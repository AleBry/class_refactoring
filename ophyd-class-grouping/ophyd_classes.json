[
  {
    "class_name": "BPM3",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/isr-profile-collection/startup/03-bpm.py",
    "source": "class BPM3(Device):\n    x = Cpt(EpicsMotor, \"Ax:X}Mtr\")\n    y = Cpt(EpicsMotor, \"Ax:Y}Mtr\")"
  },
  {
    "class_name": "EigerSimulatedFilePlugin",
    "bases": [
      "Device",
      "FileStoreBase"
    ],
    "file": "profile-collections/isr-profile-collection/startup/20-area-detectors.py",
    "source": "class EigerSimulatedFilePlugin(Device, FileStoreBase):\n    sequence_id = ADComponent(EpicsSignalRO, \"SequenceId\")\n    file_path = ADComponent(\n        EpicsPathSignal, \"FilePath\", string=True, path_semantics=\"posix\"\n    )\n    file_write_name_pattern = ADComponent(\n        EpicsSignalWithRBV, \"FWNamePattern\", string=True\n    )\n    file_write_images_per_file = ADComponent(EpicsSignalWithRBV, \"FWNImagesPerFile\")\n    current_run_start_uid = Cpt(Signal, value=\"\", add_prefix=())\n    enable = SimpleNamespace(get=lambda: True)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._datum_kwargs_map = dict()  # store kwargs for each uid\n        self.filestore_spec = \"AD_EIGER2\"\n\n    def stage(self):\n        res_uid = new_short_uid()\n        write_path = datetime.now().strftime(self.write_path_template)\n        self.file_path.set(write_path).wait()\n        self.file_write_name_pattern.set(\"{}_$id\".format(res_uid)).wait()\n        super().stage()\n        fn = PurePath(self.file_path.get()) / res_uid\n        ipf = int(self.file_write_images_per_file.get())\n        # logger.debug(\"Inserting resource with filename %s\", fn)\n        self._fn = fn\n        res_kwargs = {\"images_per_file\": ipf}\n        self._generate_resource(res_kwargs)\n\n    def generate_datum(self, key, timestamp, datum_kwargs):\n        # The detector keeps its own counter which is uses label HDF5\n        # sub-files.  We access that counter via the sequence_id\n        # signal and stash it in the datum.\n        seq_id = 1 + int(self.sequence_id.get())  # det writes to the NEXT one\n        datum_kwargs.update({\"seq_id\": seq_id})\n        return super().generate_datum(key, timestamp, datum_kwargs)"
  },
  {
    "class_name": "SSASlit",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/isr-profile-collection/startup/70-quadem.py",
    "source": "class SSASlit(Device):\n    x_cntr = Cpt(EpicsMotor, \"-Ax:XT}Mtr\")\n    x_gap = Cpt(EpicsMotor, \"-Ax:XO}Mtr\")\n    y_cntr = Cpt(EpicsMotor, \"-Ax:YT}Mtr\")\n    y_gap = Cpt(EpicsMotor, \"-Ax:YO}Mtr\")\n    current = Cpt(\n        QuadEMWithPortSS,\n        \"XF:04IDB-BI:1{EM:3}EM180:\",\n        add_prefix=(),\n        read_attrs=[\"sum_all.mean_value\"]\n        + [f\"current{j}.mean_value\" for j in range(1, 5)],\n        lazy=True,\n    )"
  },
  {
    "class_name": "BPM1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/isr-profile-collection/startup/70-quadem.py",
    "source": "class BPM1(Device):\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    y = Cpt(EpicsMotor, \"-Ax:Y}Mtr\")\n    current = Cpt(\n        QuadEMWithPort,\n        \"XF:04IDA-BI:1{EM:1}EM180:\",\n        add_prefix=(),\n        read_attrs=[\"sum_all.mean_value\"]\n        + [f\"current{j}.mean_value\" for j in range(1, 5)],\n    )"
  },
  {
    "class_name": "BPM2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/isr-profile-collection/startup/70-quadem.py",
    "source": "class BPM2(Device):\n    x_cntr = Cpt(EpicsMotor, \"-Ax:XCtr}Mtr\")\n    x_gap = Cpt(EpicsMotor, \"-Ax:XGap}Mtr\")\n    y_cntr = Cpt(EpicsMotor, \"-Ax:YCtr}Mtr\")\n    y_gap = Cpt(EpicsMotor, \"-Ax:YGap}Mtr\")\n    current = Cpt(\n        QuadEMWithPort,\n        \"XF:04IDA-BI:1{EM:2}EM180:\",\n        add_prefix=(),\n        read_attrs=[\"sum_all.mean_value\"]\n        + [f\"current{j}.mean_value\" for j in range(1, 5)],\n    )"
  },
  {
    "class_name": "VirtualMotorCenterAndGap",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/isr-profile-collection/startup/01-machine.py",
    "source": "class VirtualMotorCenterAndGap(Device):\n    \"Center and gap with virtual motors\"\n    x_cntr = Cpt(VirtualCenter, \"-Ax:X}\")\n    y_cntr = Cpt(VirtualCenter, \"-Ax:Y}\")\n    x_gap = Cpt(VirtualGap, \"-Ax:X}\")\n    y_gap = Cpt(VirtualGap, \"-Ax:Y}\")"
  },
  {
    "class_name": "AttenuatorBank",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/isr-profile-collection/startup/15-attenuators.py",
    "source": "class AttenuatorBank(Device):\n    attn1 = Cpt(AttnShutter, \"{Fil:1}\")\n    attn2 = Cpt(AttnShutter, \"{Fil:2}\")\n    attn3 = Cpt(AttnShutter, \"{Fil:3}\")\n    attn4 = Cpt(AttnShutter, \"{Fil:4}\")\n\n    def set_attenuation_level(self, n):\n        s1, s2, s3, s4 = [{\"0\": \"Close\", \"1\": \"Open\"}[v] for v in format(n, \"04b\")]\n        yield from bps.mv(\n            bank.attn1,\n            s1,\n            bank.attn2,\n            s2,\n            bank.attn3,\n            s3,\n            bank.attn4,\n            s4,\n        )"
  },
  {
    "class_name": "DCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/isr-profile-collection/startup/04-dcm.py",
    "source": "class DCM(Device):\n    brag_th = Cpt(EpicsMotor, \"-Ax:th}Mtr\")\n    cb = Cpt(EpicsMotor, \"-Ax:CB}Mtr\")\n    z = Cpt(EpicsMotor, \"-Ax:Z}Mtr\")\n    y2 = Cpt(EpicsMotor, \"-Ax:Y2}Mtr\")\n    th2 = Cpt(EpicsMotor, \"-Ax:th2}Mtr\")\n    chi2 = Cpt(EpicsMotor, \"-Ax:chi2}Mtr\")\n\n    th2f = Cpt(EpicsMotor, \"-Ax:th2f}Mtr\")\n    chi2f = Cpt(EpicsMotor, \"-Ax:chi2f}Mtr\")"
  },
  {
    "class_name": "Mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/isr-profile-collection/startup/02-mirrors.py",
    "source": "class Mirror(Device):\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    pitch = Cpt(EpicsMotor, \"-Ax:P}Mtr\")\n    y = Cpt(EpicsMotor, \"-Ax:Y}Mtr\")\n    yaw = Cpt(EpicsMotor, \"-Ax:Yaw}Mtr\")\n    roll = Cpt(EpicsMotor, \"-Ax:R}Mtr\")"
  },
  {
    "class_name": "ScalerMCA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/25-sclr.py",
    "source": "class ScalerMCA(Device):\n    _default_read_attrs = (\"channels\", \"current_channel\")\n    _default_configuration_attrs = (\"nuse\", \"prescale\")\n\n    # things to be read as data\n    channels = DDC({f\"mca{k:02d}\": (EpicsSignal, f\"mca{k}\", {}) for k in range(1, 21)})\n    current_channel = C(EpicsSignal, \"CurrentChannel\")\n    # configuration details\n    nuse = C(EpicsSignal, \"NuseAll\", kind=\"config\")\n    prescale = C(EpicsSignal, \"Prescale\", kind=\"config\")\n    channel_advance = C(EpicsSignal, \"ChannelAdvance\")\n\n    # control PVs\n\n    # high is acquiring\n    with kind_context(\"omitted\") as Co:\n        status = Co(EpicsSignal, \"Acquiring\", string=True)\n        startall = Co(EpicsSignal, \"StartAll\", string=True)\n        stopall = Co(EpicsSignal, \"StopAll\", string=True)\n        eraseall = Co(EpicsSignal, \"EraseAll\", string=True)\n        erasestart = Co(EpicsSignal, \"EraseStart\", string=True)\n\n    def stage(self):\n        staged_cmpts = super().stage()\n        self.eraseall.put(\"Erase\")\n        return staged_cmpts\n\n    def stop(self):\n        self.stopall.put(\"Stop\")\n\n    def trigger(self):\n        self.erasestart.put(\"Erase\")\n\n        return StatusBase(done=True, success=True)\n\n    def read(self):\n        # TODO handle file writing and document generation\n        return super().read()"
  },
  {
    "class_name": "Scaler",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/25-sclr.py",
    "source": "class Scaler(Device):\n    # MCAs\n    mcas = C(ScalerMCA, \"\")\n    # TODO maybe an issue with the timing around the triggering?\n    cnts = C(FixedScalerCH, \"scaler1\")\n\n    def __init__(self, *args, mode=\"counting\", **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_mode(mode)\n\n    def match_names(self, N=20):\n        self.cnts.match_names()\n        for j in range(1, N + 1):\n            mca_ch = getattr(self.mcas.channels, f\"mca{j:02d}\")\n            ct_ch = getattr(self.cnts.channels, f\"chan{j:02d}\")\n            mca_ch.name = ct_ch.chname.get()\n\n    # TODO put a soft signal around this so we can stage it\n    def set_mode(self, mode):\n        if mode == \"counting\":\n            self.read_attrs = [\"cnts\"]\n            self.configuration_attrs = [\"cnts\"]\n        elif mode == \"flying\":\n            self.read_attrs = [\"mcas\"]\n            self.configuration_attrs = [\"mcas\"]\n        else:\n            raise ValueError\n\n        self._mode = mode\n\n    def trigger(self):\n        if self._mode == \"counting\":\n            return self.cnts.trigger()\n        elif self._mode == \"flying\":\n            return self.mcas.trigger()\n        else:\n            raise ValueError\n\n    def stage(self):\n        if self._mode == \"counting\":\n            staged_cmpts = self.cnts.stage()\n        elif self._mode == \"flying\":\n            staged_cmpts = self.mcas.stage()\n        else:\n            raise ValueError\n        self.match_names()\n        return staged_cmpts\n\n    def unstage(self):\n        if self._mode == \"counting\":\n            unstaged_cmpts = self.cnts.unstage()\n        elif self._mode == \"flying\":\n            unstaged_cmpts = self.mcas.unstage()\n        else:\n            raise ValueError\n        self.match_names()\n        return unstaged_cmpts"
  },
  {
    "class_name": "TestingStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/21-testing-stage.py",
    "source": "class TestingStage(Device):\n    x = Cpt(EpicsMotor, \"1}Mtr\")"
  },
  {
    "class_name": "SampleStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/21-testing-stage.py",
    "source": "class SampleStage(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")"
  },
  {
    "class_name": "XYStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/20-motors.py",
    "source": "class XYStage(Device):\n    x = Cpt(MresMotor, \"X}Mtr\")\n    y = Cpt(MresMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")"
  },
  {
    "class_name": "Mono",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/20-motors.py",
    "source": "class Mono(Device):\n    # pseudo axis and configuration\n    energy = Cpt(EpicsMotor, \"x08bm:mon\")\n    cal = Cpt(EpicsSignal, \"x08bm:mono_cal\")\n    e_back = Cpt(EpicsSignal, \"x08bm:E_back\")\n\n    # linear drive\n    linear = Cpt(MresMotor, \"XF:08BMA-OP{Mono:1-Ax:Linear}Mtr\")\n    tilt = Cpt(MresMotor, \"XF:08BMA-OP{Mono:1-Ax:Tilt}Mtr\")"
  },
  {
    "class_name": "ToroidalMirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/20-motors.py",
    "source": "class ToroidalMirror(Device):\n    dsy = Cpt(EpicsMotor, \"XD}Mtr\")\n    usy = Cpt(EpicsMotor, \"XU}Mtr\")\n    dsh = Cpt(EpicsMotor, \"YD}Mtr\")  # Should move high to low\n    ush = Cpt(EpicsMotor, \"YU}Mtr\")"
  },
  {
    "class_name": "SSA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/20-motors.py",
    "source": "class SSA(Device):\n    inboard = Cpt(EpicsMotor, \"I}Mtr\")\n    outboard = Cpt(EpicsMotor, \"O}Mtr\")"
  },
  {
    "class_name": "KBMirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/20-motors.py",
    "source": "class KBMirror(Device):\n    dsh = Cpt(EpicsMotor, \"BD}Mtr\")\n    ush = Cpt(EpicsMotor, \"YD}Mtr\")\n\n    # BL staff does not want to expose these EpicsMotors PVs via ophyd/bluesky as they are manually controlled via CSS,\n    # therefore we add individual components to read the values and record them as configuration attrs:\n    dsb_rbv = Cpt(EpicsSignalRO, \"BU}Mtr.RBV\", kind=\"config\")\n    dsb = Cpt(EpicsSignalRO, \"BU}Mtr.VAL\", kind=\"config\")\n    usb_rbv = Cpt(EpicsSignalRO, \"YU}Mtr.RBV\", kind=\"config\")\n    usb = Cpt(EpicsSignalRO, \"YU}Mtr.VAL\", kind=\"config\")"
  },
  {
    "class_name": "Robot_Smart",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/20-motors.py",
    "source": "class Robot_Smart(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")\n    ry = Cpt(EpicsMotor, \"Ry}Mtr\")"
  },
  {
    "class_name": "Sample_Smart",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/20-motors.py",
    "source": "class Sample_Smart(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")\n    ry = Cpt(EpicsMotor, \"Ry}Mtr\")"
  },
  {
    "class_name": "SDD_Smart",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/20-motors.py",
    "source": "class SDD_Smart(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")"
  },
  {
    "class_name": "VideoStreamDet",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/27-vstream-cam.py",
    "source": "class VideoStreamDet(Device):\n    image = Cpt(ExternalFileReference, kind=\"normal\")\n    mean = Cpt(Signal, value=0.0, kind=\"hinted\")\n    exposure_time = Cpt(Signal, value=1.0, kind=\"config\")\n\n    def __init__(\n        self,\n        *args,\n        root_dir=\"/tmp/video-stream-data\",\n        assets_dir=None,\n        video_stream_url=None,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n\n        self._root_dir = root_dir\n        self._assets_dir = assets_dir\n        self._video_stream_url = video_stream_url\n\n        self._asset_docs_cache = deque()\n        self._resource_document = None\n        self._datum_factory = None\n\n        self._frame_shape = (480, 704)\n\n    def stage(self):\n        super().stage()\n        date = datetime.datetime.now()\n        self._assets_dir = date.strftime(\"%Y/%m/%d\")\n        data_file = f\"{new_uid()}.h5\"\n\n        self._resource_document, self._datum_factory, _ = compose_resource(\n            start={\"uid\": \"needed for compose_resource() but will be discarded\"},\n            spec=\"VIDEO_STREAM_HDF5\",\n            root=self._root_dir,\n            resource_path=str(Path(self._assets_dir) / Path(data_file)),\n            resource_kwargs={},\n        )\n\n        self._data_file = str(\n            Path(self._resource_document[\"root\"])\n            / Path(self._resource_document[\"resource_path\"])\n        )\n\n        # now discard the start uid, a real one will be added later\n        self._resource_document.pop(\"run_start\")\n        self._asset_docs_cache.append((\"resource\", self._resource_document))\n\n        logger.debug(f\"{self._data_file = }\")\n\n        self._h5file_desc = h5py.File(self._data_file, \"x\")\n        group = self._h5file_desc.create_group(\"/entry\")\n        self._dataset = group.create_dataset(\"averaged\",\n                                             data=np.full(fill_value=np.nan,\n                                                          shape=(1, *self._frame_shape)),\n                                             maxshape=(None, *self._frame_shape),\n                                             chunks=(1, *self._frame_shape),\n                                             dtype=\"float64\",\n                                             compression=\"lzf\")\n        self._counter = itertools.count()\n\n    def trigger(self, *args, **kwargs):\n        super().trigger(*args, **kwargs)\n\n        frames = []\n        times = []\n\n        start = ttime.monotonic()\n        i = 0\n        cap = cv2.VideoCapture(self._video_stream_url)\n        while True:\n            logger.debug(f\"Iteration: {i}\")\n            i += 1\n            ret, frame = cap.read()\n            frames.append(frame)\n            times.append(ttime.time())\n\n            # cv2.imshow('Video', frame)\n            logger.debug(f\"shape: {frame.shape}\")\n\n            if ttime.monotonic() - start >= self.exposure_time.get():\n                break\n\n            if cv2.waitKey(1) == 27:\n                exit(0)\n\n        frames = np.array(frames)\n        logger.debug(f\"original shape: {frames.shape}\")\n        # Averaging over all frames and summing 3 RGB channels\n        averaged = frames.mean(axis=0).sum(axis=-1)\n\n        current_frame = next(self._counter)\n        self._dataset.resize((current_frame + 1, *self._frame_shape))\n        logger.debug(f\"{self._dataset = }\\n{self._dataset.shape = }\")\n        self._dataset[current_frame, :, :] = averaged\n\n        datum_document = self._datum_factory(datum_kwargs={\"frame\": current_frame})\n        self._asset_docs_cache.append((\"datum\", datum_document))\n\n        self.image.put(datum_document[\"datum_id\"])\n        self.mean.put(averaged.mean())\n\n        return NullStatus()\n\n    def describe(self):\n        res = super().describe()\n        res[self.image.name].update(dict(shape=self._frame_shape))\n        return res\n\n    def unstage(self):\n        super().unstage()\n        del self._dataset\n        self._h5file_desc.close()\n        self._resource_document = None\n        self._datum_factory = None\n\n    def collect_asset_docs(self):\n        items = list(self._asset_docs_cache)\n        self._asset_docs_cache.clear()\n        for item in items:\n            yield item"
  },
  {
    "class_name": "PShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/tes-profile-collection/startup/22-shutters.py",
    "source": "class PShutter(Device):\n    # TODO: extend the class to take care of the flaky state switching.\n    open_cmd = Cpt(EpicsSignal, \"Cmd:Opn-Cmd\")\n    close_cmd = Cpt(EpicsSignal, \"Cmd:Cls-Cmd\")\n    status = Cpt(EpicsSignalRO, \"Pos-Sts\")"
  },
  {
    "class_name": "DarkFrameCache",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/81-pe-callbacks.py",
    "source": "class DarkFrameCache(Device):\n    def __init__(self, *args, **kwargs):\n        # self.det = det\n        self.last_collected = None\n        self.just_started = True\n        self.update_done = False\n        return super().__init__(*args, **kwargs)\n\n    def read(self):\n        return self._read\n\n    def read_configuration(self):\n        return self._read_configuration\n\n    @property\n    def configuration_attrs(self):\n        return self._configuration_attrs\n\n    @property\n    def read_attrs(self):\n        return self._read_attrs\n\n    def describe(self):\n        return self._describe\n\n    def describe_configuration(self):\n        return self._describe_configuration\n\n    # def describe_configuration(self):\n    #     return self.det.describe_configuration\n\n    def collect_asset_docs(self):\n        # keep track of when we get restaged to restore these\n        yield from self._asset_docs_cache\n        self._really_cached = self._asset_docs_cache\n        self._asset_docs_cache = []\n\n    def stage(self):\n        self._asset_docs_cache = self._really_cached"
  },
  {
    "class_name": "EPS_Shutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class EPS_Shutter(Device):\n    state = Cpt(EpicsSignal, 'Pos-Sts')\n    cls = Cpt(EpicsSignal, 'Cmd:Cls-Cmd')\n    opn = Cpt(EpicsSignal, 'Cmd:Opn-Cmd')\n    error = Cpt(EpicsSignal,'Err-Sts')\n    permit = Cpt(EpicsSignal, 'Permit:Enbl-Sts')\n    enabled = Cpt(EpicsSignal, 'Enbl-Sts')\n\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.color = 'red'\n\n    def open_plan(self):\n        yield from mv(self.opn, 1,wait=True)\n\n    def close_plan(self):\n        yield from abs_set(self.cls, 1, wait=True)\n\n    def open(self):\n        print('Opening {}'.format(self.name))\n        self.opn.put(1)\n\n    def close(self):\n        print('Closing {}'.format(self.name))\n        self.cls.put(1)"
  },
  {
    "class_name": "QASFastShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class QASFastShutter(Device):\n    IO_status = Cpt(EpicsSignal, '', kind='omitted')\n    status = Cpt(EpicsSignal, '', kind='omitted', string=True)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.setmap = {'Open': 1, 'Close': 0}\n        self.readmap = {v: k for k, v in self.setmap.items()}\n        self.status.get = self.get\n        self.status.set = self.set\n\n    def set(self, val):\n        return self.IO_status.set(self.setmap[val])\n\n    def get(self):\n        return self.readmap[self.IO_status.get()]\n\n    def read(self):\n        d = super().read()\n        d[self.name] = {'value': self.get(), 'timestamp': time.time()}\n        return d"
  },
  {
    "class_name": "LinkamThermal",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class LinkamThermal(Device):\n\n    #Set-and-read signals\n    cmd = Cpt(EpicsSignal, 'STARTHEAT')\n    temperature_setpoint = Cpt(EpicsSignal, 'SETPOINT:SET')\n    temperature_rate_setpoint = Cpt(EpicsSignal, 'RAMPRATE:SET')\n\n    #Read-Only signals\n    status_power = Cpt(EpicsSignalRO, 'STARTHEAT')\n    status_code =  Cpt(EpicsSignalRO, 'STATUS') \n    # status_code = Cpt(EpicsSignal, 'STATUS')\n    # done = Cpt(AtSetpoint, parent_attr = 'status_code')\n    temperature_current = Cpt(EpicsSignalRO, 'TEMP')\n    temperature_rate_current = Cpt(EpicsSignalRO, 'RAMPRATE')\n\n    #not commonly used\n    init = Cpt(EpicsSignal, 'INIT')\n    model_array = Cpt(EpicsSignal, 'MODEL')\n    serial_array = Cpt(EpicsSignal, 'SERIAL')\n    stage_model_array = Cpt(EpicsSignal, 'STAGE:MODEL')\n    stage_serial_array = Cpt(EpicsSignal, 'STAGE:SERIAL')\n    firm_ver = Cpt(EpicsSignal, 'FIRM:VER')\n    hard_ver = Cpt(EpicsSignal, 'HARD:VER')\n    ctrllr_err = Cpt(EpicsSignal, 'CTRLLR:ERR')\n    config = Cpt(EpicsSignal, 'CONFIG')\n    stage_config = Cpt(EpicsSignal, 'STAGE:CONFIG')\n    disable = Cpt(EpicsSignal, 'DISABLE')\n    dsc = Cpt(EpicsSignal, 'DSC')\n    # RR_set = Cpt(EpicsSignal, 'RAMPRATE:SET')\n    # RR = Cpt(EpicsSignal, 'RAMPRATE')\n    ramptime = Cpt(EpicsSignal, 'RAMPTIME')\n    # startheat = Cpt(EpicsSignal, 'STARTHEAT')\n    holdtime_set = Cpt(EpicsSignal, 'HOLDTIME:SET')\n    holdtime = Cpt(EpicsSignal, 'HOLDTIME')\n    power = Cpt(EpicsSignalRO, 'POWER')\n    lnp_speed = Cpt(EpicsSignal, 'LNP_SPEED')\n    lnp_mode_set = Cpt(EpicsSignal, 'LNP_MODE:SET')\n    lnp_speed_set = Cpt(EpicsSignal, 'LNP_SPEED:SET')\n    ramprate = Cpt(EpicsSignal, 'RAMPRATE')\n    ramprate_set = Cpt(EpicsSignal, 'RAMPRATE:SET')\n\n\n    def on(self):\n        return self.cmd.put(1)\n\n    def _on(self):\n        yield from bps.mv(self.cmd,1)\n\n    def off(self):\n        return self.cmd.put(0)\n\n    def _off(self):\n        yield from bps.mv(self.cmd,0)\n\n    def setTemperature(self, temperature):\n        return self.temperature_setpoint.put(temperature)\n\n    def setTemperatureRate(self, temperature_rate):\n        return self.temperature_rate_setpoint.put(temperature_rate)\n\n    def temperature(self):\n        return self.temperature_current.get()\n\n    def temperatureRate(self):\n        return self.temperature_rate_current.get()\n\n    @property\n    def serial(self):\n        return self.arr2word(self.serial_array.get())\n\n    @property\n    def model(self):\n        return self.arr2word(self.model_array.get())\n    \n    @property\n    def stage_model(self):\n        return self.arr2word(self.stage_model_array.get())\n    \n    @property\n    def stage_serial(self):\n        return self.arr2word(self.stage_serial_array.get())\n\n    @property\n    def firmware_version(self):\n        return self.arr2word(self.firm_ver.get())\n\n    @property\n    def hardware_version(self):\n        return self.arr2word(self.hard_ver.get())\n\n    def status(self):\n        text = f'\\nCurrent temperature = {self.temperature():.1f}, setpoint = {self.temperature_setpoint.get():.1f}\\n\\n'\n        code = int(self.status_code.get())\n        \n        if code & 1:  #Error\n            text += 'Error        : yes' + '\\n'\n        else:\n            text += 'Error        : no\\n'\n        if code & 2: # at setpoint \n            text += 'At setpoint  : yes' + '\\n'\n        else:\n            text += 'At setpoint  : no\\n'\n        if code & 4: #heater\n            text += 'Heater       : on' + '\\n'\n        else:\n            text += 'Heater       : off\\n'\n        if code & 8: #pump\n            text += 'Pump         : on' + '\\n'\n        else:\n            text += 'Pump         : off\\n'\n        if code & 16: # pump auto\n            text += 'Pump Auto    : yes' + '\\n'\n        else:\n            text += 'Pump Auto    : no\\n'\n            \n        print( text )"
  },
  {
    "class_name": "EPS_MFC",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class EPS_MFC(Device):\n    ch1_he_rb = Cpt(EpicsSignal, '-AI}MFC1_FB')\n    ch1_he_sp = Cpt(EpicsSignal, '-AO}MFC1_SP')\n\n    ch2_n2_rb = Cpt(EpicsSignal, '-AI}MFC2_FB')\n    ch2_n2_sp = Cpt(EpicsSignal, '-AO}MFC2_SP')\n\n    ch3_ar_rb = Cpt(EpicsSignal, '-AI}MFC3_FB')\n    ch3_ar_sp = Cpt(EpicsSignal, '-AO}MFC3_SP')\n\n    ch4_n2_rb = Cpt(EpicsSignal, '-AI}MFC4_FB')\n    ch4_n2_sp = Cpt(EpicsSignal, '-AO}MFC4_SP')\n\n    ch5_ar_rb = Cpt(EpicsSignal, '-AI}MFC5_FB')\n    ch5_ar_sp = Cpt(EpicsSignal, '-AO}MFC5_SP')"
  },
  {
    "class_name": "EPS_MFC1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class EPS_MFC1(Device):\n    flow_rb = Cpt(EpicsSignal, '-AI}MFC1_FB')\n    flow_sp = Cpt(EpicsSignal, '-AO}MFC1_SP')"
  },
  {
    "class_name": "EPS_MFC2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class EPS_MFC2(Device):\n    flow_rb = Cpt(EpicsSignal, '-AI}MFC2_FB')\n    flow_sp = Cpt(EpicsSignal, '-AO}MFC2_SP')"
  },
  {
    "class_name": "EPS_MFC3",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class EPS_MFC3(Device):\n    flow_rb = Cpt(EpicsSignal, '-AI}MFC3_FB')\n    flow_sp = Cpt(EpicsSignal, '-AO}MFC3_SP')"
  },
  {
    "class_name": "EPS_MFC4",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class EPS_MFC4(Device):\n    flow_rb = Cpt(EpicsSignal, '-AI}MFC4_FB')\n    flow_sp = Cpt(EpicsSignal, '-AO}MFC4_SP')"
  },
  {
    "class_name": "EPS_MFC5",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class EPS_MFC5(Device):\n    flow_rb = Cpt(EpicsSignal, '-AI}MFC5_FB')\n    flow_sp = Cpt(EpicsSignal, '-AO}MFC5_SP')"
  },
  {
    "class_name": "DIODE_MFC",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class DIODE_MFC(Device):\n    ch1_c_he_rb = Cpt(EpicsSignal, ':1}Gas:Flow-I')\n    ch1_c_he_sp = Cpt(EpicsSignal, ':1}Gas:Flow-SP')\n\n    ch2_c_n2_rb = Cpt(EpicsSignal, ':2}Gas:Flow-I')\n    ch2_c_n2_sp = Cpt(EpicsSignal, ':2}Gas:Flow-SP')\n\n    ch3_c_ar_rb = Cpt(EpicsSignal, ':3}Gas:Flow-I')\n    ch3_c_ar_sp = Cpt(EpicsSignal, ':3}Gas:Flow-SP')\n\n    ch4_c_n2_rb = Cpt(EpicsSignal, ':4}Gas:Flow-I')\n    ch4_c_n2_sp = Cpt(EpicsSignal, ':4}Gas:Flow-SP')\n\n    ch5_c_ar_rb = Cpt(EpicsSignal, ':5}Gas:Flow-I')\n    ch5_c_ar_sp = Cpt(EpicsSignal, ':5}Gas:Flow-SP')"
  },
  {
    "class_name": "DIODE_MFC1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class DIODE_MFC1(Device):\n    flow_rb = Cpt(EpicsSignal, ':1}Gas:Flow-I')\n    flow_sp = Cpt(EpicsSignal, ':1}Gas:Flow-SP')"
  },
  {
    "class_name": "DIODE_MFC2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class DIODE_MFC2(Device):\n    flow_rb = Cpt(EpicsSignal, ':2}Gas:Flow-I')\n    flow_sp = Cpt(EpicsSignal, ':2}Gas:Flow-SP')"
  },
  {
    "class_name": "DIODE_MFC3",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class DIODE_MFC3(Device):\n    flow_rb = Cpt(EpicsSignal, ':3}Gas:Flow-I')\n    flow_sp = Cpt(EpicsSignal, ':3}Gas:Flow-SP')"
  },
  {
    "class_name": "DIODE_MFC4",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class DIODE_MFC4(Device):\n    flow_rb = Cpt(EpicsSignal, ':4}Gas:Flow-I')\n    flow_sp = Cpt(EpicsSignal, ':4}Gas:Flow-SP')"
  },
  {
    "class_name": "DIODE_MFC5",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class DIODE_MFC5(Device):\n    flow_rb = Cpt(EpicsSignal, ':5}Gas:Flow-I')\n    flow_sp = Cpt(EpicsSignal, ':5}Gas:Flow-SP')"
  },
  {
    "class_name": "Lakeshore336Setpoint",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class Lakeshore336Setpoint(Device):\n    readback = Cpt(EpicsSignalRO, 'Chan:A}T-I')\n    setpoint = Cpt(EpicsSignal, 'Out:1}T-SP')\n    ramp_rate = Cpt(EpicsSignal, 'Out:1}Val:Ramp-SP')\n    done = Cpt(EpicsSignalRO, 'Out:1}Enbl:Ramp-Sts')\n    ramp_enabled = Cpt(EpicsSignal, 'Out:1}Enbl:Ramp-Sel')\n    done_value = 0"
  },
  {
    "class_name": "WienerPowerSupply",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class WienerPowerSupply(Device):\n    i0_plate_rb = Cpt(EpicsSignal, 'u300}V-Sense')\n    i0_plate_sp = Cpt(EpicsSignal, 'u300}V-Set')\n\n    i0_grid_rb = Cpt(EpicsSignal, 'u301}V-Sense')\n    i0_grid_sp = Cpt(EpicsSignal, 'u301}V-Set')\n\n    it_plate_rb = Cpt(EpicsSignal, 'u302}V-Sense')\n    it_plate_sp = Cpt(EpicsSignal, 'u302}V-Set')\n\n    it_grid_rb = Cpt(EpicsSignal, 'u303}V-Sense')\n    it_grid_sp = Cpt(EpicsSignal, 'u303}V-Set')\n\n    ir_plate_rb = Cpt(EpicsSignal, 'u304}V-Sense')\n    ir_plate_sp = Cpt(EpicsSignal, 'u304}V-Set')\n\n    ir_grid_rb = Cpt(EpicsSignal, 'u305}V-Sense')\n    ir_grid_sp = Cpt(EpicsSignal, 'u305}V-Set')"
  },
  {
    "class_name": "ICAmplifier",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class ICAmplifier(Device):\n\n    gain = Cpt(EpicsSignal,'Gain')\n    risetime = Cpt(EpicsSignal,'RiseTime')\n    supr_mode = Cpt(EpicsSignal, 'SuppressionMode')\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n\n    def get_gain(self):\n        return self.gain.get()+3\n\n    def set_gain(self, gain):\n        self.gain.set(gain-3)\n\n    def set_gain_plan(self, gain):\n        yield from bps.abs_set(self.gain, gain-3)"
  },
  {
    "class_name": "WPS_Scan",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/22-devices.py",
    "source": "class WPS_Scan(Device):\n    setpoint = Cpt(EpicsSignal, '-Set')\n    readback = Cpt(EpicsSignalRO, '-Sense')\n\n    def set(self, value):\n        return self.setpoint.set(value).wait()\n\n    def read(self):\n        return {'WPS_scan': {'value':self.readback.get(), 'timestamp': time.time()}}\n\n    def describe(self):\n        return {'WPS_scan': {'source': 'PV-Sense', 'dtype': 'number', 'shape': []}}\n\n    def stop(self, *, success=False):\n        self.setpoint.stop()\n\n    def is_moving(self):\n        return False\n\n    def read_configuration(self):\n        return {}\n\n    def describe_configuration(self):\n        return {}"
  },
  {
    "class_name": "Accelerator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/08-accelerator.py",
    "source": "class Accelerator(Device):\n    beam_current = Cpt(EpicsSignal, ':OPS-BI{DCCT:1}I:Real-I')\n    life_time = Cpt(EpicsSignal, ':OPS-BI{DCCT:1}Lifetime-I')\n    status = Cpt(EpicsSignal,'-OPS{}Mode-Sts')"
  },
  {
    "class_name": "Xspress3FileStoreFlyable",
    "bases": [
      "Xspress3FileStore"
    ],
    "file": "profile-collections/qas-profile-collection/startup/41-xspress3x.py",
    "source": "class Xspress3FileStoreFlyable(Xspress3FileStore):\n    def warmup(self):\n        \"\"\"\n        A convenience method for 'priming' the plugin.\n        The plugin has to 'see' one acquisition before it is ready to capture.\n        This sets the array size, etc.\n        NOTE : this comes from:\n            https://github.com/NSLS-II/ophyd/blob/master/ophyd/areadetector/plugins.py\n        We had to replace \"cam\" with \"settings\" here.\n        Also modified the stage sigs.\n        \"\"\"\n        print(\"warming up the hdf5 plugin...\")\n        self.enable.set(1).wait()\n        sigs = OrderedDict([(self.parent.settings.array_callbacks, 1),\n                            (self.parent.settings.trigger_mode, 'Internal'),\n                            # just in case the acquisition time is set very long...\n                            (self.parent.settings.acquire_time, 1),\n                            # (self.capture, 1),\n                            (self.parent.settings.acquire, 1)])\n\n        original_vals = {sig: sig.get() for sig in sigs}\n\n        # Remove the hdf5.capture item here to avoid an error as it should reset back to 0 itself\n        # del original_vals[self.capture]\n\n        for sig, val in sigs.items():\n            ttime.sleep(0.1)  # abundance of caution\n            sig.set(val).wait()\n\n        ttime.sleep(2)  # wait for acquisition\n\n        for sig, val in reversed(list(original_vals.items())):\n            ttime.sleep(0.1)\n            sig.set(val).wait()\n        print(\"done\")"
  },
  {
    "class_name": "AnalogPizzaBoxTrigger",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/30-apb_trigger.py",
    "source": "class AnalogPizzaBoxTrigger(Device):\n    freq = Cpt(EpicsSignal,'Frequency-SP')\n    duty_cycle = Cpt(EpicsSignal,'DutyCycle-SP')\n    max_counts = Cpt(EpicsSignal,'MaxCount-SP')\n\n    acquire = Cpt(EpicsSignal, 'Mode-SP')\n    acquiring = Cpt(EpicsSignal, 'Status-I')\n    filename = Cpt(EpicsSignal,'Filename-SP')\n    filebin_status = Cpt(EpicsSignalRO,'File:Status-I')\n    stream = Cpt(EpicsSignal,'Stream:Mode-SP')\n\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._acquiring = None\n\n        self._asset_docs_cache = deque()\n        self._resource_uid = None\n        self._datum_counter = None\n\n    # Step-scan interface\n    def stage(self, *args, **kwargs):\n        file_uid = new_uid()\n        # self.filename_target = f'{ROOT_PATH}/data/apb/{dt.datetime.strftime(dt.datetime.now(), \"%Y/%m/%d\")}/{file_uid}'\n        # Note: temporary static file name in GPFS, due to the limitation of 40 symbols in the filename field.\n        # self.filename = f'{ROOT_PATH}/data/apb/{file_uid[:8]}'\n        self.fn = f'{ROOT_PATH}/raw/apb/{dt.datetime.strftime(dt.datetime.now(), \"%Y/%m/%d\")}/{file_uid}.bin'\n        self.filename.put(f'{self.fn}')\n\n        self._resource_uid = new_uid()\n        resource = {'spec': 'APB_TRIGGER',\n                    'root': ROOT_PATH,  # from 00-startup.py (added by mrakitin for future generations :D)\n                    'resource_path': f'{self.fn}',\n                    'resource_kwargs': {},\n                    'path_semantics': os.name,\n                    'uid': self._resource_uid}\n        self._asset_docs_cache.append(('resource', resource))\n        self._datum_counter = itertools.count()\n\n        # def callback(value, old_value, **kwargs):\n        #     # print(f'{ttime.time()} {old_value} ---> {value}')\n        #     if self._acquiring and int(round(old_value)) == 1 and int(round(value)) == 0:\n        #         self._acquiring = False\n        #         return True\n        #     else:\n        #         self._acquiring = True\n        #         return False\n        #\n        # status = SubscriptionStatus(self.acquire, callback)\n        # self.tiff.capture.put(1)\n        # self.hdf5.capture.put(1)\n        # self.cam.acquire.put(1)\n\n        self.stream.put(1)\n        ttime.sleep(0.2)\n        self.acquire.put(2)\n        # st_super = super().stage(*args, **kwargs)\n        return super().stage(*args, **kwargs)\n\n\n    def unstage(self, *args, **kwargs):\n        self._datum_counter = None\n        self.acquire.put(0)\n        self.stream.put(0)\n        return super().unstage(*args, **kwargs)\n\n    def prepare_to_fly(self, traj_duration):\n        self.num_points = int(self.freq.get() * (traj_duration + 1))\n\n    def complete(self, *args, **kwargs):\n        def callback_saving(value, old_value, **kwargs):\n            if int(round(old_value)) == 1 and int(round(value)) == 0:\n                self.acquire.put(0)\n                self.stream.put(0)\n                return True\n            else:\n                return False\n\n        filebin_st = SubscriptionStatus(self.filebin_status, callback_saving)\n        # filetxt_st = SubscriptionStatus(self.filetxt_status, callback_saving)\n\n        self._datum_ids = []\n        datum_id = '{}/{}'.format(self._resource_uid, next(self._datum_counter))\n        datum = {'resource': self._resource_uid,\n                 'datum_kwargs': {},\n                 'datum_id': datum_id}\n        self._asset_docs_cache.append(('datum', datum))\n        self._datum_ids.append(datum_id)\n        return filebin_st #& filetxt_st\n\n\n    def collect(self):\n        # print(f'APB collect is complete {ttime.ctime(ttime.time())}')\n\n        # Copied from 10-detectors.py (class EncoderFS)\n        now = ttime.time()\n        print(f\"{len(self._datum_ids) = }\")\n        for datum_id in self._datum_ids:\n            data = {self.name: datum_id}\n            yield {'data': data,\n                   'timestamps': {key: now for key in data}, 'time': now,\n                   'filled': {key: False for key in data}}\n            # print(f'yield data {ttime.ctime(ttime.time())}')\n\n        # self.unstage()\n\n\n    def describe_collect(self):\n        return_dict = {self.name:\n                           {f'{self.name}': {'source': 'APB_TRIGGER',\n                                             'dtype': 'array',\n                                             'shape': [-1, -1],\n                                             'filename': f'{self.fn}',\n                                             'external': 'FILESTORE:'}}}\n        return return_dict\n\n\n    def collect_asset_docs(self):\n        items = list(self._asset_docs_cache)\n        self._asset_docs_cache.clear()\n        for item in items:\n            yield item\n\n\n    def calc_num_points(self):\n        tr = trajectory_manager(mono1)\n        info = tr.read_info(silent=True)\n        lut = str(int(mono1.lut_number_rbv.get()))\n        traj_duration = int(info[lut]['size']) / 16000\n        acq_num_points = traj_duration * self.acq_rate.get() * 1000 * 1.3\n        self.num_points = int(round(acq_num_points, ndigits=-3))"
  },
  {
    "class_name": "Encoder",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/10-detectors.py",
    "source": "class Encoder(Device):\n    \"\"\"This class defines components but does not implement actual reading.\n\n    See EncoderFS and EncoderParser\"\"\"\n    pos_I = Cpt(EpicsSignal, '}Cnt:Pos-I')\n    sec_array = Cpt(EpicsSignal, '}T:sec_Bin_')\n    nsec_array = Cpt(EpicsSignal, '}T:nsec_Bin_')\n    pos_array = Cpt(EpicsSignal, '}Cnt:Pos_Bin_')\n    index_array = Cpt(EpicsSignal, '}Cnt:Index_Bin_')\n    data_array = Cpt(EpicsSignal, '}Data_Bin_')\n    # The '$' in the PV allows us to write 40 chars instead of 20.\n    filepath = Cpt(EpicsSignal, '}ID:File.VAL', string=True)\n    dev_name = Cpt(EpicsSignal, '}DevName')\n\n    filter_dy = Cpt(EpicsSignal, '}Fltr:dY-SP')\n    filter_dt = Cpt(EpicsSignal, '}Fltr:dT-SP')\n    reset_counts = Cpt(EpicsSignal, '}Rst-Cmd')\n\n    ignore_rb = Cpt(EpicsSignal, '}Ignore-RB')\n    ignore_sel = Cpt(EpicsSignal, '}Ignore-Sel')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._ready_to_collect = False\n        if self.connected:\n            self.ignore_sel.put(1)"
  },
  {
    "class_name": "DigitalOutput",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/10-detectors.py",
    "source": "class DigitalOutput(Device):\n    \"\"\" DigitalOutput \"\"\"\n    enable = Cpt(EpicsSignal, '}Ena-Cmd')\n    period_sp = Cpt(EpicsSignal, '}Period-SP')\n    unit_sel = Cpt(EpicsSignal, '}Unit-Sel')\n    dutycycle_sp = Cpt(EpicsSignal, '}DutyCycle-SP')\n    default_pol = Cpt(EpicsSignal, '}Dflt-Sel')\n\n    def __init__(self, *args, reg, **kwargs):\n        self._reg = reg\n        super().__init__(*args, **kwargs)\n        self._ready_to_collect = False\n        if self.connected:\n            self.enable.put(0)"
  },
  {
    "class_name": "DigitalInput",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/10-detectors.py",
    "source": "class DigitalInput(Device):\n    \"\"\"This class defines components but does not implement actual reading.\n    See DigitalInputFS \"\"\"\n    data_I = Cpt(EpicsSignal, '}Raw:Data-I_')\n    sec_array = Cpt(EpicsSignal, '}T:sec_Bin_')\n    nsec_array = Cpt(EpicsSignal, '}T:nsec_Bin_')\n    index_array = Cpt(EpicsSignal, '}Cnt:Index_Bin_')\n    data_array = Cpt(EpicsSignal, '}Data_Bin_')\n    # The '$' in the PV allows us to write 40 chars instead of 20.\n    filepath = Cpt(EpicsSignal, '}ID:File.VAL', string=True)\n    dev_name = Cpt(EpicsSignal, '}DevName')\n\n    ignore_rb = Cpt(EpicsSignal, '}Ignore-RB')\n    ignore_sel = Cpt(EpicsSignal, '}Ignore-Sel')\n\n    def __init__(self, *args, reg, **kwargs):\n        self._reg = reg\n        super().__init__(*args, **kwargs)\n        self._ready_to_collect = False\n        if self.connected:\n            self.ignore_sel.put(1)"
  },
  {
    "class_name": "PizzaBoxFS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/10-detectors.py",
    "source": "class PizzaBoxFS(Device):\n    ts_sec = Cpt(EpicsSignal, '}T:sec-I')\n    #internal_ts_sel = Cpt(EpicsSignal, '}T:Internal-Sel')\n\n    enc1 = Cpt(EncoderFS, ':1')\n    enc2 = Cpt(EncoderFS, ':2')\n    enc3 = Cpt(EncoderFS, ':3')\n    enc4 = Cpt(EncoderFS, ':4')\n    di = Cpt(DIFS, ':DI', reg=db.reg)\n    do0 = Cpt(DigitalOutput, '-DO:0', reg=db.reg)\n    do1 = Cpt(DigitalOutput, '-DO:1', reg=db.reg)\n    do2 = Cpt(DigitalOutput, '-DO:2', reg=db.reg)\n    do3 = Cpt(DigitalOutput, '-DO:3', reg=db.reg)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # must use internal timestamps or no bytes are written\n\n    def kickoff(self):\n        \"Call encoder.kickoff() for every encoder.\"\n        for attr_name in ['enc1', 'enc2', 'enc3', 'enc4']:\n            status = getattr(self, attr_name).kickoff()\n            print(\"Eli's test\", self.attr_name)\n        # it's fine to just return one of the status objects\n        return status\n\n    def collect(self):\n        \"Call encoder.collect() for every encoder.\"\n        # Stop writing data to the file in all encoders.\n        for attr_name in ['enc1', 'enc2', 'enc3', 'enc4']:\n            getattr(self, attr_name).ignore_sel.set(1).wait()\n        # Now collect the data accumulated by all encoders.\n        for attr_name in ['enc1', 'enc2', 'enc3', 'enc4']:\n            yield from getattr(self, attr_name).collect()"
  },
  {
    "class_name": "TriggerAdc",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/10-detectors.py",
    "source": "class TriggerAdc(Device):\n    file_size = Cpt(EpicsSignal, '}FileSize')\n    reset = Cpt(EpicsSignal, '}Rst-Cmd')\n    filepath = Cpt(EpicsSignal, '}ID:File.VAL', string=True)\n    sec_array = Cpt(EpicsSignal, '}T:sec_Bin_')\n    nsec_array = Cpt(EpicsSignal, '}T:nsec_Bin_')\n    #pos_array = Cpt(EpicsSignal, '}Cnt:Pos_Bin_')\n    index_array = Cpt(EpicsSignal, '}Cnt:Index_Bin_')\n    data_array = Cpt(EpicsSignal, '}Data_Bin_')\n    sample_rate = Cpt(EpicsSignal,'}F:Sample-I_', write_pv='}F:Sample-SP')\n    enable_averaging = Cpt(EpicsSignal, '}Avrg-Sts', write_pv='}Avrg-Sel')\n    averaging_points = Cpt(EpicsSignal, '}Avrg-SP')\n    averaging_points_rbv = Cpt(EpicsSignal, '}GP-ADC:Reg0-RB_')\n    dev_saturation = Cpt(EpicsSignal, '}DevSat')\n    polarity = 'neg'\n    # offset = Cpt(EpicsSignal, '}Offset')\n\n    enable_sel = Cpt(EpicsSignal, '}Ena-Sel')\n    enable_rb = Cpt(EpicsSignal, '}Ena-Sts')\n\n    def timeout_handler(self, signum, frame):\n        print(\"{}.connected timeout\".format(self.name))\n        raise Exception(\"end of time\")\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._ready_to_collect = False\n\n        #signal.signal(signal.SIGALRM, self.timeout_handler)\n        #signal.setitimer(signal.ITIMER_REAL, 2)\n        #try:\n        #    while(self.connected == False):\n        #        pass\n        if self.connected:\n            #self.enable_sel.put(1)\n            #self.sample_rate.put(350)\n            self.enable_averaging.put(1)\n            if self.averaging_points.get() == 0:\n                self.averaging_points.put(\"1024\")"
  },
  {
    "class_name": "PizzaBoxAnalogFS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/10-detectors.py",
    "source": "class PizzaBoxAnalogFS(Device):\n    #internal_ts_sel = Cpt(EpicsSignal, 'Gen}T:Internal-Sel')\n\n    adc1 = Cpt(AdcFS, 'ADC:1', reg=db.reg)\n    adc6 = Cpt(AdcFS, 'ADC:6', reg=db.reg)\n    adc7 = Cpt(AdcFS, 'ADC:7', reg=db.reg)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # must use internal timestamps or no bytes are written\n        # self.stage_sigs[self.internal_ts_sel] = 1\n\n    def kickoff(self):\n        \"Call encoder.kickoff() for every encoder.\"\n        for attr_name in ['adc1']: #, 'adc2', 'adc3', 'adc4']:\n            status = getattr(self, attr_name).kickoff()\n        # it's fine to just return one of the status objects\n        return status\n\n    def collect(self):\n        \"Call adc.collect() for every encoder.\"\n        # Stop writing data to the file in all encoders.\n        for attr_name in ['adc1']: #, 'adc2', 'adc3', 'adc4']:\n            getattr(self, attr_name).enable_sel.set(0).wait()\n        # Now collect the data accumulated by all encoders.\n        for attr_name in ['adc1']: #, 'adc2', 'adc3', 'adc4']:\n            yield from getattr(self, attr_name).collect()"
  },
  {
    "class_name": "PizzaBoxDualAnalogFS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/10-detectors.py",
    "source": "class PizzaBoxDualAnalogFS(Device):\n    #internal_ts_sel = Cpt(EpicsSignal, 'Gen}T:Internal-Sel')\n\n    # for these, you need a master and a slave\n    # set the PV that will always trigger to master and any additional to slave\n    # first pair\n    '''\n        Some comments about defining these adc's for the pizza boxes:\n            adc_column: int\n                this is the column in the file that the data is written\n                0, being the first column with encoder data\n            adc_read_name : str\n                This is the PV string for the Epics PV we must read from \n            mode: {'master', 'slave', 'disabled'}\n                This is the mode.\n                In slave mode, the adc won't trigger the collection.\n                In disabled mode, the adc won't stage when the parent stage() method\n                    is called.\n                In master mode, the adc will trigger the collection of data.\n                If you use just one PV in a pair, make sure it is in 'master' mode.\n                If you use both PV's in a pair, make sure only one is set to \"master\"\n                Another option is we could remove this option and just have\n                each PV check if the collection has been triggered and trigger\n                otherwise.\n\n        An alternative to defining these is to create an object per pair of ADC's.\n        However, this is not backwards compatible with the way iss runs on the\n        pizza boxes. Some care must be taken to modify the plans and the GUI if\n        doing this.\n    '''\n    adc3 = Cpt(DualAdcFS, 'ADC:1',\n               adc_column=0, adc_read_name=\"XF:07BMB-CT{GP2-ADC:3\")\n    adc4 = Cpt(DualAdcFS, 'ADC:1',\n               adc_column=1, adc_read_name=\"XF:07BMB-CT{GP2-ADC:4\")\n\n    # second pair\n    # if using both, one must be master, the other slave\n    adc5 = Cpt(DualAdcFS, 'ADC:6',\n               adc_column=0, adc_read_name=\"XF:07BMB-CT{GP2-ADC:5\")\n    adc6 = Cpt(DualAdcFS, 'ADC:6',\n               adc_column=1, adc_read_name=\"XF:07BMB-CT{GP2-ADC:6\")\n\n    # third pair\n    adc7 = Cpt(DualAdcFS, 'ADC:7',\n               adc_column=0, adc_read_name=\"XF:07BMB-CT{GP2-ADC:7\")\n    adc8 = Cpt(DualAdcFS, 'ADC:7',\n               adc_column=1, adc_read_name=\"XF:07BMB-CT{GP2-ADC:8\")\n\n\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # must use internal timestamps or no bytes are written\n        # self.stage_sigs[self.internal_ts_sel] = 1\n\n    def _get_active_devices(self):\n        devices = [getattr(self, name) for name in self.component_names]\n        devices = [device for device in devices if device._mode != 'disabled']\n        return devices\n\n    def stage(self):\n        devices = self._get_active_devices()\n        for device in devices:\n            device.stage()\n\n    def unstage(self):\n        devices = self._get_active_devices()\n        for device in devices:\n            device.unstage()\n\n    def kickoff(self):\n        '''Call encoder.kickoff() for every encoder.\n\n            This is untested. Currently isstools uses the underlying adc\n                children.\n        '''\n        devices = self._get_active_devices()\n        compound_status = None\n        for device in devices:\n            new_status = device.kickoff()\n            if compound_status is None:\n                new_status = compound_status\n            else:\n                new_status = ophyd.AndStatus(compound_status, new_status)\n        return new_status\n\n    def complete(self):\n        '''Call encoder.complete() for every encoder.\n\n            This is untested. Currently isstools uses the underlying adc\n                children.\n        '''\n        devices = self._get_active_devices()\n        compound_status = None\n        for device in devices:\n            new_status = device.complete()\n            if compound_status is None:\n                new_status = compound_status\n            else:\n                new_status = ophyd.AndStatus(compound_status, new_status)\n        return new_status\n\n    def collect(self):\n        \"Call adc.collect() for every encoder.\"\n        devices = self._get_active_devices()\n        for device in devices:\n            yield from device.collect()\n\n    def collect_asset_docs(self):\n        print(f\"PizzaBox collect_asset_docs\")\n        devices = self._get_active_devices()\n        for device in devices:\n            yield from device.collect_asset_docs()"
  },
  {
    "class_name": "Xspress3FileStoreFlyable",
    "bases": [
      "Xspress3FileStore"
    ],
    "file": "profile-collections/qas-profile-collection/startup/40-xspress3.py",
    "source": "class Xspress3FileStoreFlyable(Xspress3FileStore):\n    def warmup(self):\n        \"\"\"\n        A convenience method for 'priming' the plugin.\n        The plugin has to 'see' one acquisition before it is ready to capture.\n        This sets the array size, etc.\n        NOTE : this comes from:\n            https://github.com/NSLS-II/ophyd/blob/master/ophyd/areadetector/plugins.py\n        We had to replace \"cam\" with \"settings\" here.\n        Also modified the stage sigs.\n        \"\"\"\n        print(\"warming up the hdf5 plugin...\")\n        self.enable.set(1).wait()\n        sigs = OrderedDict([(self.parent.settings.array_callbacks, 1),\n                            (self.parent.settings.trigger_mode, 'Internal'),\n                            # just in case the acquisition time is set very long...\n                            (self.parent.settings.acquire_time, 1),\n                            # (self.capture, 1),\n                            (self.parent.settings.acquire, 1)])\n\n        original_vals = {sig: sig.get() for sig in sigs}\n\n        # Remove the hdf5.capture item here to avoid an error as it should reset back to 0 itself\n        # del original_vals[self.capture]\n\n        for sig, val in sigs.items():\n            ttime.sleep(0.1)  # abundance of caution\n            sig.set(val).wait()\n\n        ttime.sleep(2)  # wait for acquisition\n\n        for sig, val in reversed(list(original_vals.items())):\n            ttime.sleep(0.1)\n            sig.set(val).wait()\n        print(\"done\")"
  },
  {
    "class_name": "QASXspress3Detector",
    "bases": [
      "XspressTrigger",
      "Xspress3Detector"
    ],
    "file": "profile-collections/qas-profile-collection/startup/40-xspress3.py",
    "source": "class QASXspress3Detector(XspressTrigger, Xspress3Detector):\n    roi_data = Cpt(PluginBase, 'ROIDATA:')\n    channel1 = Cpt(Xspress3Channel, 'C1_', channel_num=1, read_attrs=['rois'])\n    channel2 = Cpt(Xspress3Channel, 'C2_', channel_num=2, read_attrs=['rois'])\n    channel3 = Cpt(Xspress3Channel, 'C3_', channel_num=3, read_attrs=['rois'])\n    channel4 = Cpt(Xspress3Channel, 'C4_', channel_num=4, read_attrs=['rois'])\n    channel5 = Cpt(Xspress3Channel, 'C5_', channel_num=5, read_attrs=['rois'])\n    channel6 = Cpt(Xspress3Channel, 'C6_', channel_num=6, read_attrs=['rois'])\n    # create_dir = Cpt(EpicsSignal, 'HDF5:FileCreateDir')\n\n    mca1_sum = Cpt(EpicsSignal, 'ARRSUM1:ArrayData')\n    mca2_sum = Cpt(EpicsSignal, 'ARRSUM2:ArrayData')\n    mca3_sum = Cpt(EpicsSignal, 'ARRSUM3:ArrayData')\n    mca4_sum = Cpt(EpicsSignal, 'ARRSUM4:ArrayData')\n    mca5_sum = Cpt(EpicsSignal, 'ARRSUM5:ArrayData')\n    mca6_sum = Cpt(EpicsSignal, 'ARRSUM6:ArrayData')\n\n    mca1 = Cpt(EpicsSignal, 'ARR1:ArrayData')\n    mca2 = Cpt(EpicsSignal, 'ARR2:ArrayData')\n    mca3 = Cpt(EpicsSignal, 'ARR3:ArrayData')\n    mca4 = Cpt(EpicsSignal, 'ARR4:ArrayData')\n    mca5 = Cpt(EpicsSignal, 'ARR5:ArrayData')\n    mca6 = Cpt(EpicsSignal, 'ARR6:ArrayData')\n\n    cnt_time = Cpt(EpicsSignal, 'C1_SCA0:Value_RBV')\n\n    # channel6 = Cpt(Xspress3Channel, 'C6_', channel_num=6)\n\n    #TODO change folder to xspress3\n    hdf5 = Cpt(Xspress3FileStoreFlyable, 'HDF5:',\n               read_path_template='/nsls2/data/qas-new/legacy/raw/x3m/%Y/%m/%d/',\n               root='/nsls2/data/qas-new/legacy/raw/',\n               write_path_template='/nsls2/data/qas-new/legacy/raw/x3m/%Y/%m/%d/',\n               )\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n        if configuration_attrs is None:\n            configuration_attrs = ['external_trig', 'total_points',\n                                   'spectra_per_point', 'settings',\n                                   'rewindable']\n        if read_attrs is None:\n            read_attrs = ['channel1', 'channel2', 'channel3', 'channel4', 'channel5', 'channel6', 'hdf5', 'settings.acquire_time']\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n        self.set_channels_for_hdf5()\n        # self.create_dir.put(-3)\n\n        self._asset_docs_cache = deque()\n        self._datum_counter = None\n\n        self.channel1.rois.roi01.configuration_attrs.append('bin_low')\n\n    # Step-scan interface methods.\n    def stage(self):\n        if self.spectra_per_point.get() != 1:\n            raise NotImplementedError(\n                \"multi spectra per point not supported yet\")\n\n        ret = super().stage()\n        self._datum_counter = itertools.count()\n        return ret\n\n    def trigger(self):\n\n        self._status = DeviceStatus(self)\n        self.settings.erase.put(1)\n        # self.settings.erase.put(1)    # this was\n        self._acquisition_signal.put(1, wait=False)\n        trigger_time = ttime.time()\n\n        for sn in self.read_attrs:\n            if sn.startswith('channel') and '.' not in sn:\n                ch = getattr(self, sn)\n                self.generate_datum(ch.name, trigger_time)\n\n        self._abs_trigger_count += 1\n        return self._status\n\n    def unstage(self):\n        self.settings.trigger_mode.put(1)  # 'Software'\n        super().unstage()\n        self._datum_counter = None\n\n    def stop(self):\n        ret = super().stop()\n        self.hdf5.stop()\n        return ret\n\n    # Fly-able interface methods.\n    def kickoff(self):\n        # TODO: implement the kickoff method for the flying mode once the hardware is ready.\n        raise NotImplementedError()\n\n    def complete(self, *args, **kwargs):\n        for resource in self.hdf5._asset_docs_cache:\n            self._asset_docs_cache.append(('resource', resource[1]))\n\n        self._datum_ids = []\n\n        num_frames = self.hdf5.num_captured.get()\n\n        # print(f'\\n!!! num_frames: {num_frames}\\n')\n\n        for frame_num in range(num_frames):\n            if self.hdf5._resource_uid is not None:\n                datum_id = '{}/{}'.format(self.hdf5._resource_uid, next(self._datum_counter))\n                datum = {'resource': self.hdf5._resource_uid,\n                         'datum_kwargs': {'frame': frame_num},\n                         'datum_id': datum_id}\n                self._asset_docs_cache.append(('datum', datum))\n                self._datum_ids.append(datum_id)\n\n        return NullStatus()\n\n    def collect(self):\n        # TODO: try to separate it from the xspress3 class\n        collected_frames = self.settings.array_counter.get()\n\n        # This is a hack around the issue with .NORD (number of elements to #\n        # read) that does not match .NELM (number of elements to that the array\n        # will hold)\n        dpb_sec_nelm_count = int(dpb_sec_nelm.get())\n        dpb_nsec_nelm_count = int(dpb_nsec_nelm.get())\n        dpb_sec_values = np.array(dpb_sec.get(count=dpb_sec_nelm_count),\n                                  dtype='float128')[:collected_frames * 2: 2]\n        dpb_nsec_values = np.array(dpb_nsec.get(count=dpb_nsec_nelm_count),\n                                   dtype='float128')[:collected_frames * 2: 2]\n\n        di_timestamps = dpb_sec_values + dpb_nsec_values * 1e-9\n\n        len_di_timestamps = len(di_timestamps)\n        len_datum_ids = len(self._datum_ids)\n\n        if len_di_timestamps != len_datum_ids:\n            warnings.warn(f'The length of \"di_timestamps\" ({len_di_timestamps}) '\n                          f'does not match the length of \"self._datum_ids\" ({len_datum_ids})')\n\n        num_frames = min(len_di_timestamps, len_datum_ids)\n        num_frames = len_datum_ids\n        for frame_num in range(num_frames):\n            datum_id = self._datum_ids[frame_num]\n            # ts = di_timestamps[frame_num]\n            ts = di_timestamps\n\n            data = {self.name: datum_id}\n            # TODO: fix the lost precision as pymongo complained about np.float128.\n            ts = float(ts)\n\n            # print(f'data: {data}\\nlen_di_timestamps: {len_di_timestamps}\\nlen_datum_ids: {len_di_timestamps}')\n\n            yield {'data': data,\n                   'timestamps': {key: ts for key in data},\n                   'time': ts,  # TODO: use the proper timestamps from the mono start and stop times\n                   'filled': {key: False for key in data}}\n\n    # The collect_asset_docs(...) method was removed as it exists on the hdf5 component and should be used there.\n\n    def set_channels_for_hdf5(self, channels=(1, 2, 3, 4, 5, 6)):\n        \"\"\"\n        Configure which channels' data should be saved in the resulted hdf5 file.\n        Parameters\n        ----------\n        channels: tuple, optional\n            the channels to save the data for\n        \"\"\"\n        # The number of channel\n        for n in channels:\n            getattr(self, f'channel{n}').rois.read_attrs = ['roi{:02}'.format(j) for j in [1, 2, 3, 4, 5, 6]]\n        self.hdf5.num_extra_dims.put(0)\n        # self.settings.num_channels.put(len(channels))\n        self.settings.num_channels.put(6)"
  },
  {
    "class_name": "SampleStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class SampleStage(Device):\n    rotary = Cpt(EpicsMotor, '-Ax:aY}Mtr')\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    z = Cpt(EpicsMotor, '-Ax:Z}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    theta = Cpt(EpicsMotor, '-Ax:Theta}Mtr')\n    chi = Cpt(EpicsMotor, '-Ax:Chi}Mtr')"
  },
  {
    "class_name": "PilatusMotion",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class PilatusMotion(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')"
  },
  {
    "class_name": "MonoTrajDesc",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class MonoTrajDesc(Device):\n    filename = Cpt(EpicsSignal, '-Name')\n    elem = Cpt(EpicsSignal, '-Elem')\n    edge = Cpt(EpicsSignal, '-Edge')\n    e0 = Cpt(EpicsSignal, '-E0')\n    type = Cpt(EpicsSignal, '-Type')"
  },
  {
    "class_name": "Monochromator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class Monochromator(Device):\n    _default_configuration_attrs = ('bragg', 'energy', 'pico', 'diag')\n    _default_read_attrs = ('bragg', 'energy', 'pico', 'diag')\n    \"Monochromator\"\n    ip = '10.68.50.104'\n    traj_filepath = '/home/xf07bm/trajectory/'\n    bragg = Cpt(EpicsMotor, 'Mono:1-Ax:Scan}Mtr')\n    energy = Cpt(EpicsMotor, 'Mono:1-Ax:E}Mtr')\n    pico = Cpt(EpicsMotor, 'Mono:1-Ax:Pico}Mtr')\n    diag = Cpt(EpicsMotor, 'Mono:1-Ax:Diag}Mtr')\n\n    main_motor_res = Cpt(EpicsSignal, 'Mono:1-Ax:Scan}Mtr.MRES')\n\n    # The following are related to trajectory motion\n    lut_number = Cpt(EpicsSignal, 'MC:03}LUT-Set')\n    lut_number_rbv = Cpt(EpicsSignal, 'MC:03}LUT-Read')\n    lut_start_transfer = Cpt(EpicsSignal, 'MC:03}TransferLUT')\n    lut_transfering = Cpt(EpicsSignal, 'MC:03}TransferLUT-Read')\n    trajectory_loading = Cpt(EpicsSignal, 'MC:03}TrajLoading')\n    traj_mode = Cpt(EpicsSignal, 'MC:03}TrajFlag1-Set')\n    traj_mode_rbv = Cpt(EpicsSignal, 'MC:03}TrajFlag1-Read')\n    enable_ty = Cpt(EpicsSignal, 'MC:03}TrajFlag2-Set')\n    enable_ty_rbv = Cpt(EpicsSignal, 'MC:03}TrajFlag2-Read')\n    cycle_limit = Cpt(EpicsSignal, 'MC:03}TrajRows-Set')\n    cycle_limit_rbv = Cpt(EpicsSignal, 'MC:03}TrajRows-Read')\n    enable_loop = Cpt(EpicsSignal, 'MC:03}TrajLoopFlag-Set')\n    enable_loop_rbv = Cpt(EpicsSignal, 'MC:03}TrajLoopFlag')\n\n    prepare_trajectory = Cpt(EpicsSignal, 'MC:03}PrepareTraj')\n    trajectory_ready = Cpt(EpicsSignal, 'MC:03}TrajInitPlc-Read')\n    start_trajectory = Cpt(EpicsSignal, 'MC:03}StartTraj')\n    stop_trajectory = Cpt(EpicsSignal, 'MC:03}StopTraj')\n    trajectory_running = Cpt(EpicsSignal,'MC:03}TrajRunning', write_pv='MC:03}TrajRunning-Set')\n    trajectory_progress = Cpt(EpicsSignal,'MC:03}TrajProgress')\n    trajectory_name = Cpt(EpicsSignal, 'MC:03}TrajFilename')\n\n    traj1 = Cpt(MonoTrajDesc, 'MC:03}Traj:1')\n    traj2 = Cpt(MonoTrajDesc, 'MC:03}Traj:2')\n    traj3 = Cpt(MonoTrajDesc, 'MC:03}Traj:3')\n    traj4 = Cpt(MonoTrajDesc, 'MC:03}Traj:4')\n    traj5 = Cpt(MonoTrajDesc, 'MC:03}Traj:5')\n    traj6 = Cpt(MonoTrajDesc, 'MC:03}Traj:6')\n    traj7 = Cpt(MonoTrajDesc, 'MC:03}Traj:7')\n    traj8 = Cpt(MonoTrajDesc, 'MC:03}Traj:8')\n    traj9 = Cpt(MonoTrajDesc, 'MC:03}Traj:9')\n\n    # trajectory_type = None\n\n    angle_offset = Cpt(EpicsSignal, 'Mono:1-Ax:E}Offset', limits=True)\n\n    def __init__(self, *args, enc = None, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.pulses_per_deg = 1/self.main_motor_res.get()\n        self.enc = enc\n\n\n    def set(self, command):\n        if command == 'prepare':\n\n            # This function will receive Events from the IOC and check whether\n            # we are seeing the trajectory_ready go low after having been high.\n            # def callback(value, old_value, **kwargs):\n            #     if int(round(old_value)) == 1 and int(round(value)) == 0:\n            #         if self._preparing or self._preparing is None:\n            #             self._preparing = False\n            #             return True\n            #         else:\n            #             self._preparing = True\n            #     return False\n\n            # This is a simpler callback to work more reliably with collection-2020-2.0rc7-1.\n            def callback(value, old_value, **kwargs):\n                if old_value == 1 and value == 0:\n                    return True\n                return False\n\n            # Creating this status object subscribes `callback` Events from the\n            # IOC. Starting at this line, we are now listening for the IOC to\n            # tell us it is done. When it does, this status object will\n            # complete (status.done = True).\n            status = SubscriptionStatus(self.trajectory_ready, callback, run=False)\n\n            # Finally, now that we are listening to the IOC, prepare the\n            # trajectory.\n            self.prepare_trajectory.set('1')  # Yes, the IOC requires a string.\n\n            # Return the status object immediately, without waiting. The caller\n            # will be able to watch for it to become done.\n            return status\n\n        if command == 'start':\n\n            # def callback(value, old_value, **kwargs):\n            #     if int(round(old_value)) == 1 and int(round(value)) == 0:\n            #         if self._starting or self._starting is None:\n            #             self._starting = False\n            #             return True\n            #         else:\n            #             self._starting = True\n            #     return False\n\n            # This is a simpler callback to work more reliably with collection-2020-2.0rc7-1.\n            def callback(value, old_value, **kwargs):\n                if old_value == 1 and value == 0:\n                    return True\n                return False\n\n            status = SubscriptionStatus(self.trajectory_running, callback, run=False)\n            self.start_trajectory.set('1')\n\n            return status"
  },
  {
    "class_name": "Mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class Mirror(Device):\n    hor_up = Cpt(EpicsMotor, '-Ax:XU}Mtr')\n    hor_down = Cpt(EpicsMotor, '-Ax:XD}Mtr')\n    vert_up = Cpt(EpicsMotor, '-Ax:YU}Mtr')\n    vert_down_in = Cpt(EpicsMotor, '-Ax:YD1}Mtr')\n    vert_down_out = Cpt(EpicsMotor, '-Ax:YD2}Mtr')\n    bend = Cpt(EpicsMotor, '-Ax:BD}Mtr')"
  },
  {
    "class_name": "Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class Slits(Device):\n    top = Cpt(EpicsMotor, '-Ax:T}Mtr')\n    bottom = Cpt(EpicsMotor, '-Ax:B}Mtr')\n    outboard = Cpt(EpicsMotor, '-Ax:O}Mtr')\n    inboard = Cpt(EpicsMotor, '-Ax:I}Mtr')"
  },
  {
    "class_name": "SlitsVA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class SlitsVA(Device):\n    top = Cpt(EpicsMotor, '-Ax:T}Mtr')\n    bottom = Cpt(EpicsMotor, '-Ax:B}Mtr')\n    outboard = Cpt(EpicsMotor, '-Ax:O}Mtr')\n    inboard = Cpt(EpicsMotor, '-Ax:I}Mtr')\n    xctr = Cpt(EpicsMotor, '-Ax:XCtr}Mtr')\n    xgap = Cpt(EpicsMotor, '-Ax:XGap}Mtr')"
  },
  {
    "class_name": "FE_Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class FE_Slits(Device):\n    top = Cpt(EpicsMotor, '1-Ax:T}Mtr')\n    bottom = Cpt(EpicsMotor, '2-Ax:B}Mtr')\n    outboard = Cpt(EpicsMotor, '1-Ax:O}Mtr')\n    inboard = Cpt(EpicsMotor, '2-Ax:I}Mtr')"
  },
  {
    "class_name": "Table",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class Table(Device):\n    hor_up = Cpt(EpicsMotor, '-Ax:XU}Mtr')\n    hor_down = Cpt(EpicsMotor, '-Ax:XD}Mtr')\n    beam_dir = Cpt(EpicsMotor, '-Ax:Z}Mtr')\n    vert_up = Cpt(EpicsMotor, '-Ax:YDU}Mtr')\n    vert_down_in = Cpt(EpicsMotor, '-Ax:YDI}Mtr')\n    vert_down_out = Cpt(EpicsMotor, '-Ax:YDO}Mtr')"
  },
  {
    "class_name": "Table_c",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class Table_c(Device):\n    hor_up = Cpt(EpicsMotor, '-Ax:XU}Mtr')\n    hor_down = Cpt(EpicsMotor, '-Ax:XD}Mtr')\n    vert_up_in = Cpt(EpicsMotor, '-Ax:YUI}Mtr')\n    vert_up_out = Cpt(EpicsMotor, '-Ax:YUO}Mtr')\n    vert_down = Cpt(EpicsMotor, '-Ax:YD}Mtr')"
  },
  {
    "class_name": "BeamStop",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class BeamStop(Device):\n    horizontal = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    vertical   = Cpt(EpicsMotor, '-Ax:Y}Mtr')"
  },
  {
    "class_name": "PerkinElmerPositioner",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class PerkinElmerPositioner(Device):\n    vertical = Cpt(EpicsMotor, '-Ax:Y}Mtr')"
  },
  {
    "class_name": "FoilWheel1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class FoilWheel1(Device):\n    wheel1 = Cpt(EpicsMotor, '-Ax:RotUp}Mtr')\n    wheel2 = Cpt(EpicsMotor, '-Ax:RotDn}Mtr')"
  },
  {
    "class_name": "FoilWheel2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class FoilWheel2(Device):\n    wheel1 = Cpt(EpicsMotor, '-Ax:Rot}Mtr')"
  },
  {
    "class_name": "FoilWheel4",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class FoilWheel4(Device):\n    wheel4 = Cpt(EpicsMotor, '-Ax:Rot}Mtr')"
  },
  {
    "class_name": "Drifts",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class Drifts(Device):\n    drifts_z = Cpt(EpicsMotor, '-Ax:Z}Mtr')\n    drifts_x = Cpt(EpicsMotor, '-Ax:X}Mtr')"
  },
  {
    "class_name": "IonChamberY",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/20-motors.py",
    "source": "class IonChamberY(Device):\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')"
  },
  {
    "class_name": "AnalogPizzaBox",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/qas-profile-collection/startup/29-apb.py",
    "source": "class AnalogPizzaBox(Device):\n\n    polarity = 'neg'\n\n    ch1 = Cpt(EpicsSignal, 'SA:Ch1:mV-I', kind=Kind.config)\n    ch2 = Cpt(EpicsSignal, 'SA:Ch2:mV-I')\n    ch3 = Cpt(EpicsSignal, 'SA:Ch3:mV-I')\n    ch4 = Cpt(EpicsSignal, 'SA:Ch4:mV-I')\n    ch5 = Cpt(EpicsSignal, 'SA:Ch5:mV-I')\n    ch6 = Cpt(EpicsSignal, 'SA:Ch6:mV-I')\n    ch7 = Cpt(EpicsSignal, 'SA:Ch7:mV-I')\n    ch8 = Cpt(EpicsSignal, 'SA:Ch8:mV-I')\n\n    vi0 = Cpt(EpicsSignal, 'SA:Ch1:V-I')\n    vit = Cpt(EpicsSignal, 'SA:Ch2:V-I')\n    vir = Cpt(EpicsSignal, 'SA:Ch3:V-I')\n    vip = Cpt(EpicsSignal, 'SA:Ch4:V-I')\n\n    ch1.polarity = ch2.polarity = ch3.polarity = ch4.polarity = 'neg'\n\n    ch1_offset = Cpt(EpicsSignal, 'Ch1:User:Offset-SP', kind=Kind.config)\n    ch2_offset = Cpt(EpicsSignal, 'Ch2:User:Offset-SP', kind=Kind.config)\n    ch3_offset = Cpt(EpicsSignal, 'Ch3:User:Offset-SP', kind=Kind.config)\n    ch4_offset = Cpt(EpicsSignal, 'Ch4:User:Offset-SP', kind=Kind.config)\n    ch5_offset = Cpt(EpicsSignal, 'Ch5:User:Offset-SP', kind=Kind.config)\n    ch6_offset = Cpt(EpicsSignal, 'Ch6:User:Offset-SP', kind=Kind.config)\n    ch7_offset = Cpt(EpicsSignal, 'Ch7:User:Offset-SP', kind=Kind.config)\n    ch8_offset = Cpt(EpicsSignal, 'Ch8:User:Offset-SP', kind=Kind.config)\n\n    ch1_adc_gain = Cpt(EpicsSignal, 'ADC1:Gain-SP')\n    ch2_adc_gain = Cpt(EpicsSignal, 'ADC2:Gain-SP')\n    ch3_adc_gain = Cpt(EpicsSignal, 'ADC3:Gain-SP')\n    ch4_adc_gain = Cpt(EpicsSignal, 'ADC4:Gain-SP')\n    ch5_adc_gain = Cpt(EpicsSignal, 'ADC5:Gain-SP')\n    ch6_adc_gain = Cpt(EpicsSignal, 'ADC6:Gain-SP')\n    ch7_adc_gain = Cpt(EpicsSignal, 'ADC7:Gain-SP')\n    ch8_adc_gain = Cpt(EpicsSignal, 'ADC8:Gain-SP')\n\n    ch1_adc_offset = Cpt(EpicsSignal, 'ADC1:Offset-SP')\n    ch2_adc_offset = Cpt(EpicsSignal, 'ADC2:Offset-SP')\n    ch3_adc_offset = Cpt(EpicsSignal, 'ADC3:Offset-SP')\n    ch4_adc_offset = Cpt(EpicsSignal, 'ADC4:Offset-SP')\n    ch5_adc_offset = Cpt(EpicsSignal, 'ADC5:Offset-SP')\n    ch6_adc_offset = Cpt(EpicsSignal, 'ADC6:Offset-SP')\n    ch7_adc_offset = Cpt(EpicsSignal, 'ADC7:Offset-SP')\n    ch8_adc_offset = Cpt(EpicsSignal, 'ADC8:Offset-SP')\n\n    pulse1_status = Cpt(EpicsSignal, 'Pulse:1:Status-I')\n    pulse2_status = Cpt(EpicsSignal, 'Pulse:2:Status-I')\n    pulse3_status = Cpt(EpicsSignal, 'Pulse:3:Status-I')\n    pulse4_status = Cpt(EpicsSignal, 'Pulse:4:Status-I')\n\n    pulse1_stream_status = Cpt(EpicsSignal, 'Pulse:1:Stream:Status-I')\n    pulse2_stream_status = Cpt(EpicsSignal, 'Pulse:2:Stream:Status-I')\n    pulse3_stream_status = Cpt(EpicsSignal, 'Pulse:3:Stream:Status-I')\n    pulse4_stream_status = Cpt(EpicsSignal, 'Pulse:4:Stream:Status-I')\n\n    pulse1_file_status = Cpt(EpicsSignal, 'Pulse:1:File:Status-I')\n    pulse2_file_status = Cpt(EpicsSignal, 'Pulse:2:File:Status-I')\n    pulse3_file_status = Cpt(EpicsSignal, 'Pulse:3:File:Status-I')\n    pulse4_file_status = Cpt(EpicsSignal, 'Pulse:4:File:Status-I')\n\n    pulse1_stream_count = Cpt(EpicsSignal, 'Pulse:1:Stream:Count-I')\n    pulse2_stream_count = Cpt(EpicsSignal, 'Pulse:2:Stream:Count-I')\n    pulse3_stream_count = Cpt(EpicsSignal, 'Pulse:3:Stream:Count-I')\n    pulse4_stream_count = Cpt(EpicsSignal, 'Pulse:4:Stream:Count-I')\n\n    pulse1_max_count = Cpt(EpicsSignal, 'Pulse:1:MaxCount-SP')\n    pulse2_max_count = Cpt(EpicsSignal, 'Pulse:2:MaxCount-SP')\n    pulse3_max_count = Cpt(EpicsSignal, 'Pulse:3:MaxCount-SP')\n    pulse4_max_count = Cpt(EpicsSignal, 'Pulse:4:MaxCount-SP')\n\n    pulse1_op_mode_sp = Cpt(EpicsSignal, 'Pulse:1:Mode-SP')\n    pulse2_op_mode_sp = Cpt(EpicsSignal, 'Pulse:2:Mode-SP')\n    pulse3_op_mode_sp = Cpt(EpicsSignal, 'Pulse:3:Mode-SP')\n    pulse4_op_mode_sp = Cpt(EpicsSignal, 'Pulse:4:Mode-SP')\n\n    pulse1_stream_mode_sp = Cpt(EpicsSignal, 'Pulse:1:Stream:Mode-SP')\n    pulse2_stream_mode_sp = Cpt(EpicsSignal, 'Pulse:2:Stream:Mode-SP')\n    pulse3_stream_mode_sp = Cpt(EpicsSignal, 'Pulse:3:Stream:Mode-SP')\n    pulse4_stream_mode_sp = Cpt(EpicsSignal, 'Pulse:4:Stream:Mode-SP')\n\n    pulse1_frequency_sp = Cpt(EpicsSignal, 'Pulse:1:Frequency-SP')\n    pulse2_frequency_sp = Cpt(EpicsSignal, 'Pulse:2:Frequency-SP')\n    pulse3_frequency_sp = Cpt(EpicsSignal, 'Pulse:3:Frequency-SP')\n    pulse4_frequency_sp = Cpt(EpicsSignal, 'Pulse:4:Frequency-SP')\n\n    pulse1_dutycycle_sp = Cpt(EpicsSignal, 'Pulse:1:DutyCycle-SP')\n    pulse2_dutycycle_sp = Cpt(EpicsSignal, 'Pulse:2:DutyCycle-SP')\n    pulse3_dutycycle_sp = Cpt(EpicsSignal, 'Pulse:3:DutyCycle-SP')\n    pulse4_dutycycle_sp = Cpt(EpicsSignal, 'Pulse:4:DutyCycle-SP')\n\n    pulse1_delay_sp = Cpt(EpicsSignal, 'Pulse:1:Delay-SP')\n    pulse2_delay_sp = Cpt(EpicsSignal, 'Pulse:2:Delay-SP')\n    pulse3_delay_sp = Cpt(EpicsSignal, 'Pulse:3:Delay-SP')\n    pulse4_delay_sp = Cpt(EpicsSignal, 'Pulse:4:Delay-SP')\n\n    acquire = Cpt(EpicsSignal, 'FA:SoftTrig-SP', kind=Kind.omitted)\n    acquiring = Cpt(EpicsSignal, 'FA:Busy-I', kind=Kind.omitted)\n\n    data_rate = Cpt(EpicsSignal, 'FA:Rate-I')\n    divide = Cpt(EpicsSignal, 'FA:Divide-SP')\n    sample_len = Cpt(EpicsSignal, 'FA:Samples-SP')\n    wf_len = Cpt(EpicsSignal, 'FA:Wfm:Length-SP')\n\n    stream = Cpt(EpicsSignal,'FA:Stream-SP', kind=Kind.omitted)\n    streaming = Cpt(EpicsSignal,'FA:Streaming-I', kind=Kind.omitted)\n    acq_rate= Cpt(EpicsSignal,'FA:Rate-I', kind=Kind.omitted)\n    stream_samples = Cpt(EpicsSignal, 'FA:Stream:Samples-SP')\n\n    trig_source = Cpt(EpicsSignal, 'Machine:Clk-SP')\n\n    filename_bin = Cpt(EpicsSignal, 'FA:Stream:Bin:File-SP')\n    filebin_status = Cpt(EpicsSignal, 'FA:Stream:Bin:File:Status-I')\n    filename_txt = Cpt(EpicsSignal, 'FA:Stream:Txt:File-SP')\n    filetxt_status = Cpt(EpicsSignal, 'FA:Stream:Txt:File:Status-I')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._IP = '10.66.59.42'"
  },
  {
    "class_name": "Stage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfm-profile-collection/startup/10-stages.py",
    "source": "class Stage(Device):\n    x    = Cpt(EpicsMotor, '{UTS:1-Ax:X}Mtr')\n    y    = Cpt(EpicsMotor, '{UTS:1-Ax:Y}Mtr')\n    z    = Cpt(EpicsMotor, '{UTS:1-Ax:Z}Mtr')"
  },
  {
    "class_name": "ScalerMCA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfm-profile-collection/startup/20-scaler.py",
    "source": "class ScalerMCA(Device):\n    _default_read_attrs = ('channels', 'current_channel')\n    _default_configuration_attrs = ('nuse', 'prescale')\n\n    channels = DDC({f'mca{k:02d}': (EpicsSignal, f\"mca{k}\", {}) for k in range(1, 33)})\n    startall = C(EpicsSignal, 'StartAll', string=True)\n    stopall = C(EpicsSignal, 'StopAll', string=True)\n    eraseall = C(EpicsSignal, 'EraseAll', string=True)\n    erasestart = C(EpicsSignal, 'EraseStart', string=True)\n\n    current_channel = C(EpicsSignal, 'CurrentChannel')\n    nuse = C(EpicsSignal, 'NuseAll')\n    prescale = C(EpicsSignal, 'Prescale')\n\n    # high is acquiring\n    status = C(EpicsSignal, 'Acquiring', string=True)\n\n    def stage(self):\n        super().stage()\n        self.eraseall.put('Erase')\n\n    def stop(self):\n        self.stopall.put('Stop')\n\n    def trigger(self):\n        self.erasestart.put('Erase')\n\n        return StatusBase()"
  },
  {
    "class_name": "Scaler",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfm-profile-collection/startup/20-scaler.py",
    "source": "class Scaler(Device):\n    # MCAs\n    mcas = C(ScalerMCA, '')\n    # TODO maybe an issue with the timing around the triggering?\n    cnts = C(ScalerCH, 'scaler1')\n\n    def __init__(self, *args, mode='counting', **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_mode(mode)\n\n\n    def match_names(self, N=20):\n        self.cnts.match_names()\n        for j in range(1, N+1):\n            mca_ch = getattr(self.mcas.channels, f\"mca{j:02d}\")\n            ct_ch = getattr(self.cnts.channels, f\"chan{j:02d}\")\n            mca_ch.name = ct_ch.chname.get()\n\n    # TODO put a soft signal around this so we can stage it\n    def set_mode(self, mode):\n        if mode == 'counting':\n            self.read_attrs = ['cnts']\n            self.configuration_attrs = ['cnts']\n        elif mode == 'flying':\n            self.read_attrs = ['mcas']\n            self.configuration_attrs = ['mcas']\n        else:\n            raise ValueError\n\n        self._mode = mode\n\n    def trigger(self):\n        if self._mode == 'counting':\n            return self.cnts.trigger()\n        elif mode == 'flying':\n            return self.mcas.trigger()\n        else:\n            raise ValueError\n\n    def stage(self):\n        self.match_names()\n        if self._mode == 'counting':\n            return self.cnts.stage()\n        elif mode == 'flying':\n            return self.mcas.stage()\n        else:\n            raise ValueError\n\n    def unstage(self):\n        if self._mode == 'counting':\n            return self.cnts.unstage()\n        elif mode == 'flying':\n            return self.mcas.unstage()\n        else:\n            raise ValueError"
  },
  {
    "class_name": "SrxXspress3Detector",
    "bases": [
      "XspressTrigger",
      "Xspress3Detector"
    ],
    "file": "profile-collections/xfm-profile-collection/startup/30-xspress3.py",
    "source": "class SrxXspress3Detector(XspressTrigger, Xspress3Detector):\n    roi_data = Cpt(PluginBase, 'ROIDATA:')\n    channel1 = C(Xspress3Channel, 'C1_', channel_num=1, read_attrs=['rois'])\n    channel2 = C(Xspress3Channel, 'C2_', channel_num=2, read_attrs=['rois'])\n    channel3 = C(Xspress3Channel, 'C3_', channel_num=3, read_attrs=['rois'])\n    channel4 = C(Xspress3Channel, 'C4_', channel_num=4, read_attrs=['rois'])\n    # create_dir = Cpt(EpicsSignal, 'HDF5:FileCreateDir')\n\n    hdf5 = Cpt(Xspress3FileStore, 'HDF5:',\n               read_path_template='/nsls2/data/xfm/legacy/raw/x3m/%Y/%m/%d/',\n               root='/nsls2/data/xfm/legacy/raw/',\n               write_path_template='/nsls2/data/xfm/legacy/raw/x3m/%Y/%m/%d/',\n               )\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n        if configuration_attrs is None:\n            configuration_attrs = ['external_trig', 'total_points',\n                                   'spectra_per_point', 'settings',\n                                   'rewindable']\n        if read_attrs is None:\n            read_attrs = ['channel1', 'channel2', 'channel3', 'channel4', 'hdf5']\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n        # self.create_dir.put(-3)\n\n    def stop(self):\n        ret = super().stop()\n        self.hdf5.stop()\n        return ret\n\n    def stage(self):\n        ret = super().stage()\n        # self._resource_uid = self._resource\n        return ret"
  },
  {
    "class_name": "TopAlignerBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/96-top_alignment.py",
    "source": "class TopAlignerBase(Device):\n\n    topcam = Cpt(TopAlignCam, \"XF:17IDB-ES:AMX{Cam:9}\")\n    gonio_o = Cpt(EpicsMotor, \"XF:17IDB-ES:AMX{Gon:1-Ax:O}Mtr\", timeout=6)\n    gonio_py = Cpt(\n        EpicsMotorSPMG, \"XF:17IDB-ES:AMX{Gon:1-Ax:PY}Mtr\", timeout=6\n    )\n    gonio_pz = Cpt(\n        EpicsMotorSPMG, \"XF:17IDB-ES:AMX{Gon:1-Ax:PZ}Mtr\", timeout=6\n    )\n    kill_py = Cpt(EpicsSignal, \"XF:17IDB-ES:AMX{Gon:1-Ax:PY}Cmd:Kill-Cmd\")\n    kill_pz = Cpt(EpicsSignal, \"XF:17IDB-ES:AMX{Gon:1-Ax:PY}Cmd:Kill-Cmd\")\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.read_attrs = []\n        self._configure_device()\n\n    def _configure_device(self, *args, **kwargs):\n        raise NotImplementedError(\n            \"Subclasses must implement custom device configuration\"\n        )\n\n    def stage(self, *args, **kwargs):\n        if type(self) == TopAlignerBase:\n            raise NotImplementedError(\"TopAlignerBase has no stage method\")\n        return super().stage(*args, **kwargs)\n\n    def trigger(self):\n        raise NotImplementedError(\"Subclasses must implement custom trigger\")\n\n    def unstage(self, *args, **kwargs):\n        if type(self) == TopAlignerBase:\n            raise NotImplementedError(\"TopAlignerBase has no unstage method\")\n        super().unstage(*args, **kwargs)"
  },
  {
    "class_name": "ZebraSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraSignalWithRBV(EpicsSignal):\n    # An EPICS signal that uses the Zebra convention of 'pvname' being the\n    # setpoint and 'pvname:RBV' being the read-back\n\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix + ':RBV', write_pv=prefix, **kwargs)"
  },
  {
    "class_name": "ZebraPulse",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraPulse(Device):\n    width = Cpt(ZebraSignalWithRBV, 'WID')\n    input_addr = Cpt(ZebraSignalWithRBV, 'INP')\n    input_str = Cpt(EpicsSignalRO, 'INP:STR', string=True)\n    input_status = Cpt(EpicsSignalRO, 'INP:STA')\n    delay = Cpt(ZebraSignalWithRBV, 'DLY')\n    delay_sync = Cpt(EpicsSignal, 'DLY:SYNC')\n    time_units = Cpt(ZebraSignalWithRBV, 'PRE', string=True)\n    output = Cpt(EpicsSignal, 'OUT')\n\n    input_edge = FC(EpicsSignal,\n                    '{self._zebra_prefix}POLARITY:{self._edge_addr}')\n\n    _edge_addrs = {1: 'BC',\n                   2: 'BD',\n                   3: 'BE',\n                   4: 'BF',\n                   }\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['input_status', 'output']\n        if configuration_attrs is None:\n            configuration_attrs = _get_configuration_attrs(self.__class__, signal_class=ZebraSignalWithRBV) + ['input_edge']\n\n        zebra = parent\n        self.index = index\n        self._zebra_prefix = zebra.prefix\n        self._edge_addr = self._edge_addrs[index]\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, parent=parent, **kwargs)"
  },
  {
    "class_name": "ZebraOutputBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraOutputBase(Device):\n    '''The base of all zebra outputs (1~8)\n\n        Front outputs\n        # TTL  LVDS  NIM  PECL  OC  ENC\n        1  o    o     o\n        2  o    o     o\n        3  o    o               o\n        4  o          o    o\n\n        Rear outputs\n        # TTL  LVDS  NIM  PECL  OC  ENC\n        5                            o\n        6                            o\n        7                            o\n        8                            o\n\n    '''\n    def __init__(self, prefix, *, index=None, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        self.index = index\n\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = _get_configuration_attrs(self.__class__)\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraOutputType",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraOutputType(Device):\n    '''Shared by all output types (ttl, lvds, nim, pecl, out)'''\n    addr = Cpt(ZebraSignalWithRBV, '')\n    status = Cpt(EpicsSignalRO, ':STA')\n    string = Cpt(EpicsSignalRO, ':STR', string=True)\n    sync = Cpt(EpicsSignal, ':SYNC')\n    write_output = Cpt(EpicsSignal, ':SET')\n\n    def __init__(self, prefix, *, read_attrs=None, configuration_attrs=None,\n                 **kwargs):\n        if read_attrs is None:\n            read_attrs = ['status']\n        if configuration_attrs is None:\n            configuration_attrs = ['addr']\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraEncoder",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraEncoder(Device):\n    motor_pos = FC(EpicsSignalRO, '{self._zebra_prefix}M{self.index}:RBV')\n    zebra_pos = FC(EpicsSignal, '{self._zebra_prefix}POS{self.index}_SET')\n    encoder_res = FC(EpicsSignal, '{self._zebra_prefix}M{self.index}:MRES')\n    encoder_off = FC(EpicsSignal, '{self._zebra_prefix}M{self.index}:OFF')\n    _copy_pos_signal = FC(EpicsSignal, '{self._zebra_prefix}M{self.index}:SETPOS.PROC')\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = ['encoder_res', 'encoder_off']\n\n        self.index = index\n        self._zebra_prefix = parent.prefix\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         parent=parent, **kwargs)\n\n    def copy_position(self):\n        self._copy_pos_signal.put(1, wait=True)"
  },
  {
    "class_name": "ZebraGateInput",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraGateInput(Device):\n    addr = Cpt(ZebraSignalWithRBV, '')\n    string = Cpt(EpicsSignalRO, ':STR', string=True)\n    status = Cpt(EpicsSignalRO, ':STA')\n    sync = Cpt(EpicsSignal, ':SYNC')\n    write_input = Cpt(EpicsSignal, ':SET')\n\n    # Input edge index depends on the gate number (these are set in __init__)\n    edge = FC(EpicsSignal,\n              '{self._zebra_prefix}POLARITY:B{self._input_edge_idx}')\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['status']\n        if configuration_attrs is None:\n            configuration_attrs = ['addr', 'edge']\n\n        gate = parent\n        zebra = gate.parent\n\n        self.index = index\n        self._zebra_prefix = zebra.prefix\n        self._input_edge_idx = gate._input_edge_idx[self.index]\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         parent=parent, **kwargs)"
  },
  {
    "class_name": "ZebraGate",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraGate(Device):\n    input1 = Cpt(ZebraGateInput, 'INP1', index=1)\n    input2 = Cpt(ZebraGateInput, 'INP2', index=2)\n    output = Cpt(EpicsSignal, 'OUT')\n\n    def __init__(self, prefix, *, index=None, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        self.index = index\n        self._input_edge_idx = {1: index - 1,\n                                2: 4 + index - 1\n                                }\n\n        if read_attrs is None:\n            read_attrs = ['output']\n        if configuration_attrs is None:\n            configuration_attrs = ['input1', 'input2']\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n\n    def set_input_edges(self, edge1, edge2):\n        set_and_wait(self.input1.edge, int(edge1))\n        set_and_wait(self.input2.edge, int(edge2))"
  },
  {
    "class_name": "ZebraPositionCaptureDeviceBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraPositionCaptureDeviceBase(Device):\n    source = Cpt(ZebraSignalWithRBV, 'SEL', put_complete=True)\n    input_addr = Cpt(ZebraSignalWithRBV, 'INP')\n    input_str = Cpt(EpicsSignalRO, 'INP:STR', string=True)\n    input_status = Cpt(EpicsSignalRO, 'INP:STA', auto_monitor=True)\n    output = Cpt(EpicsSignalRO, 'OUT', auto_monitor=True)\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n\n        if read_attrs is None:\n            read_attrs = []\n        read_attrs += ['input_status', 'output']\n\n        if configuration_attrs is None:\n            configuration_attrs = []\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraPositionCaptureData",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraPositionCaptureData(Device):\n    num_captured = Cpt(EpicsSignalRO, 'NUM_CAP')\n    num_downloaded = Cpt(EpicsSignalRO, 'NUM_DOWN')\n\n    time = Cpt(EpicsSignalRO, 'TIME')\n\n    enc1 = Cpt(EpicsSignalRO, 'ENC1')\n    enc2 = Cpt(EpicsSignalRO, 'ENC2')\n    enc3 = Cpt(EpicsSignalRO, 'ENC3')\n    enc4 = Cpt(EpicsSignalRO, 'ENC4')\n\n    sys1 = Cpt(EpicsSignalRO, 'SYS1')\n    sys2 = Cpt(EpicsSignalRO, 'SYS2')\n\n    div1 = Cpt(EpicsSignalRO, 'DIV1')\n    div2 = Cpt(EpicsSignalRO, 'DIV2')\n    div3 = Cpt(EpicsSignalRO, 'DIV3')\n    div4 = Cpt(EpicsSignalRO, 'DIV4')\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n\n        if read_attrs is None:\n            read_attrs = _get_configuration_attrs(self.__class__, signal_class=EpicsSignalRO)\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraPositionCapture",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraPositionCapture(Device):\n    source = Cpt(ZebraSignalWithRBV, 'ENC')\n    direction = Cpt(ZebraSignalWithRBV, 'DIR')\n    time_units = Cpt(ZebraSignalWithRBV, 'TSPRE')\n\n    arm = Cpt(ZebraPositionCaptureArm, 'ARM_')\n    gate = Cpt(ZebraPositionCaptureGate, 'GATE_')\n    pulse = Cpt(ZebraPositionCapturePulse, 'PULSE_')\n\n    capture_enc1 = Cpt(EpicsSignal, 'BIT_CAP:B0')\n    capture_enc2 = Cpt(EpicsSignal, 'BIT_CAP:B1')\n    capture_enc3 = Cpt(EpicsSignal, 'BIT_CAP:B2')\n    capture_enc4 = Cpt(EpicsSignal, 'BIT_CAP:B3')\n\n    capture_sys1 = Cpt(EpicsSignal, 'BIT_CAP:B4')\n    capture_sys2 = Cpt(EpicsSignal, 'BIT_CAP:B5')\n\n    capture_div1 = Cpt(EpicsSignal, 'BIT_CAP:B6')\n    capture_div2 = Cpt(EpicsSignal, 'BIT_CAP:B7')\n    capture_div3 = Cpt(EpicsSignal, 'BIT_CAP:B8')\n    capture_div4 = Cpt(EpicsSignal, 'BIT_CAP:B9')\n\n    data = Cpt(ZebraPositionCaptureData, '')\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n\n        if read_attrs is None:\n            read_attrs = ['data']\n        if configuration_attrs is None:\n            configuration_attrs = (\n                ['source', 'direction', 'time_units',\n                 'arm', 'gate', 'pulse'] +\n                [f'capture_enc{i}' for i in range(1,5)] +\n                [f'capture_sys{i}' for i in range(1,3)] +\n                [f'capture_div{i}' for i in range(1,5)]\n            )\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraBase(Device):\n    soft_input1 = Cpt(EpicsSignal, 'SOFT_IN:B0')\n    soft_input2 = Cpt(EpicsSignal, 'SOFT_IN:B1')\n    soft_input3 = Cpt(EpicsSignal, 'SOFT_IN:B2')\n    soft_input4 = Cpt(EpicsSignal, 'SOFT_IN:B3')\n\n    pulse1 = Cpt(ZebraPulse, 'PULSE1_', index=1)\n    pulse2 = Cpt(ZebraPulse, 'PULSE2_', index=2)\n    pulse3 = Cpt(ZebraPulse, 'PULSE3_', index=3)\n    pulse4 = Cpt(ZebraPulse, 'PULSE4_', index=4)\n\n    output1 = Cpt(ZebraFrontOutput12, 'OUT1_', index=1)\n    output2 = Cpt(ZebraFrontOutput12, 'OUT2_', index=2)\n    output3 = Cpt(ZebraFrontOutput3, 'OUT3_', index=3)\n    output4 = Cpt(ZebraFrontOutput4, 'OUT4_', index=4)\n\n    output5 = Cpt(ZebraRearOutput, 'OUT5_', index=5)\n    output6 = Cpt(ZebraRearOutput, 'OUT6_', index=6)\n    output7 = Cpt(ZebraRearOutput, 'OUT7_', index=7)\n    output8 = Cpt(ZebraRearOutput, 'OUT8_', index=8)\n\n    gate1 = Cpt(ZebraGate, 'GATE1_', index=1)\n    gate2 = Cpt(ZebraGate, 'GATE2_', index=2)\n    gate3 = Cpt(ZebraGate, 'GATE3_', index=3)\n    gate4 = Cpt(ZebraGate, 'GATE4_', index=4)\n\n    encoder1 = Cpt(ZebraEncoder, '', index=1)\n    encoder2 = Cpt(ZebraEncoder, '', index=2)\n    encoder3 = Cpt(ZebraEncoder, '', index=3)\n    encoder4 = Cpt(ZebraEncoder, '', index=4)\n\n    pos_capt = Cpt(ZebraPositionCapture, 'PC_')\n    download_status = Cpt(EpicsSignalRO, 'ARRAY_ACQ')\n    reset = Cpt(EpicsSignal, 'SYS_RESET.PROC')\n\n    addresses = ZebraAddresses\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = (\n                [f'soft_input{i}' for i in range(1,5)] +\n                [f'pulse{i}' for i in range(1,5)] +\n                [f'output{i}' for i in range(1,9)] +\n                [f'gate{i}' for i in range(1,5)] +\n                [f'encoder{i}' for i in range(1,5)] +\n                ['pos_capt']\n            )\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n\n        self.pulse = dict(self._get_indexed_devices(ZebraPulse))\n        self.output = dict(self._get_indexed_devices(ZebraOutputBase))\n        self.gate = dict(self._get_indexed_devices(ZebraGate))\n        self.encoder = dict(self._get_indexed_devices(ZebraEncoder))\n\n    def _get_indexed_devices(self, cls):\n        for attr in self._sub_devices:\n            dev = getattr(self, attr)\n            if isinstance(dev, cls):\n                yield dev.index, dev\n\n    def trigger(self):\n        # Re-implement this to trigger as desired in bluesky\n        status = DeviceStatus(self)\n        status._finished()\n        return status"
  },
  {
    "class_name": "ZebraArmSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraArmSignalWithRBV(EpicsSignal):\n        def __init__(self, prefix, **kwargs):\n            super().__init__(prefix + 'ARM_OUT', write_pv=prefix+'ARM', **kwargs)"
  },
  {
    "class_name": "ZebraDisarmSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/amx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraDisarmSignalWithRBV(EpicsSignal):\n        def __init__(self, prefix, **kwargs):\n            super().__init__(prefix + 'ARM_OUT', write_pv=prefix+'DISARM', **kwargs)"
  },
  {
    "class_name": "PBSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/amx-profile-collection/startup/24-powerbrick.py",
    "source": "class PBSignalWithRBV(EpicsSignal):\n    # An EPICS signal that uses the NSLS-II convention of 'pvname-SP' being the\n    # setpoint and 'pvname-I' being the read-back\n\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix + '-I', write_pv=prefix + '-SP', **kwargs)"
  },
  {
    "class_name": "PowerBrickVectorMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/24-powerbrick.py",
    "source": "class PowerBrickVectorMotor(Device):\n    start = Cpt(PBSignalWithRBV, 'Start')\n    end = Cpt(PBSignalWithRBV, 'End')\n\n    def __init__(self, prefix, *, parent=None, **kwargs):\n        cfg_attrs = ['start', 'end']\n        super().__init__(prefix, configuration_attrs=cfg_attrs,\n                         parent=parent, **kwargs)"
  },
  {
    "class_name": "PowerBrickVectorBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/24-powerbrick.py",
    "source": "class PowerBrickVectorBase(Device):\n    x = Cpt(PowerBrickVectorMotor, 'Pos:X')\n    y = Cpt(PowerBrickVectorMotor, 'Pos:Y')\n    z = Cpt(PowerBrickVectorMotor, 'Pos:Z',)\n    o = Cpt(PowerBrickVectorMotor, 'Pos:O')\n\n    exposure = Cpt(PBSignalWithRBV, 'Val:Exposure')\n    num_samples = Cpt(PBSignalWithRBV, 'Val:NumSamples')\n\n    expose = Cpt(EpicsSignal, 'Expose-Sel')\n    hold = Cpt(EpicsSignal, 'Hold-Sel')\n\n    state = Cpt(EpicsSignalRO, 'Sts:State-Sts', auto_monitor=True)\n    running = Cpt(EpicsSignalRO, 'Sts:Running-Sts', auto_monitor=True)\n\n    go = Cpt(EpicsSignal, 'Cmd:Go-Cmd')\n    proceed = Cpt(EpicsSignal, 'Cmd:Proceed-Cmd')\n    abort = Cpt(EpicsSignal, 'Cmd:Abort-Cmd')\n    sync = Cpt(EpicsSignal, 'Cmd:Sync-Cmd')\n\n    def __init__(self, prefix, configuration_attrs=None, *args, **kwargs):\n        cfg_attrs = ['x', 'y', 'z', 'o', 'exposure', 'num_samples', 'expose', 'hold']\n        if configuration_attrs is not None:\n            cfg_attrs = configuration_attrs + cfg_attrs\n        super().__init__(prefix, configuration_attrs=cfg_attrs, *args, **kwargs)\n\n        self.motors = [self.x, self.y, self.z, self.o]"
  },
  {
    "class_name": "KBTweaker",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/96-beam_alignment.py",
    "source": "class KBTweaker(Device):\n    hor = Cpt(KBTweakerAxis, \"-Motor-X}Mtr\")\n    ver = Cpt(KBTweakerAxis, \"-Motor-Y}Mtr\")"
  },
  {
    "class_name": "SmartMagnet",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/96-beam_alignment.py",
    "source": "class SmartMagnet(Device):\n    sample_detect = Cpt(\n        EpicsSignalRO,\n        \"SampleDetected1-Sts\",\n        doc=\"1 is NO sample, 0 is YES sample\",\n    )"
  },
  {
    "class_name": "PYZHomer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/29-sentinel.py",
    "source": "class PYZHomer(Device):\n\n    status = Cpt(EpicsSignalRO, \"XF:17IDB-ES:AMX{Sentinel}Homing_Sts\")\n    home_actuate = Cpt(EpicsSignal, \"XF:17ID:AMX{Sentinel}pin_home\")\n\n    kill_home = Cpt(EpicsSignal, \"XF:17IDB-ES:AMX{Sentinel}Homing_Kill\")\n    kill_py = Cpt(EpicsSignal, \"XF:17IDB-ES:AMX{Gon:1-Ax:PY}Cmd:Kill-Cmd\")\n    kill_pz = Cpt(EpicsSignal, \"XF:17IDB-ES:AMX{Gon:1-Ax:PY}Cmd:Kill-Cmd\")\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def trigger(self):\n\n        def callback_homed(value, old_value, **kwargs):\n            if old_value == 1 and value == 0:\n                return True\n            else:\n                return False\n\n        self.home_actuate.put(1)\n\n        homing_status = SubscriptionStatus(\n            self.status,\n            callback_homed,\n            run=False,\n            timeout=180,\n        )\n\n        return homing_status"
  },
  {
    "class_name": "Bpm",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/21-bpm.py",
    "source": "class Bpm(Device):\n    x = Cpt(EpicsSignalRO, 'PosX:MeanValue_RBV')\n    y = Cpt(EpicsSignalRO, 'PosY:MeanValue_RBV')\n    a = Cpt(EpicsSignalRO, 'Current1:MeanValue_RBV')\n    b = Cpt(EpicsSignalRO, 'Current2:MeanValue_RBV')\n    c = Cpt(EpicsSignalRO, 'Current3:MeanValue_RBV')\n    d = Cpt(EpicsSignalRO, 'Current4:MeanValue_RBV')\n    sum_x = Cpt(EpicsSignalRO, 'SumX:MeanValue_RBV')\n    sum_y = Cpt(EpicsSignalRO, 'SumY:MeanValue_RBV')\n    sum_all = Cpt(EpicsSignalRO, 'SumAll:MeanValue_RBV')"
  },
  {
    "class_name": "Best",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/21-bpm.py",
    "source": "class Best(Device):\n    x_mean  = Cpt(EpicsSignal, 'PosX_Mean')\n    x_std = Cpt(EpicsSignal, 'PosX_Std')\n    y_mean  = Cpt(EpicsSignal, 'PosY_Mean')\n    y_std = Cpt(EpicsSignal, 'PosY_Std')\n    int_mean  = Cpt(EpicsSignal, 'Int_Mean')\n    int_std = Cpt(EpicsSignal, 'Int_Std')"
  },
  {
    "class_name": "RobotTaskSignal",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/amx-profile-collection/startup/26-robot.py",
    "source": "class RobotTaskSignal(EpicsSignal):\n    def _set_and_wait(self, value, timeout=100, **kwargs):\n        start_value = int(self.get()[0])\n        expiration_time = ttime.time() + timeout if timeout is not None else None\n        self.put(value, timeout=timeout)\n        while True:\n            current_value = int(self.get()[0])\n            if current_value == start_value + 1:\n                break\n            if current_value != start_value:\n                raise RuntimeError(\n                    f\"SW:startRobotTask indexed by {current_value - start_value} on task {value} (should be 1).\")\n            if expiration_time is not None and ttime.time() > expiration_time:\n                raise TimeoutError(\n                    \"Attempted to set %r to value %r and timed \"\n                    \"out after %r seconds.\"\n                    % (self, value, timeout, current_value)\n                )\n            ttime.sleep(0.05)"
  },
  {
    "class_name": "RobotVariableSignal",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/amx-profile-collection/startup/26-robot.py",
    "source": "class RobotVariableSignal(EpicsSignal):\n    def set(self, value, timeout=100, **kwargs):\n        self.put(value, timeout=timeout)"
  },
  {
    "class_name": "Robot",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/26-robot.py",
    "source": "class Robot(Device):\n    task = Cpt(RobotTaskSignal, \"startRobotTask\")\n    abort = Cpt(EpicsSignal, \"abort\")\n    restart = Cpt(EpicsSignal, \"restart\")\n    robot_pause = Cpt(EpicsSignal, \"pauseRobot\")\n    robot_resume = Cpt(EpicsSignal, \"resumeRobot\")\n    start_test = Cpt(EpicsSignal, \"startTestTask\")\n\n    set_variable = Cpt(RobotVariableSignal, \"setRobotVariable\")\n    get_variable = Cpt(RobotVariableSignal, \"getRobotVariable\")\n    speed = Cpt(EpicsSignal, \"RobotSpeed\")\n    gui_lockout = Cpt(EpicsSignal, \"LocalGuiLockOut\")\n\n    status = Cpt(EpicsSignalRO, \"Status\")\n    robot_state = Cpt(EpicsSignalRO, \"RobotState\")\n    state = Cpt(EpicsSignalRO, \"State\")\n    info = Cpt(EpicsSignalRO, \"getTaskInfo\")\n    running = Cpt(EpicsSignalRO, \"isTaskRunning\")\n    distance = Cpt(EpicsSignalRO, \"getDistance\")\n    mounted = Cpt(EpicsSignalRO, \"isSampleMounted\")\n    check_result = Cpt(EpicsSignalRO, \"checkTaskResult\")\n    task_exception = Cpt(EpicsSignalRO, \"LastTaskException\")\n    task_output = Cpt(EpicsSignalRO, \"LastTaskOutput\")\n    task_info = Cpt(EpicsSignalRO, \"LastTaskInfo\")\n    cartesian_positions = Cpt(EpicsSignalRO, \"CartesianPositions\")\n    joint_positions = Cpt(EpicsSignalRO, \"JointPositions\")\n    version = Cpt(EpicsSignalRO, \"Version\")\n    uptime = Cpt(EpicsSignalRO, \"Uptime\")\n    alarm_list = Cpt(EpicsSignalRO, \"AlarmList\")\n\n    def set_nsample(self, value, value_max=48):\n        if value < 1 or value > value_max:\n            raise ValueError(\n                f\"Sample number {value} is out of range (1-{value_max}).\")\n        self.set_variable.set(['nSample', value, 100000])\n        self.get_variable.set('nDummy')\n        # sleep(0.1)\n        self.get_variable.set('nSample')\n        # sleep(0.1)\n        # print(self.get_variable.get())\n        if int(float(self.get_variable.get())) != value:\n            raise RobotError(f\"Failed to set robot variable nSample\")\n\n    def run_command(self, command, timeout=-1):\n\n        def check_done(*, old_value, value, **kwargs):\n            not_done = [\"Running\", \"Moving\", \"Busy\", \"Initialize\"]\n            return(old_value in not_done and value not in not_done)\n        status = SubscriptionStatus(self.state, check_done)\n        self.task.set([command, timeout])\n        self.running.get()\n        logger.info(f\"Running Task {command.upper()}.\")\n        return status\n\n    def get_return(self):\n        smpStat = []\n        # print(self.task_info.get())\n        stat, exception = self.task_info.get()[4:6]\n        if stat.startswith(\"ABORT\"):\n            stat, exception = stat.split(\": \")\n        if stat.startswith(\"Done\") and stat.find(\"/\") >= 0:\n            stat, tmp = stat.split(\" \")\n            smpStat = [s == \"True\" for s in tmp.split(\"/\")]\n        if stat not in (\"Done\", \"ABORT\") and exception not in (\"\", \"null\"):\n            stat = \"ABORT\"\n        return stat, smpStat, exception\n\n    def run_and_wait(self, command, timeout=-1):\n        old_info = self.task_info.get()[3]\n        status = self.run_command(command, timeout=timeout)\n        current_time = ttime.time()\n        while True:\n            current_info = self.task_info.get()[3]\n            if current_info == old_info:\n                ttime.sleep(0.1)\n            elif current_info == 'null':\n                ttime.sleep(0.1)\n            else:\n                break\n            if (ttime.time() - current_time) > timeout/1000:\n                raise TimeoutError(\n                    f\"Task {command} failed to execute within {timeout/1000} seconds.\")\n        status.wait(timeout/1000)  # timeout in seconds, ms above\n        logger.info(\n            f\"Task {command.upper()} is running = {self.running.get()}\")\n        return self.get_return()\n\n    def run_task(self, task, timeout=-1):\n        if task not in robot_tasks:\n            raise KeyError(f\"Task {task} is not a recognized task.\")\n        for cmd in robot_tasks[task]:\n            tskStat, sampleStat, exception = self.run_and_wait(\n                cmd, timeout=timeout)\n            if (tskStat.lower() != \"done\"):\n                raise RobotError(cmd+\" \"+tskStat+\" with exception \"+exception)\n\n    def reset_heartbeat(self):\n        self.set_variable.set([\"nDummy\", 882])\n\n    def reboot_EMBL(self):\n        self.abort.set(\"__EMPTY__\")\n        time.sleep(2)\n        self.restart.set(\"__EMPTY__\")\n\n    def recover(self, timeout=-1):\n        cmdList = ['Recover', 'TraceSample']\n        for cmd in cmdList:\n            tskStat, sampleStat, exception = self.run_and_wait(\n                cmd, timeout=timeout)\n            if (tskStat.lower() != \"done\"):\n                raise RobotError(cmd+\" \"+tskStat+\" with exception \"+exception)\n        return sampleStat\n\n    def initialize(self, timeout=-1):\n        self.run_task(\"initialize\", timeout=timeout)\n\n    def open_gripper(self, timeout=-1):\n        self.run_task(\"openGripper\", timeout=timeout)\n\n    def close_gripper(self, timeout=-1):\n        self.run_task(\"closeGripper\", timeout=timeout)\n\n    def test_robot(self, timeout=-1):\n        self.run_task(\"testRobot\", timeout=timeout)\n\n    def openPort(self, nPort=1, timeout=-1):\n        if nPort == 1:\n            self.run_task(\"openPortLid\", timeout=timeout)\n        elif nPort == 2:\n            self.run_task(\"openLoadLid\", timeout=timeout)\n        else:\n            self.run_task(\"openParkLid\", timeout=timeout)\n\n    def pre_mount(self, nSample, timeout=-1):\n        cmdList = ['Initialize', 'LatchRobGov', 'TraceSample', 'CoolDown']\n\n        for cmd in cmdList:\n            tskStat, sampleStat, exception = self.run_and_wait(\n                cmd, timeout=timeout)\n            if (tskStat.lower() != \"done\"):\n                raise RobotError(cmd+\" \"+tskStat+\" with exception \"+exception)\n\n            if len(sampleStat) == 3:\n                [bMounted, bLoaded, bTilted] = sampleStat\n\n            if cmd == \"TraceSample\":\n                if bMounted or bLoaded:\n                    raise RobotError(\n                        \"Aborting mount: Found pin on gonio or in gripper\")\n\n    def mount(self, nSample=0, warmup=False, timeout=-1):\n        cmdList = ['Load',\n                   'Mount',\n                   'WarmUp',\n                   'Park',\n                   'UnlatchRobGov']\n\n        self.set_nsample(nSample)\n\n        for cmd in cmdList:\n            if cmd == 'WarmUp' and warmup == False:\n                continue\n            tskStat, sampleStat, exception = self.run_and_wait(\n                cmd, timeout=timeout)\n\n            if (tskStat.lower() != \"done\"):\n                # solution for SE timeout during Mount scenario\n                if cmd == \"Mount\" and exception.find(\"SE\") >= 0:\n                    self.run_and_wait(\"Home\", timeout=timeout)\n                    tskStat2, sampleStat, exception2 = self.run_and_wait(\n                        \"Unload\", timeout=timeout)\n                    if (tskStat2.lower() == \"done\"):\n                        [bMounted, bLoaded, bTilted] = sampleStat\n                        if bLoaded:\n                            self.run_and_wait(\"TraceSample\", timeout=timeout)\n                            self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                            self.run_and_wait(\"UnlatchRobGov\", timeout=timeout)\n                            exception2 = \"Failed to save the sample\"\n                        else:\n                            self.run_and_wait(\"Home\", timeout=timeout)\n                            self.run_and_wait(\"Park\", timeout=timeout)\n                            self.run_and_wait(\"UnlatchRobGov\", timeout=timeout)\n                            exception2 = \"Sample is saved back to the dewar\"\n                    exception = exception + \"/\" + exception2\n                raise RobotError(\n                    cmd+\" \"+tskStat+\" with exception \"+exception+\";\")\n\n            if len(sampleStat) == 3:\n                [bMounted, bLoaded, bTilted] = sampleStat\n\n            if cmd == \"Load\":\n                if not bLoaded:\n                    logger.error(\"Failed to load sample, parking robot.\")\n                    self.run_and_wait(\"Home\", timeout=timeout)\n                    self.run_and_wait(\"Park\", timeout=timeout)\n                    raise RobotError(\"Failed to load sample, aborting.\")\n                elif bLoaded and bTilted:\n                    logger.error(\n                        \"Pin is tilted after loading. Attempting to unload the pin.\")\n                    self.run_and_wait(\"Home\", timeout=timeout)\n                    tskStat, sampleStat, exception = self.run_and_wait(\n                        \"Unload\", timeout=timeout)\n                    if (tskStat.lower() != \"done\"):\n                        raise RobotError(\"Failed to unload the pin.\")\n                    [bMounted, bLoaded, bTilted] = sampleStat\n\n                    if bLoaded:\n                        self.run_and_wait(\"TraceSample\", timeout=timeout)\n                        self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                    else:\n                        self.run_and_wait(\"Home\", timeout=timeout)\n                        self.run_and_wait(\"Park\", timeout=timeout)\n                    raise RobotError(\n                        \"Mount aborted due to tilted sample during load.\")\n\n            if cmd == \"Mount\":\n                if not bMounted and bLoaded:\n                    logger.error(\"Mount failed. Returning puck to the dewar.\")\n                    tskStat, sampleStat, exception = self.run_and_wait(\n                        \"Unload\", timeout=timeout)\n                    if tskStat.lower() != \"done\":\n                        raise RobotError(\"Failed to unload sample.\")\n                    [bMounted, bLoaded, bTilted] = sampleStat\n\n                    if bLoaded:\n                        self.run_and_wait(\"TraceSample\", timeout=timeout)\n                        self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                        raise RobotError(\n                            \"Mount Failed: Failed to unload back to dewar @\"+exception)\n                    else:\n                        self.run_task(\"finish\", timeout=timeout)\n                        raise RobotError(\n                            \"Mount failed. Sample returned to dewar.\")\n\n                elif not bMounted and not bLoaded:\n                    self.run_and_wait(\"TraceSample\", timeout=timeout)\n                    self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                    raise RobotError(\n                        \"Fatal: Pin lost during mount transaction.\")\n                elif bMounted and bLoaded:\n                    self.run_and_wait(\"TraceSample\", timeout=timeout)\n                    self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                    raise RobotError(\n                        \"Fatal: Found pin on both Gonio and gripper\")\n\n    def pre_unmount(self, init=True, cooldown=True, timeout=-1):\n        cmdList = ['Initialize', 'CoolDown']\n\n        for cmd in cmdList:\n            if cmd == \"Initialize\" and init == False:\n                continue\n            if cmd == \"CoolDown\" and cooldown == False:\n                continue\n            tskStat, sampleStat, exception = self.run_and_wait(\n                cmd, timeout=timeout)\n\n            if (tskStat.lower() != \"done\"):\n                raise RobotError(cmd+\" \"+tskStat+\" with exception \"+exception)\n\n    def unmount(self, nSample=0, timeout=-1):\n        cmdList = ['Unmount', 'Unload']\n        self.set_nsample(nSample)\n\n        for cmd in cmdList:\n            tskStat, sampleStat, exception = self.run_and_wait(\n                cmd, timeout=timeout)\n\n            if (tskStat.lower() != \"done\"):\n                raise RobotError(cmd+\" \"+tskStat+\" with exception \"+exception)\n\n            if len(sampleStat) == 3:\n                [bMounted, bLoaded, bTilted] = sampleStat\n\n            if cmd == \"Unmount\":\n                if bMounted and not bLoaded:\n                    logger.warn(\n                        \"Unmount failed. Attempting warmup and unmount again.\")\n                    unmountCmd = ['Home', 'WarmUp', 'CoolDown', 'Unmount']\n                    for subCmd in unmountCmd:\n                        tskStat, sampleStat, exception = self.run_and_wait(\n                            subCmd, timeout=timeout)\n                        if tskStat.lower() != \"done\":\n                            raise RobotError(\n                                \"Failed to unmount again @\"+exception)\n\n                    [bMounted, bLoaded, bTilted] = sampleStat\n\n                if bMounted and bLoaded:\n                    # For current solution, just ignore the smart Magnet\n                    logger.warn(\n                        \"Found pin on Gonio and gripper. Attempting unload.\")\n                elif not bMounted and not bLoaded:\n                    self.run_and_wait(\"TraceSample\", timeout=timeout)\n                    self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                    raise RobotError(\n                        \"Fatal: Pin lost during unmount transaction\")\n                elif bMounted and not bLoaded:\n                    self.run_and_wait(\"TraceSample\", timeout=timeout)\n                    self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                    raise RobotError(\n                        \"Fatal: Failed to unmount second time. Sticky pin on Gonio\")\n                else:\n                    if bTilted:\n                        logger.warn(\n                            \"Pin is tilted after unmounting. Attempting unload anyway\")\n\n            if cmd == \"Unload\":\n                if bLoaded and not bTilted:\n                    logger.warn(\"Unload failed. Attempting unload again.\")\n                    tskStat, sampleStat, exception = self.run_and_wait(\n                        \"Unload\", timeout=timeout)\n                    if tskStat.lower() != \"done\":\n                        raise RobotError(\"Unload failure\")\n\n                    [bMounted, bLoaded, bTilted] = sampleStat\n\n                if bLoaded:\n                    self.run_and_wait(\"TraceSample\", timeout=timeout)\n                    self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                    raise RobotError(\n                        \"Fatal: Failed unloading. Sticky or tilted pin.\")\n\n    def mount_special(self, nSample=0, timeout=-1):\n        cmdList = ['Initialize', 'TraceSample',\n                   'LoadSpecial', 'MountSpecial', 'UnlatchRobGov']\n        self.set_nsample(nSample, value_max=16)\n\n        for cmd in cmdList:\n            tskStat, sampleStat, exception = self.run_and_wait(\n                cmd, timeout=timeout)\n            if (tskStat.lower() != \"done\"):\n                raise RobotError(cmd+\" \"+tskStat+\" with exception \"+exception)\n\n            if len(sampleStat) == 3:\n                [bMounted, bLoaded, bTilted] = sampleStat\n\n            if cmd == \"TraceSample\":\n                if bMounted or bLoaded:\n                    raise RobotError(\n                        \"Mount abort. Found pin on gonio or in gripper\")\n\n            if cmd == \"LoadSpecial\":\n                if not bLoaded:\n                    logger.error(\"Load Alignment Pin failed.\")\n                    raise RobotError(\"Load Alignment Pin Failed. Abort!\")\n                elif bLoaded and bTilted:\n                    logger.warn(\n                        \"Alignment Pin is tilted. Attempting to unload the pin\")\n                    tskStat, sampleStat, exception = self.run_and_wait(\n                        \"UnloadSpecial\", timeout=timeout)\n                    raise RobotError(\n                        \"Alignment Pin tilted after loading. Unloadin the pin.\")\n\n            if cmd == \"MountSpecial\":\n                if not bMounted and bLoaded:\n                    logger.warn(\n                        \"Mount failed. Unloading Alignment Pin back to the Puck\")\n                    tskStat, sampleStat, exception = self.run_and_wait(\n                        \"UnloadSpecial\", timeout=timeout)\n                    raise RobotError(\n                        \"Fatal: Mount Alignment Pin Failed. Attempting to unload it.\")\n                elif not bMounted and not bLoaded:\n                    raise RobotError(\n                        \"Fatal: Alignment Pin lost during mount transaction\")\n                elif bMounted and bLoaded:\n                    raise RobotError(\"Fatal: Found A pin on Gonio and gripper\")\n\n    def unmount_special(self, nSample=0, timeout=-1):\n        cmdList = ['Initialize', 'UnmountSpecial',\n                   'UnloadSpecial', 'UnlatchRobgov', 'Home']\n        self.set_nsample(nSample, value_max=16)\n\n        for cmd in cmdList:\n            tskStat, sampleStat, exception = self.run_and_wait(\n                cmd, timeout=timeout)\n\n            if (tskStat.lower() != \"done\"):\n                raise RobotError(cmd+\" \"+tskStat+\" with exception \"+exception)\n\n            if len(sampleStat) == 3:\n                [bMounted, bLoaded, bTilted] = sampleStat\n\n            if cmd == \"UnmountSpecial\":\n                if bMounted and bLoaded:\n                    # For current solution, just ignore the smart Magnet\n                    logger.warn(\n                        \"Found pin on Gonio and gripper. Ignore smartMagnet Signal\")\n                elif not bMounted and not bLoaded:\n                    self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                    raise RobotError(\n                        \"Fatal: Alignment Pin lost during unmount transaction\")\n                elif bMounted and not bLoaded:\n                    self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                    raise RobotError(\n                        \"Fatal: Failed to unmount. Sticky pin on Gonio\")\n                else:\n                    logger.info(\"Normal unmount procedure\")\n\n            if cmd == \"UnloadSpecial\":\n                if bLoaded:\n                    self.run_and_wait(\"ClosePorts\", timeout=timeout)\n                    raise RobotError(\n                        \"Fatal: Failed to unload Alignment Pin. Pin stuck in Gripper\")"
  },
  {
    "class_name": "Keithley",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/20-detectors.py",
    "source": "class Keithley(Device):\n    current = Cpt(EpicsSignalRO, \"XF:17IDB-BI:AMX{Keith:1}readFloat\")\n    flux = Cpt(EpicsSignalRO, \"XF:17IDA-OP:AMX{Mono:DCM-dflux}\")"
  },
  {
    "class_name": "LoopDetector",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/96-two_click_center.py",
    "source": "class LoopDetector(Device):\n    url = Cpt(\n        Signal, value='http://mars8.nsls2.bnl.gov:8000/predict', kind='config'\n    )\n    filename = Cpt(Signal, value=None)\n    box = Cpt(Signal, value=[])\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.read_attrs = ['box']\n\n    def trigger(self):\n\n        filename_dict = {\"file\": Path(self.filename.get()).open('rb')}\n        response = requests.post(self.url.get(), files=filename_dict)\n        response.raise_for_status()\n        json_response = response.json()\n        if json_response['pred_boxes']:\n            self.box.put(response.json()['pred_boxes'][0]['box'])\n        else:\n            self.box.put([])\n        response_status = DeviceStatus(self.box, timeout=10)\n        response_status.set_finished()\n\n        return response_status"
  },
  {
    "class_name": "WorkPositions",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/96-two_click_center.py",
    "source": "class WorkPositions(Device):\n    gx = Cpt(EpicsSignal, '{Gov:Robot-Dev:gx}Pos:Work-Pos')\n    py = Cpt(EpicsSignal, '{Gov:Robot-Dev:gpy}Pos:Work-Pos')\n    pz = Cpt(EpicsSignal, '{Gov:Robot-Dev:gpz}Pos:Work-Pos')\n    o = Cpt(EpicsSignal, '{Gov:Robot-Dev:go}Pos:Work-Pos')"
  },
  {
    "class_name": "MountPositions",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/96-two_click_center.py",
    "source": "class MountPositions(Device):\n    gx = Cpt(EpicsSignal, '{Gov:Robot-Dev:gx}Pos:Mount-Pos')\n    py = Cpt(EpicsSignal, '{Gov:Robot-Dev:gpy}Pos:Mount-Pos')\n    pz = Cpt(EpicsSignal, '{Gov:Robot-Dev:gpz}Pos:Mount-Pos')\n    o = Cpt(EpicsSignal, '{Gov:Robot-Dev:go}Pos:Mount-Pos')"
  },
  {
    "class_name": "InsertionDevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/09-machine.py",
    "source": "class InsertionDevice(Device):\n    gap = Cpt(EpicsMotor, '-Ax:Gap}-Mtr',\n              name='')\n    brake = Cpt(EpicsSignal, '}BrakesDisengaged-Sts',\n                write_pv='}BrakesDisengaged-SP',\n                kind='omitted', add_prefix=('read_pv', 'write_pv', 'suffix'))\n\n    def set(self, *args, **kwargs):\n        set_and_wait(self.brake, 1)\n        return self.gap.set(*args, **kwargs)\n\n    def stop(self, *, success=False):\n        return self.gap.stop(success=success)"
  },
  {
    "class_name": "XYMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class XYMotor(Device):\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    y = Cpt(EpicsMotor, \"-Ax:Y}Mtr\")"
  },
  {
    "class_name": "Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class Slits(Device):\n    b = Cpt(EpicsMotor, \"-Ax:B}Mtr\")\n    i = Cpt(EpicsMotor, \"-Ax:I}Mtr\")\n    o = Cpt(EpicsMotor, \"-Ax:O}Mtr\")\n    t = Cpt(EpicsMotor, \"-Ax:T}Mtr\")\n    x_ctr = Cpt(EpicsMotor, \"-Ax:XCtr}Mtr\")\n    x_gap = Cpt(EpicsMotor, \"-Ax:XGap}Mtr\")\n    y_ctr = Cpt(EpicsMotor, \"-Ax:YCtr}Mtr\")\n    y_gap = Cpt(EpicsMotor, \"-Ax:YGap}Mtr\")"
  },
  {
    "class_name": "FESlits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class FESlits(Device):\n    i = Cpt(EpicsMotor, \"{Slt:2-Ax:I}Mtr\")\n    t = Cpt(EpicsMotor, \"{Slt:2-Ax:T}Mtr\")\n    o = Cpt(EpicsMotor, \"{Slt:1-Ax:O}Mtr\")\n    b = Cpt(EpicsMotor, \"{Slt:1-Ax:B}Mtr\")\n    x_ctr = Cpt(FESlitsCenter, \"{Slt:12-Ax:X}\")\n    x_gap = Cpt(FESlitsGap, \"{Slt:12-Ax:X}\")\n    y_ctr = Cpt(FESlitsCenter, \"{Slt:12-Ax:Y}\")\n    y_gap = Cpt(FESlitsGap, \"{Slt:12-Ax:Y}\")"
  },
  {
    "class_name": "VerticalDCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class VerticalDCM(Device):\n    b = Cpt(EpicsMotor, \"-Ax:B}Mtr\")\n    g = Cpt(EpicsMotor, \"-Ax:G}Mtr\")\n    p = Cpt(EpicsMotorSPMG, \"-Ax:P}Mtr\")\n    r = Cpt(EpicsMotor, \"-Ax:R}Mtr\")\n    e = Cpt(EpicsMotor, \"-Ax:E}Mtr\")\n    w = Cpt(EpicsMotor, \"-Ax:W}Mtr\")"
  },
  {
    "class_name": "TandemMirrors",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class TandemMirrors(Device):\n    pd = Cpt(EpicsMotor, \"-Ax:PD}Mtr\")\n    pu = Cpt(EpicsMotor, \"-Ax:PU}Mtr\")\n    rd = Cpt(EpicsMotor, \"-Ax:RD}Mtr\")\n    xd = Cpt(EpicsMotor, \"-Ax:XD}Mtr\")\n    xu = Cpt(EpicsMotor, \"-Ax:XU}Mtr\")\n    yd = Cpt(EpicsMotor, \"-Ax:YD}Mtr\")\n    yu = Cpt(EpicsMotor, \"-Ax:YU}Mtr\")"
  },
  {
    "class_name": "KBMirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class KBMirror(Device):\n    hp = Cpt(EpicsMotor, \":KBH-Ax:P}Mtr\")\n    hr = Cpt(EpicsMotor, \":KBH-Ax:R}Mtr\")\n    hx = Cpt(EpicsMotor, \":KBH-Ax:X}Mtr\")\n    hy = Cpt(EpicsMotor, \":KBH-Ax:Y}Mtr\")\n    vp = Cpt(EpicsMotor, \":KBV-Ax:P}Mtr\")\n    vx = Cpt(EpicsMotor, \":KBV-Ax:X}Mtr\")\n    vy = Cpt(EpicsMotor, \":KBV-Ax:Y}Mtr\")"
  },
  {
    "class_name": "GoniometerStack",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class GoniometerStack(Device):\n    gx = Cpt(EpicsMotor, \"-Ax:GX}Mtr\")\n    gy = Cpt(EpicsMotor, \"-Ax:GY}Mtr\")\n    gz = Cpt(EpicsMotor, \"-Ax:GZ}Mtr\")\n    o = Cpt(EpicsMotor, \"-Ax:O}Mtr\")\n    py = Cpt(EpicsMotor, \"-Ax:PY}Mtr\")\n    pz = Cpt(EpicsMotor, \"-Ax:PZ}Mtr\")"
  },
  {
    "class_name": "ShutterTranslation",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class ShutterTranslation(Device):\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    r = Cpt(EpicsMotor, \"-Ax:R}Mtr\")"
  },
  {
    "class_name": "BeamStop",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class BeamStop(Device):\n    fx = Cpt(EpicsMotor, \"-Ax:FX}Mtr\")\n    fy = Cpt(EpicsMotor, \"-Ax:FY}Mtr\")"
  },
  {
    "class_name": "Attenuator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class Attenuator(Device):\n    a1 = Cpt(EpicsMotor, \"-Ax:1}Mtr\")\n    a2 = Cpt(EpicsMotor, \"-Ax:2}Mtr\")\n    a3 = Cpt(EpicsMotor, \"-Ax:3}Mtr\")\n    a4 = Cpt(EpicsMotor, \"-Ax:4}Mtr\")"
  },
  {
    "class_name": "Collimator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/10-motors.py",
    "source": "class Collimator(Device):\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    xy = Cpt(EpicsMotor, \"-Ax:XY}Mtr\")\n    z = Cpt(EpicsMotor, \"-Ax:Z}Mtr\")"
  },
  {
    "class_name": "RotationAxisAligner",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/96-rot_axis_alignment.py",
    "source": "class RotationAxisAligner(Device):\n    cam_hi = Cpt(RotAlignHighMag, \"{Cam:7}\")\n    cam_lo = Cpt(RotAlignLowMag, \"{Cam:6}\")\n    gc_positioner = Cpt(GonioCameraPositioner, \"{Gon:1\")\n    current_rot_axis = Cpt(\n        Signal,\n        value=None,\n        doc=\"current rotation axis in hi mag pixels based on high mag ROI\",\n    )\n    proposed_rot_axis = Cpt(\n        Signal, value=None, doc=\"proposed rot axis in pixels\"\n    )\n    acceptance_criterium = Cpt(\n        Signal,\n        value=25,\n        doc=\"difference in pixels we will accept\",\n        kind=\"config\",\n    )\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.current_rot_axis.put(self.cam_hi.roi1.min_xyz.min_y.get() + 256)\n        self.proposed_rot_axis.subscribe(\n            self._update_rot_axis, event_type=\"value\", run=False\n        )\n\n    def _update_rois(self, delta_pix, **kwargs):\n        self.cam_hi.roi1.min_xyz.min_y.put(self.current_rot_axis.get() - 256)\n        # TODO feature registration (pin tip) with low mag\n\n    def _update_rot_axis(self, *args, **kwargs):\n        delta_pix = round(\n            self.current_rot_axis.get() - self.proposed_rot_axis.get()\n        )\n        if abs(delta_pix) < self.acceptance_criterium.get():\n            self.current_rot_axis.put(self.proposed_rot_axis.get())\n            self._update_rois(delta_pix)"
  },
  {
    "class_name": "CustomFlyer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/amx-profile-collection/startup/95-custom_plans.py",
    "source": "class CustomFlyer(Device):\n        def __init__(self, *args, **kwargs):\n            self._last_point = 0\n            self._collection_ts = None\n\n            self._ts = zebra.pos_capt.data.time\n            self._centroid_x = stats.ts_centroid.x\n            self._centroid_y = stats.ts_centroid.y\n            self._enc = getattr(zebra.pos_capt.data, f'enc{encoder_idx+1}')\n\n            self._data_sources = (\n                self._centroid_x, self._centroid_y, self._enc)\n\n            super().__init__(*args, **kwargs)\n\n        def kickoff(self):\n            self._collection_ts = time.time()\n            return zebra.kickoff()\n\n        def complete(self):\n            return zebra.complete()\n\n        def collect(self):\n            data = {\n                sig: sig.get(use_monitor=False) for sig in self._data_sources\n            }\n\n            timestamps = self._ts.get(use_monitor=False) + self._collection_ts\n\n            min_len = min([len(d) for d in data.values()])\n            cur_time = time.time()\n\n            for i in range(self._last_point, min_len):\n                yield {\n                    'data': {sig.name: data[sig][i] for sig in data},\n                    'timestamps': {sig.name: timestamps[i] for sig in data},\n                    'time': cur_time\n                }\n\n            self._last_point = min_len\n\n        def describe_collect(self):\n            return {\n                'primary': {\n                    sig.name: {\n                        'source': 'PV:' + sig.pvname,\n                        'shape': [],\n                        'dtype': 'number'\n                    } for sig in self._data_sources\n                }\n            }"
  },
  {
    "class_name": "KillSwitch",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/killswitch.py",
    "source": "class KillSwitch(Device):\n    '''A simple interface to the DIODE kill switches for the Phytron\n    amplifiers on the FMBO Delta Tau motor controllers.\n\n    In BMM's DIODE box, these are implemented on channels 0 to 4 of\n    slot 4.\n\n    attributes\n    ----------\n    dcm \n       kill switch for MC02, monochromator\n    slits2\n       kill switch for MC03, DM2 slits\n    m2\n       kill switch for MC04, focusing mirror\n    m3\n       kill switch for MC05, harmonic rejection mirror\n    dm3\n       kill switch for MC06, hutch slits and diagnostics\n\n    methods\n    -------\n    kill(mc)\n       disable Phytron\n    enable(mc)\n       activate Phytron\n    cycle(mc)\n       disable, wait 5 seconds, reactivate, then re-enable all motors\n\n    Specify the motor controller as a string, i.e. 'dcm', 'slits2',\n    'm2', 'm3', 'dm3'\n\n    Here's a common problem which is resolved using a kill switch.\n\n      BMM E.111 [36] \u25b6 RE(mvr(m2.pitch, 0.05))\n      INFO:BMM_logger:    Moving m2_pitch to 2.550\n\n      Moving m2_pitch to 2.550\n      ERROR:ophyd.objects:Motion failed: m2_yu is in an alarm state status=AlarmStatus.STATE severity=AlarmSeverity.MAJOR\n      ERROR:ophyd.objects:Motion failed: m2_yu is in an alarm state status=AlarmStatus.STATE severity=AlarmSeverity.MAJOR\n      ERROR:ophyd.objects:Motion failed: m2_ydi is in an alarm state status=AlarmStatus.STATE severity=AlarmSeverity.MAJOR\n      ERROR:ophyd.objects:Motion failed: m2_ydi is in an alarm state status=AlarmStatus.STATE severity=AlarmSeverity.MAJOR\n      Out[36]: ()\n\n    This is telling you that the amplifiers for two of the M2 jacks\n    went into an alarm state. In the vast majority of cases, this\n    simply requires killing and reactivating those amplifiers.\n\n    The solution to this one is:\n\n      BMM E.111 [1] \u25b6 ks.cycle('m2')\n      Cycling amplifiers on m2 motor controller\n      killing amplifiers\n      reactivating amplifiers\n      enabling motors\n\n    '''\n    dcm    = Cpt(EpicsSignal, 'OutPt00:Data-Sel')\n    slits2 = Cpt(EpicsSignal, 'OutPt01:Data-Sel')\n    m2     = Cpt(EpicsSignal, 'OutPt02:Data-Sel')\n    m3     = Cpt(EpicsSignal, 'OutPt03:Data-Sel')\n    dm3    = Cpt(EpicsSignal, 'OutPt04:Data-Sel')\n\n    def check(self, mc):\n        '''Verify the string identifying the motor controller.\n\n        Identify the motor controller by these strings:\n           'dcm', 'slits2', 'm2', 'm3', 'dm3'\n        '''\n        if mc is None:\n            error_msg(\"Specify a device: ks.kill(device), device is dcm/slits2/m2/m3/dm3\")\n            return False\n        if mc.lower() not in ('dcm', 'slits2', 'm2', 'm3', 'dm3'):\n            error_msg(\"Specify a device: ks.kill(device), device is dcm/slits2/m2/m3/dm3\")\n            return False\n        return True\n        \n\n    def kill(self, mc=None):\n        '''Kill the amplifiers on a motor controller.\n\n        Identify the motor controller by these strings:\n           'dcm', 'slits2', 'm2', 'm3', 'dm3'\n        '''\n        if self.check(mc) is False:\n            return\n        switch = getattr(self, mc)\n        switch.put(1)\n\n    def enable(self, mc=None):\n        '''Reactivate the amplifiers on a motor controller.\n\n        Identify the motor controller by these strings:\n           'dcm', 'slits2', 'm2', 'm3', 'dm3'\n        '''\n        if self.check(mc) is False:\n            return\n        switch = getattr(self, mc)\n        switch.put(0)\n\n    def allon(self):\n        for mc in ('dcm', 'slits2', 'm2', 'm3', 'dm3'):\n            self.enable(mc)\n        \n    def alloff(self):\n        for mc in ('dcm', 'slits2', 'm2', 'm3', 'dm3'):\n            self.kill(mc)\n\n    def checkall(self):\n        ok = True\n        for mc in ('dcm', 'slits2', 'm2', 'm3', 'dm3'):\n            switch = getattr(self, mc)\n            if switch.get() == 1:\n                disconnected_msg(f'{mc} controller is disabled')\n                ok = False\n        return(ok)\n\n    def cycle(self, mc=None):\n        '''Cycle power to the amplifiers on a motor controller, then reenable\n        the motors on that controller.\n\n        Identify the motor controller by these strings:\n           'dcm', 'slits2', 'm2', 'm3', 'dm3'\n\n        '''\n        if self.check(mc) is False:\n            return\n        bold_msg(f'Cycling amplifiers on {mc} motor controller')\n        whisper('killing amplifiers')\n        self.kill(mc)\n        countdown(5)\n        whisper('reactivating amplifiers')\n        self.enable(mc)\n        whisper('enabling motors')\n        if mc == 'm2':\n            m2.ena()\n        elif mc == 'm3':\n            m3.ena()\n        elif mc == 'slits2':\n            slits2.enable()\n        elif mc == 'dm3':\n            slits3.enable()\n            for axis in (dm3_bct, dm3_bpm, dm3_foils, dm3_fs):\n                try:\n                    axis.enable()\n                    time.sleep(0.5)\n                    axis.kill()\n                except:\n                    pass\n        elif mc == dcm:\n            dcm.ena()\n            time.sleep(0.5)\n            dcm.kill()"
  },
  {
    "class_name": "BMMSnapshot",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/camera_device.py",
    "source": "class BMMSnapshot(Device):\n    image = Component(ExternalFileReference, value=\"\", kind=\"normal\", shape=(1080, 1920, 3))\n    \n    def __init__(self, *args, root, which, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._root = root\n        self._acquiring_lock = threading.Lock()\n        self._counter = None  # set to an itertools.count object when staged\n        self._asset_docs_cache = []\n        self._annotation_string = ''\n        self.device = None      # needed for the fswebcam interface\n        self.x = 640\n        self.y = 480\n        self.brightness = 30\n        if which.lower() =='xrd':\n            self._SPEC = \"BMM_XRD_WEBCAM\"\n            self._url = 'http://xf06bm-cam5/axis-cgi/jpg/image.cgi'\n        elif which.lower() == 'xas':\n            self._SPEC = \"BMM_XAS_WEBCAM\"\n            self._url = 'http://xf06bm-cam6/axis-cgi/jpg/image.cgi'\n        elif 'usb' in which.lower():\n            self._SPEC = \"BMM_USBCAM\"\n            self._url = None\n        else:\n            self._SPEC = \"BMM_ANALOG_CAMERA\"\n            self._url = None\n\n    def current_folder(self):\n        #folder = os.path.join(BMMuser.folder, 'raw', datetime.datetime.now().strftime(\"%Y/%m/%d/%H\"))\n        folder = os.path.join(BMMuser.workspace, 'snapshots')\n        if not os.path.isdir(folder):\n            os.makedirs(folder)\n        #folder = f\"/nsls2/data3/bmm/proposals/{md['cycle']}/{md['data_session']}/assets/{self.name}/{datetime.datetime.now().strftime('%Y/%m/%d')}\"\n        return folder\n            \n    def stage(self):\n        #self._rel_path_template = f\"path/to/files/{uuid.uuid4()}_%d.ext\"\n        self._rel_path_template = f\"{uuid.uuid4()}_%d.jpg\"\n        self._root = self.current_folder()\n        resource, self._datum_factory = resource_factory(\n            self._SPEC, self._root, self._rel_path_template, {}, \"posix\")\n        self._asset_docs_cache.append(('resource', resource))\n        self._counter = itertools.count()\n        # Set the filepath\n        return super().stage()\n\n    def collect_asset_docs(self):\n        yield from self._asset_docs_cache\n        self._asset_docs_cache.clear()\n\n    def unstage(self):\n        self._counter = None\n        self._asset_docs_cache.clear()\n        return super().unstage()\n\n    def _capture(self, status, i):\n        \"This runs on a background thread.\"\n        try:\n            if not self._acquiring_lock.acquire(timeout=0):\n                raise RuntimeError(\"Cannot trigger, currently trigggering!\")\n            filename = os.path.join(self._root, self._rel_path_template % i)\n            # Kick off requests, or subprocess, or whatever with the result\n            # that a file is saved at `filename`.\n\n            if self._SPEC == \"BMM_XAS_WEBCAM\" or self._SPEC == \"BMM_XRD_WEBCAM\":\n                CAM_PROXIES = {\"http\": None, \"https\": None,}\n                r=requests.get(self._url, proxies=CAM_PROXIES)\n                im = Image.open(BytesIO(r.content))\n                im.save(filename, 'JPEG')\n                #print(f'w: {im.width}    h: {im.height}')\n                self.image.shape = (im.height, im.width, 3)\n\n                annotation = 'NIST BMM (NSLS-II 06BM)      ' + self._annotation_string + '      ' + now()\n                annotate_image(filename, annotation)\n            elif self._SPEC == \"BMM_USBCAM\":\n                if self.name == 'usbcam-1':\n                    u=user_ns['usb1'].image.array_data.get().reshape((1080,1920,3))\n                else: \n                    u=user_ns['usb2'].image.array_data.get().reshape((600,800,3))\n                im = Image.fromarray(u)\n                im.save(filename, 'JPEG')\n                self.image.shape = (im.height, im.width, 3)\n                annotation = 'NIST BMM (NSLS-II 06BM)      ' + self._annotation_string + '      ' + now()\n                annotate_image(filename, annotation)\n            else:\n                analog_camera(device=self.device, x=self.x, y=self.y, brightness=self.brightness,\n                              filename=filename, sample=self._annotation_string, folder=self._root, quiet=True)\n                self.image.shape = (self.y, self.x, 3)\n            self._annotation_string = ''\n\n            datum = self._datum_factory({\"index\": i})\n            self._asset_docs_cache.append(('datum', datum))\n            self.image.set(datum[\"datum_id\"]).wait()\n        except Exception as exc:\n            status.set_exception(exc)\n        else:\n            status.set_finished()\n        finally:\n            self._acquiring_lock.release()\n\n    def trigger(self):\n        status = DeviceStatus(self)\n        i = next(self._counter)\n        thread = threading.Thread(target=self._capture, args=(status, i))\n        thread.start()\n        return status"
  },
  {
    "class_name": "AxisCaprotoCam",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/camera_device.py",
    "source": "class AxisCaprotoCam(Device):\n    '''Simple ophyd class for capturing an Axis Web camera\n    '''\n    write_dir = Component(EpicsSignal, \"write_dir\", string=True)\n    file_name = Component(EpicsSignal, \"file_name\", string=True)\n    full_file_path = Component(EpicsSignalRO, \"full_file_path\", string=True)\n    ioc_stage = Component(EpicsSignal, \"stage\", string=True)\n    acquire = Component(EpicsSignal, \"acquire\", string=True)\n\n    image = Component(ExternalFileReference, kind=Kind.normal)\n\n    def __init__(self, *args, root_dir=None, **kwargs):\n        super().__init__(*args, **kwargs)\n        if root_dir is None:\n            msg = \"The 'root_dir' kwarg cannot be None\"\n            raise RuntimeError(msg)\n        self._root_dir = root_dir\n        self._resource_document, self._datum_factory = None, None\n        self._asset_docs_cache = deque()\n\n    def _update_paths(self):\n        self._root_dir = self.root_path_str\n\n    @property\n    def root_path_str(self):\n        root_path = f\"/nsls2/data3/bmm/proposals/{md['cycle']}/{md['data_session']}/assets/\"\n        return root_path\n\n\n    def collect_asset_docs(self):\n        \"\"\"The method to collect resource/datum documents.\"\"\"\n        items = list(self._asset_docs_cache)\n        self._asset_docs_cache.clear()\n        yield from items\n\n    def stage(self):\n        self._update_paths()\n        super().stage()\n\n        # Clear asset docs cache which may have some documents from the previous failed run.\n        self._asset_docs_cache.clear()\n\n        assets_dir = self.name + datetime.datetime.now().strftime('/%Y/%m/%d')\n        data_file_no_ext = f\"{self.name}_{new_uid()}\"\n        data_file_with_ext = f\"{data_file_no_ext}.jpeg\"\n\n        self._resource_document, self._datum_factory, _ = compose_resource(\n            start={\"uid\": \"needed for compose_resource() but will be discarded\"},\n            spec=\"BMM_JPEG_HANDLER\",\n            root=self._root_dir,\n            resource_path=str(Path(assets_dir) / Path(data_file_with_ext)),\n            resource_kwargs={},\n        )\n\n        # now discard the start uid, a real one will be added later\n        self._resource_document.pop(\"run_start\")\n        self._asset_docs_cache.append((\"resource\", self._resource_document))\n\n        # Update caproto IOC parameters:\n        self.write_dir.put(str(Path(self._root_dir) / Path(assets_dir)))\n        self.file_name.put(data_file_with_ext)\n        self.ioc_stage.put(1)\n\n    def describe(self):\n        res = super().describe()\n        res[self.image.name].update(\n            {\"shape\": (1080, 1920), \"dtype_str\": \"<f4\"}\n        )\n        return res\n\n    def trigger(self):\n\n        def done_callback(value, old_value, **kwargs):\n            \"\"\"The callback function used by ophyd's SubscriptionStatus.\"\"\"\n            # print(f\"{old_value = } -> {value = }\")\n            if old_value == \"acquiring\" and value == \"idle\":\n                return True\n            return False\n\n        status = SubscriptionStatus(self.acquire, run=False, callback=done_callback)\n\n        # Reuse the counter from the caproto IOC\n        self.acquire.put(1)\n\n        datum_document = self._datum_factory(datum_kwargs={})\n        self._asset_docs_cache.append((\"datum\", datum_document))\n\n        self.image.put(datum_document[\"datum_id\"])\n\n        return status\n\n    def unstage(self):\n        self._resource_document = None\n        self._datum_factory = None\n        self.ioc_stage.put(0)\n        super().unstage()"
  },
  {
    "class_name": "TC",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/metadata.py",
    "source": "class TC(Device):\n    temperature = Cpt(EpicsSignal, 'T-I-I')"
  },
  {
    "class_name": "Ring",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/metadata.py",
    "source": "class Ring(Device):\n    current    = Cpt(EpicsSignalRO, ':OPS-BI{DCCT:1}I:Real-I')\n    lifetime   = Cpt(EpicsSignalRO, ':OPS-BI{DCCT:1}Lifetime-I')\n    energy     = Cpt(EpicsSignalRO, '{}Energy_SRBend')\n    mode       = Cpt(EpicsSignalRO, '-OPS{}Mode-Sts', string=True)\n    filltarget = Cpt(EpicsSignalRO, '-HLA{}FillPattern:DesireImA')"
  },
  {
    "class_name": "GlancingAngle",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/glancing_angle.py",
    "source": "class GlancingAngle(Device):\n    '''A class capturing the movement and control of the glancing angle\n    spinner stage.\n\n    Attributes\n    ==========\n    spinner1 .. spinner8 : EpicsSignal\n        The EpicsSignal component for spinner #1 .. 8\n    spin : Bool\n        When True, the ga.to() method will start the spinner\n    home : float\n        Position in xafs_garot of spinner 0\n    inverted : str\n        A string used to recognize whether the linear scan steps up or down\n    flat : list\n        The linear and pitch positions of the flat sample on the current spinner\n    y_uid : str\n        The DataBroker UID of the most recent linear against It scan\n    pitch_uid : str\n        The DataBroker UID of the most recent xafs_pitch against It scan\n    f_uid : str\n        The DataBroker UID of the most recent linear against fluorescence scan\n    alignment_filename : str\n        The fully resolved path to the three-panel, auto-alignment png image\n\n\n    Methods\n    =======\n    current : return the current spoinner number as an integer\n    reset : return xafs_garot to its home position\n    on : turn on the specified spinner\n    off : turn off the specified spinner\n    alloff : turn off all spinners\n    alloff_plan : turn off all spinners as a plan\n    to : move to the specified spinner, turn off all other spinners, turn on this spinner\n    auto_align : perform an automated alignment for the current spinner\n\n    '''\n    spinner1 = Cpt(EpicsSignal, 'OutPt08:Data-Sel')\n    spinner2 = Cpt(EpicsSignal, 'OutPt09:Data-Sel')\n    spinner3 = Cpt(EpicsSignal, 'OutPt10:Data-Sel')\n    spinner4 = Cpt(EpicsSignal, 'OutPt11:Data-Sel')\n    spinner5 = Cpt(EpicsSignal, 'OutPt12:Data-Sel')\n    spinner6 = Cpt(EpicsSignal, 'OutPt13:Data-Sel')\n    spinner7 = Cpt(EpicsSignal, 'OutPt14:Data-Sel')\n    spinner8 = Cpt(EpicsSignal, 'OutPt15:Data-Sel')\n    #rotation\n\n    spin = True\n    automatic = True\n    home = 0\n    garot = xafs_garot\n    inverted = ''\n    flat = [0,0]\n    y_uid = ''\n    pitch_uid = ''\n    f_uid = ''\n    alignment_filename = ''\n    _orientation = 'parallel'\n    toss = os.path.join(user_ns['BMMuser'].folder, 'snapshots', 'toss.png')\n    img = None\n\n    @property\n    def orientation(self):\n        return self._orientation\n    @orientation.setter\n    def orientation(self, value):\n        if value.lower() == 'perpendicular':\n            self._orientation = 'perpendicular'\n            user_ns['gawheel'].orientation = 'perpendicular'\n        else:\n            self._orientation = 'parallel'\n            user_ns['gawheel'].orientation = 'parallel'\n\n    \n    def current(self):\n        '''Return the current spinner number as an integer'''\n        pos = self.garot.position\n        cur = pos % 360\n        here = (9-round(cur/45)) % 8\n        if here == 0:\n            here = 8\n        return here\n\n    def reset(self):\n        '''Return glancing angle stage to spinner 1'''\n        yield from self.alloff_plan()\n        yield from mv(self.garot, self.home)\n        report('Returned to spinner 1 at %d degrees and turned off all spinners' % self.home, level='bold')\n        \n    def valid(self, number=None):\n        '''Check that an argument is an integer between 1 and 8'''\n        if number is None:\n            return False\n        if type(number) is not int:\n            return False\n        if number < 1 or number > 8:\n            return False\n        return True\n        \n    def on(self, number):\n        '''Turn on the specified spinner'''\n        if self.spin is False:\n            warning_msg('The spinners are currently disabled.  do \"ga.spin = True\" to re-enable.')\n            return\n        if not self.valid(number):\n            error_msg('The fans are numbered from 1 to 8')\n            return\n        this = getattr(self, f'spinner{number}')\n        this.put(1)\n    def off(self, number=None):\n        '''Turn off the specified spinner'''\n        if number is None:\n            self.alloff()\n            return\n        if not self.valid(number):\n            error_msg('The fans are numbered from 1 to 8')\n            return\n        this = getattr(self, f'spinner{number}')\n        this.put(0)\n        \n    def alloff(self):\n        '''Turn off all spinners'''\n        for i in range(1,9):\n            self.off(i)\n    def alloff_plan(self):\n        '''Turn off all spinners as a plan'''\n        save = user_ns['RE'].msg_hook\n        user_ns['RE'].msg_hook = None\n        for i in range(1,9):\n            this = getattr(self, f'spinner{i}')\n            yield from mv(this, 0)\n        user_ns['RE'].msg_hook = save\n            \n    def to(self, number):\n        '''Rotate to the specified spinner. Turn off all other spinners.  Turn\n        on the specified spinner.'''\n        if not self.valid(number):\n            error_msg('The fans are numbered from 1 to 8')\n            yield from null()\n            return\n        yield from self.alloff_plan()\n        distance = number - self.current()\n        if distance > 4:\n            distance = distance - 8\n        elif distance < -4:\n            distance = 8 + distance\n        angle = -45*distance\n        yield from mvr(self.garot, angle)\n        if self.spin is True:\n            this = getattr(self, f'spinner{number}')\n            yield from mv(this, 1)\n\n\n    def align_pitch(self, force=False):\n        '''Find the peak of xafs_pitch scan against It. Plot the\n        result. Move to the peak.'''\n        kafka_message({'close': 'last'})\n        motor = user_ns['xafs_pitch']\n        yield from prepare_alignment_scan()\n        uid = yield from linescan(motor, 'it', -2.5, 2.5, 51, dopluck=False, force=force)\n        kafka_message({'close': 'last'})\n\n        \n        kafka_message({'peakfit'    : True,\n                       'uid'        : 'last',\n                       'motor_name' : motor.name,\n                       'signal'     : 'It',\n                       'choice'     : 'peak',\n                       'spinner'    : self.current()})\n        top = fetch_peak_position_via_redis()\n        yield from mv(motor, top)\n\n        \n        # ATTEMPTS = 4\n        # error = None\n        # for attempt in range(ATTEMPTS):\n        #     try:\n        #         table  = user_ns['db'][-1].table()\n        #     except Exception as exc:\n        #         print(f\"glancing angle alignment: Failure {attempt} reading back pitch scan data:\", repr(exc))\n        #         error = exc\n        #     else:\n        #         break\n        #     time.sleep(2)\n        # else:\n        #     # out of attemtps\n        #     raise error\n            \n        # pitch  = table['xafs_pitch']\n        # signal = table['It']/table['I0']\n        # target = signal.idxmax()\n        # yield from mv(xafs_pitch, pitch[target])\n        # kafka_message({'glancing_angle' : 'pitch',\n        #                'motor'          : 'xafs_pitch',\n        #                'center'         : pitch[target],\n        #                'amplitude'      : signal.max(),\n        #                'spinner'        : self.current(),\n        #                'xaxis'          : list(pitch),\n        #                'data'           : list(signal),\n        #                'uid'            : uid,})\n        # #self.pitch_plot(pitch, signal)\n    \n\n    def align_linear(self, force=False, drop=None):\n        '''Fit an error function to the linear scan against It. Plot the\n        result. Move to the centroid of the error function.'''\n        kafka_message({'close': 'last'})\n        if self.orientation == 'parallel':\n            motor = user_ns['xafs_liny']\n        else:\n            motor = user_ns['xafs_linx']\n        yield from prepare_alignment_scan()\n        uid = yield from linescan(motor, 'it', -2.3, 2.3, 51, dopluck=False)\n        kafka_message({'close': 'last'})\n        kafka_message({'stepfit'    : True,\n                       'uid'        : 'last',\n                       'motor_name' : motor.name,\n                       'signal'     : 'It',\n                       'spinner'    : self.current() })\n        target = fetch_peak_position_via_redis()\n        yield from mv(motor, target)\n        \n        \n        # table  = user_ns['db'][-1].table()\n        # yy     = table[motor.name]\n        # signal = table['It']/table['I0']\n        # if drop is not None:\n        #     yy = yy[:-drop]\n        #     signal = signal[:-drop]\n        # if float(signal[2]) > list(signal)[-2] :\n        #     ss     = -(signal - signal[2])\n        #     self.inverted = 'inverted '\n        # else:\n        #     ss     = signal - signal[2]\n        #     self.inverted    = ''\n        # mod    = StepModel(form='erf')\n        # pars   = mod.guess(ss, x=numpy.array(yy))\n        # out    = mod.fit(ss, pars, x=numpy.array(yy))\n        # whisper(out.fit_report(min_correl=0))\n        # target = out.params['center'].value\n        # yield from mv(motor, target)\n        # kafka_message({'glancing_angle' : 'linear',\n        #                'motor'          : motor.name,\n        #                'center'         : target,\n        #                'amplitude'      : out.params['amplitude'].value,\n        #                'inverted'       : self.inverted,\n        #                'spinner'        : self.current(),\n        #                'xaxis'          : list(yy),\n        #                'data'           : list(ss),\n        #                'best_fit'       : list(out.best_fit),\n        #                'uid'            : uid,})\n\n        #self.y_plot(yy, out)\n\n\n    def align_fluo(self, force=False):\n        kafka_message({'close': 'last'})\n        BMMuser = user_ns['BMMuser']\n        yield from prepare_alignment_scan()\n        if self.orientation == 'parallel':\n            motor = user_ns['xafs_liny']\n        else:\n            motor = user_ns['xafs_linx']\n        uid = yield from linescan(motor, 'xs', -1.8, 1.8, 51, dopluck=False, force=force, stack=False)\n        kafka_message({'close': 'last'})\n        kafka_message({'peakfit'    : True,\n                       'uid'        : 'last',\n                       'motor_name' : motor.name,\n                       'signal'     : 'If',\n                       'choice'     : 'peak',\n                       'spinner'    : self.current()})\n        target = fetch_peak_position_via_redis()\n        yield from mv(motor, target)\n        self.f_uid = uid\n\n        # tf = user_ns['db'][-1].table()\n        # yy = tf[motor.name]\n        # yy = yy[2:]             # spurious first point in fluo scan due to Xspress3 issue 24 July 2024\n        # rkvs = user_ns['rkvs']\n        # detector = rkvs.get('BMM:xspress3').decode('utf-8')\n        # if detector == '1':\n        #     signal = tf[BMMuser.xs1] / tf['I0']\n        # elif detector == '4':\n        #     signal = (tf[BMMuser.xs1] +\n        #               tf[BMMuser.xs2] +\n        #               tf[BMMuser.xs3] +\n        #               tf[BMMuser.xs4]) / tf['I0']\n        # elif detector == '7':\n        #     signal = (tf[BMMuser.xs1] +\n        #               tf[BMMuser.xs2] +\n        #               tf[BMMuser.xs3] +\n        #               tf[BMMuser.xs4] +\n        #               tf[BMMuser.xs5] +\n        #               tf[BMMuser.xs6] +\n        #               tf[BMMuser.xs7]) / tf['I0']\n        # signal = signal[2:]\n        # #if BMMuser.element in ('Cr', 'Zr'):\n        # centroid = yy[signal.idxmax()]\n        # #else:\n        # #    com = int(center_of_mass(signal)[0])+1\n        # #    centroid = yy[com]\n        # yield from mv(motor, centroid)\n        # kafka_message({'glancing_angle' : 'fluo',\n        #                'motor'          : motor.name,\n        #                'center'         : centroid,\n        #                'amplitude'      : signal.max(),\n        #                'inverted'       : self.inverted,\n        #                'spinner'        : self.current(),\n        #                'xaxis'          : list(yy),\n        #                'data'           : list(signal),\n        #                'uid'            : uid,})\n\n        \n    def auto_align(self, pitch=2, drop=None):\n        '''Align a sample on a spinner automatically.  This performs 5 scans.\n        The first four iterate twice between linear and pitch\n        against the signal in It.  This find the flat position.\n\n        Then the sample is pitched to the requested angle and a fifth\n        scan is done to optimize the linear motor position against the\n        fluorescence signal.\n\n        The linear scans against It look like a step-down function.\n        The center of this step is found as the centroid of a fitted\n        error function.\n\n        The xafs_pitch scan should be peaked.  Move to the max of the\n        signal.\n\n        The linear scan against fluorescence ideally looks like a\n        flat-topped peak.  Move to the center of mass.\n\n        At the end, a three-panel figure is drawn showing the last\n        three scans.  This is posted to Slack.  It also finds its way\n        into the dossier as a record of the quality of the alignment.\n\n        Arguments\n        =========\n        pitch : int\n          The angle at which to make the glancing angle measurements.\n        drop : int or None\n          If not None, then this many points will be dropped from the\n          end of linear scan against transmission when fitting the error\n          function. This is an attempt to deal gracefully with leakage \n          through the adhesive at very high energy.\n\n        '''\n        BMMuser = user_ns['BMMuser']\n\n        def main_plan(pitch, drop):\n            if BMMuser.macro_dryrun:\n                report(f'Auto-aligning glancing angle stage, spinner {self.current()}', level='bold', slack=False)\n                info_msg(f'\\nBMMuser.macro_dryrun is True.  Sleeping for %.1f seconds at spinner %d.\\n' %\n                               (BMMuser.macro_sleep, self.current()))\n                countdown(BMMuser.macro_sleep)\n                return(yield from null())\n\n            report(f'Auto-aligning glancing angle stage, spinner {self.current()}', level='bold', slack=True)\n\n            BMM_suspenders()\n            self.alignment_filename = os.path.join(proposal_base(), 'snapshots', f'spinner{self.current()}-alignment-{now()}.png')\n            kafka_message({'glancing_angle' : 'start',\n                           'filename' : self.alignment_filename})\n\n            ## first pass in transmission\n            yield from self.align_linear(drop=drop)\n            yield from sleep(1)\n            yield from self.align_pitch()\n            yield from sleep(1)\n\n            ## for realsies X or Y in transmission\n            yield from self.align_linear(drop=drop)\n            #self.y_uid = user_ns['db'].v2[-1].metadata['start']['uid'] \n            yield from sleep(1)\n            kafka_message({'close': 'all'})\n\n            ## for realsies Y in pitch\n            yield from self.align_pitch()\n            #self.pitch_uid = user_ns['db'].v2[-1].metadata['start']['uid'] \n            yield from sleep(1)\n            kafka_message({'close': 'all'})\n\n            ## record the flat position\n            if self.orientation == 'parallel':\n                motor = user_ns['xafs_y']\n            else:\n                motor = user_ns['xafs_x']\n            self.flat = [motor.position, user_ns['xafs_pitch'].position]\n\n            ## move to measurement angle and align\n            yield from mvr(user_ns['xafs_pitch'], pitch)\n            yield from self.align_fluo()\n            self.f_uid = user_ns['db'].v2[-1].metadata['start']['uid'] \n\n\n        def cleanup_plan():\n            yield from mv(_locked_dwell_time, 0.5)\n            yield from resting_state_plan()\n            kafka_message({'close': 'all'})\n            kafka_message({'glancing_angle' : 'stop'})\n            self.y_uid     = user_ns['rkvs'].get('BMM:ga:xy_uid').decode('utf-8')\n            self.pitch_uid = user_ns['rkvs'].get('BMM:ga:pitch_uid').decode('utf-8')\n            self.f_uid     = user_ns['rkvs'].get('BMM:ga:fluo_uid').decode('utf-8')\n            \n        user_ns['RE'].msg_hook = None\n        yield from finalize_wrapper(main_plan(pitch=2, drop=None), cleanup_plan())\n        user_ns['RE'].msg_hook = BMM_msg_hook\n        BMM_clear_suspenders()\n \n\n\n        \n    def flatten(self):\n        '''Return the stage to its nominally flat position.'''\n        xafs_pitch = user_ns['xafs_pitch']\n        if self.orientation == 'parallel':\n            motor = user_ns['xafs_y']\n        else:\n            motor = user_ns['xafs_x']\n        if self.flat != [0, 0]:\n            yield from mv(motor, self.flat[0], xafs_pitch, self.flat[1])\n        \n\n    def dossier_entry(self):\n        thistext  =  '\t    <div>\\n'\n        thistext +=  '\t      <h3>Instrument: Glancing angle stage</h3>\\n'\n        thistext +=  '\t      <ul>\\n'\n        thistext += f'               <li><b>Spinner:</b> {self.current()}</li>\\n'\n        if self.automatic is True:\n            thistext +=  '               <li><b>Alignment:</b> automatic</li>\\n'\n            thistext += f'               <li><b>Tilt angle:</b> {xafs_pitch.position - self.flat[1]:.1f}</li>\\n'\n        else:\n            thistext +=  '               <li><b>Alignment:</b> manual</li>\\n'\n            thistext += f'               <li><b>Tilt angle:</b> {xafs_pitch.position:.1f}</li>\\n'\n        thistext += f'               <li><b>Spinning:</b> {\"yes\" if self.spin else \"no\"}</li>\\n'\n        thistext +=  '\t      </ul>\\n'\n        thistext +=  '\t    </div>\\n'\n        return thistext\n\n    def ready_to_start(self):\n        ## NEVER prompt when using queue server\n        if is_re_worker_active() is True:\n            user_ns['BMMuser'].prompt = False\n        if user_ns['BMMuser'].prompt:\n            #action = input(\"\\nIs the glancing angle stage currently flat? \" + PROMPT)\n            print()\n            action = animated_prompt('Is the glancing angle stage currently flat? ' + PROMPTNC)\n            if action != '':\n                if action[0].lower() != 'y':\n                    return False\n        return True"
  },
  {
    "class_name": "DeadbandMixin",
    "bases": [
      "Device",
      "PositionerBase"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/motors.py",
    "source": "class DeadbandMixin(Device, PositionerBase):\n    \"\"\"\n    Should be the leftmost class in the inheritance list so that it grabs move first!\n\n    Must be combined with either EpicsMotor or PVPositioner, or some other class\n    that has a done_value attribute\n\n    An EpicsMotor subclass that has an absolute tolerance for moves.\n    If the readback is within tolerance of the setpoint, the MoveStatus\n    is marked as finished, even if the motor is still settling.\n\n    This prevents motors with long, but irrelevant, settling times from\n    adding overhead to scans.\n    \"\"\"\n\n    tolerance = Cpt(Signal, value=-1, kind=\"omitted\")\n    move_latch = Cpt(Signal, value=0, kind=\"omitted\")\n\n    def __init__(self, *args, tolerance=None, **kwargs):\n        super().__init__(*args, **kwargs)\n        if tolerance is not None:\n            self.tolerance.put(tolerance)\n\n    def _done_moving(self, success=True, timestamp=None, value=None, **kwargs):\n        \"\"\"Call when motion has completed.  Runs ``SUB_DONE`` subscription.\"\"\"\n        if self.move_latch.get():\n            #print(f\"{timestamp} {datetime.today().time().isoformat()} [{self.name}]: marked done\")\n            if success:\n                self._run_subs(sub_type=self.SUB_DONE, timestamp=timestamp, value=value)\n\n            self._run_subs(\n                sub_type=self._SUB_REQ_DONE, success=success, timestamp=timestamp\n            )\n            self._reset_sub(self._SUB_REQ_DONE)\n            self.move_latch.put(0)\n\n    def move(self, position, wait=True, **kwargs):\n        tolerance = self.tolerance.get()\n\n        if tolerance < 0:\n            self.move_latch.put(1)\n            return super().move(position, wait=wait, **kwargs)\n        else:\n            status = super().move(position, wait=False, **kwargs)\n            setpoint = position\n            done_value = getattr(self, \"done_value\", 1)\n\n            def check_deadband(value, timestamp, **kwargs):\n                if abs(value - setpoint) < tolerance:\n                    #print(f\"{timestamp} {datetime.today().time().isoformat()} [{self.name}]: {value} within {tolerance} of {setpoint}\")\n                    self._done_moving(\n                        timestamp=timestamp, success=True, value=done_value\n                    )\n                else:\n                    pass\n                    # print(f\"{timestamp}: {self.name}, {value} not within {tolerance} of {setpoint}\")\n\n            def clear_deadband(*args, **kwargs):\n                # print(f\"{timestamp}: Ran deadband clear for {self.name}\")\n                self.clear_sub(check_deadband, event_type=self.SUB_READBACK)\n\n            self.subscribe(clear_deadband, event_type=self._SUB_REQ_DONE, run=False)\n            self.move_latch.put(1)\n            self.subscribe(check_deadband, event_type=self.SUB_READBACK, run=True)\n\n            try:\n                if wait:\n                    status_wait(status)\n            except KeyboardInterrupt:\n                self.stop()\n                raise\n\n            return status"
  },
  {
    "class_name": "FEBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/frontend.py",
    "source": "class FEBPM(Device):\n    x = Cpt(EpicsSignalRO, 'X-I')\n    y = Cpt(EpicsSignalRO, 'Y-I')"
  },
  {
    "class_name": "EPS_Shutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/actuators.py",
    "source": "class EPS_Shutter(Device):\n    state = Cpt(EpicsSignal, 'Pos-Sts')\n    cls = Cpt(EpicsSignal, 'Cmd:Cls-Cmd')\n    opn = Cpt(EpicsSignal, 'Cmd:Opn-Cmd')\n    error = Cpt(EpicsSignal,'Err-Sts')\n    permit = Cpt(EpicsSignal, 'Permit:Enbl-Sts')\n    enabled = Cpt(EpicsSignal, 'Enbl-Sts')\n    maxcount = 4\n    openval = 1                 # normal shutter values, FS1 is reversed\n    closeval = 0\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        #self.color = 'red'\n\n    def status(self):\n        if self.state.get() == 1:\n            return 'closed'\n        else:\n            return 'open'\n\n    def open_plan(self):\n        user_ns['RE'].msg_hook = None\n        count = 0\n        while self.state.get() != self.openval:\n            count += 1\n            print(u'\\u231b', end=' ', flush=True)\n            yield from mv(self.opn, 1)\n            if count >= self.maxcount:\n                print('tried %d times and failed to open %s %s' % (count, self.name, ':('))  # u'\\u2639'  unicode frown\n                return(yield from null())\n            time.sleep(1.5)\n        report('Opened {}'.format(self.name))\n        user_ns['RE'].msg_hook = BMM_msg_hook\n\n    def close_plan(self):\n        user_ns['RE'].msg_hook = None\n        count = 0\n        while self.state.get() != self.closeval:\n            count += 1\n            print(u'\\u231b', end=' ', flush=True)\n            yield from mv(self.cls, 1)\n            if count >= self.maxcount:\n                print('tried %d times and failed to close %s %s' % (count, self.name, ':('))\n                return(yield from null())\n            time.sleep(1.5)\n        report('Closed {}'.format(self.name))\n        user_ns['RE'].msg_hook = BMM_msg_hook\n\n    def open(self):\n        user_ns['RE'].msg_hook = None\n        if self.state.get() != self.openval:\n            count = 0\n            while self.state.get() != self.openval:\n                count += 1\n                print(u'\\u231b', end=' ', flush=True)\n                self.opn.put(1)\n                if count >= self.maxcount:\n                    print('tried %d times and failed to open %s %s' % (count, self.name, ':('))\n                    return\n                time.sleep(1.5)\n            report(' Opened {}'.format(self.name))\n        else:\n            print('{} is open'.format(self.name))\n        user_ns['RE'].msg_hook = BMM_msg_hook\n\n    def close(self):\n        user_ns['RE'].msg_hook = None\n        if self.state.get() != self.closeval:\n            count = 0\n            while self.state.get() != self.closeval:\n                count += 1\n                print(u'\\u231b', end=' ', flush=True)\n                self.cls.put(1)\n                if count >= self.maxcount:\n                    print('tried %d times and failed to close %s %s' % (count, self.name, ':('))\n                    return\n                time.sleep(1.5)\n            report(' Closed {}'.format(self.name))\n        else:\n            print('{} is closed'.format(self.name))\n        user_ns['RE'].msg_hook = BMM_msg_hook\n\n    def _state(self):\n        if self.state.get() == self.closeval:\n            state = 'closed'\n            if self.name == 'FS1':\n                return 'retracted'\n            if self.name == 'LN2':\n                return state\n            return f'[red]{state}[/red]'\n        state = 'open'\n        if self.name == 'FS1':\n            return '[red]in place[/red]'\n        if self.name == 'LN2':\n            return f'[pale_turquoise1]{state}[/pale_turquoise1]'\n        return(state + '  ')"
  },
  {
    "class_name": "BMPS_Shutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/actuators.py",
    "source": "class BMPS_Shutter(Device):\n    state = Cpt(EpicsSignal, 'Sts:BM_BMPS_Opn-Sts')"
  },
  {
    "class_name": "IDPS_Shutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/actuators.py",
    "source": "class IDPS_Shutter(Device):\n    state = Cpt(EpicsSignal, 'Sts:BM_PS_OpnA3-Sts')"
  },
  {
    "class_name": "BMMXspress3DetectorBase",
    "bases": [
      "Xspress3Trigger",
      "Xspress3Detector"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/xspress3.py",
    "source": "class BMMXspress3DetectorBase(Xspress3Trigger, Xspress3Detector):\n    '''This class captures everything that is in common for the 1-element\n    and 4-element detector interfaces.\n    '''\n\n    # if sys.version_info[1] < 10:\n    #     ## HDF5 storage semantics prior to January 2023\n    #     hdf5 = Cpt(Xspress3FileStoreFlyable, 'HDF1:',\n    #                read_path_template='/nsls2/data3/bmm/assets/xspress3/2022',  # path to data folder, as mounted on client (i.e. Lustre) \n    #                root='/nsls2/data3/bmm/',                                    # path to root, as mounted on client (i.e. Lustre)\n    #                write_path_template='/nsls2/data3/bmm/assets/xspress3/2022', # full path on IOC server (i.e. xf06bm-xspress3)\n    #                )\n    # else:\n        ## new HDF5 storage semantics as of January 2023\n\n\n\n    hdf5 = Cpt(BMMXspress3HDF5Plugin,\n               \"HDF1:\", \n               name=\"h5p\",\n               root_path=None,\n               path_template=None,\n               resource_kwargs={},\n    )\n\n    acquire_busy = Cpt(EpicsSignal, \"AcquireBusy\")\n    erase = Cpt(EpicsSignal, 'det1:ERASE')\n    Acquire = Cpt(EpicsSignal, 'det1:Acquire')\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n        if configuration_attrs is None:\n            configuration_attrs = ['external_trig', 'total_points', 'spectra_per_point', 'cam', 'rewindable']\n\n        ## is this line needed?  I think the class builder takes care of this\n        if read_attrs is None:\n            read_attrs = ['channel01', 'channel02', 'channel03', 'channel04', 'hdf5'] #, 'channel8'\n            #, 'channel5', 'channel6', 'channel7', 'channel8'\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n\n        self.hdf5.num_extra_dims.put(0)\n\n        ## May 22, 2024: this PV suppresses the EraseOnStart function\n        ## of the Xspress3 IOC.  When on and used in the way BMM uses\n        ## the IOC, this leads to trouble in the form of a \"ghost\n        ## frame\" whenever the Xspress3 is counted.  This confuses a\n        ## simple count, and also adds considerable overhead to an\n        ## XAFS scan.  These two lines force that PV to off in a way\n        ## that is intentionally hidden.\n        erase_on_start = EpicsSignal('XF:06BM-ES{Xsp:1}:det1:EraseOnStart', name='erase_on_start')\n        erase_on_start.put(0)\n\n        \n        self._asset_docs_cache = deque()\n        self._datum_counter = None\n        \n        self.slots = ['Ti', 'V',  'Cr', 'Mn',\n                      'Fe', 'Co', 'Ni', 'Cu',\n                      'Zn', 'Ge', 'As', 'Br',\n                      'Pt', 'Au', 'Pb', 'Nb',\n                      'Mo', 'K', None, 'OCR']\n        self.restart()\n\n    def new_acquire_status(self):\n        \"\"\"\n        Create and return a Status object that will be marked\n        as `finished` when acquisition is done (see _acquire_changed). The\n        intention is that this Status will be used by another object,\n        for example a RunEngine.\n\n        This method is intended only to be used by the trigger method.\n\n        Override this method if a more complex status object is needed.\n\n        Returns\n        -------\n        DeviceStatus\n        \"\"\"\n\n        return DeviceStatus(self, settle_time=0.05)\n\n    # JL: trying to use Xspress3Trigger.trigger\n    #     which is almost identical to this\n    def trigger_hide(self):\n        if self._staged != Staged.yes:\n            raise RuntimeError(\"not staged\")\n\n        import epics\n        #t = '{:%H:%M:%S.%f}'.format(datetime.datetime.now())\n        #print('tr1 {} '.format(t))\n        self._status = DeviceStatus(self)\n        self.cam.acquire.put(1, wait=False, use_complete=True)\n        trigger_time = ttime.time()\n        #t = '{:%H:%M:%S.%f}'.format(datetime.datetime.now())\n        #print('tr2 {} '.format(t))\n\n        for sn in self.read_attrs:\n            if sn.startswith('channel') and '.' not in sn:\n                ch = getattr(self, sn)\n                self.dispatch(ch.name, trigger_time)\n        #t = '{:%H:%M:%S.%f}'.format(datetime.datetime.now())\n        #print('tr3 {} '.format(t))\n\n        self._abs_trigger_count += 1\n        return self._status\n    \n    def restart(self):\n        self.cam.num_images.put(1)\n        self.cam.trigger_mode.put(1)\n        self.cam.ctrl_dtc.put(1)\n        self.set_rois()\n        \n    def _acquire_changed_hide(self, value=None, old_value=None, **kwargs):\n        #print(f\"!!! HERE I AM !!!   {value}  {old_value}  {id(self._status)}  {self._status}\")\n        super()._acquire_changed(value=value, old_value=old_value, **kwargs)\n        status = self._status\n        if status is not None and status.done:\n            # Clear the state to be ready for the next round.\n            self._status = None\n        #print(f\"!!! END !!!   {value}  {old_value}  {status}  {id(self._status)}  {self._status}\")\n            \n    def stop(self):\n        ret = super().stop()\n        self.hdf5.stop()\n        return ret\n\n    def stage(self):\n        if self.spectra_per_point.get() != 1:\n            raise NotImplementedError(\n                \"multi spectra per point not supported yet\")\n        ret = super().stage()\n        self._datum_counter = itertools.count()\n        return ret\n\n    def unstage(self):\n        self.cam.trigger_mode.put(0)\n        super().unstage()\n        self._datum_counter = None\n        self._status = None\n\n    def reset(self):\n        '''call the signals to clear ROIs.  Would like to clear array sums as well....\n        '''\n        for channel in self.iterate_channels():\n            # this probably still doesn't work\n            channel.mca_sum.array_data.put(numpy.zeros)\n        self.erase.put(1)\n\n    def describe(self):        \n        res = super().describe()\n        # res[self.xrf.name][\"shape\"] = (8, 4096)\n        for channel in self.iterate_channels():\n            res[channel.name+'_xrf']['dtype_str'] = '<f8'\n        # try:\n        #     res['4-element SDD_channel01_xrf']['dtype_str'] = '<f8'\n        #     res['4-element SDD_channel02_xrf']['dtype_str'] = '<f8'\n        #     res['4-element SDD_channel03_xrf']['dtype_str'] = '<f8'\n        #     res['4-element SDD_channel04_xrf']['dtype_str'] = '<f8'\n        # except:\n        #     pass\n        # try:\n        #     res['1-element SDD_channel08_xrf']['dtype_str'] = '<f8'\n        # except:\n        #     pass            \n        return res\n\n    def set_rois(self):\n        '''Read ROI values from a JSON serialization on disk and set all 16 ROIs for channels 1-4.\n        '''\n        with open(os.path.join(startup_dir, 'rois.json'), 'r') as fl:\n            js = fl.read()\n        allrois = json.loads(js)\n        for i, el in enumerate(self.slots):\n            if el == 'OCR':\n                for channel in self.iterate_channels():\n                    mcaroi = channel.get_mcaroi(mcaroi_number=i+1)\n                    self.set_roi(\n                        mcaroi,\n                        name='OCR',\n                        min_x=allrois['OCR']['low'],\n                        size_x=allrois['OCR']['high'] - allrois['OCR']['low']\n                    )\n                \n                continue\n            elif el is None:\n                for channel in self.iterate_channels():\n                    mcaroi = channel.get_mcaroi(mcaroi_number=i+1)\n                    self.set_roi(\n                        mcaroi,\n                        name='none',\n                        min_x=0,\n                        size_x=0\n                    )\n                continue\n            edge = 'k'\n            if Z_number(el) > 45:\n                edge = 'l3'\n            if el == user_ns['BMMuser'].element:\n                edge = user_ns['BMMuser'].edge.lower()\n            for channel in self.iterate_channels():\n                mcaroi = channel.get_mcaroi(mcaroi_number=i+1)\n                #print(f\"element: {el} edge: {edge} mcaroi number: {mcaroi.mcaroi_number} \")\n                self.set_roi(\n                    mcaroi,\n                    name=f'{el.capitalize()}{channel.channel_number}',\n                    min_x=allrois[el][edge]['low'],\n                    size_x=allrois[el][edge]['high'] - allrois[el][edge]['low']\n                )\n                # Azure testing error happens at this line ^\n\n    def reload_rois(self):\n        '''This reloads the rois.json file and resets all uses of that information.\n        '''\n        self.set_rois()\n        kafka_message({'reset_rois': True})\n        print('Reloaded rois.json and reset ROI values.')\n        \n    def measure_roi(self):\n        '''Hint the ROI currently in use for XAS\n        '''\n        BMMuser = user_ns['BMMuser']\n        hint_potassium = profile_configuration.getboolean('experiments', 'hint_potassium')  # special consideration for molten salt experiments\n        for channel in self.iterate_channels():\n            for mcaroi in channel.iterate_mcarois():\n                if self.slots[mcaroi.mcaroi_number-1] == BMMuser.element:\n                    mcaroi.kind = 'hinted'\n                    mcaroi.total_rbv.kind = 'hinted'\n                    setattr(BMMuser, f'xs{channel.channel_number}', mcaroi.total_rbv.name) \n                    setattr(BMMuser, f'xschannel{channel.channel_number}', mcaroi.total_rbv)\n                    #EpicsSignal(mcaroi.total_rbv.pvname + \".PREC\", name='').put(1)\n                elif self.slots[mcaroi.mcaroi_number-1] == 'K' and hint_potassium is True:\n                    mcaroi.kind = 'hinted'\n                    mcaroi.total_rbv.kind = 'hinted'\n                # elif self.slots[mcaroi.mcaroi_number-1] == 'La':\n                #     mcaroi.kind = 'hinted'\n                #     mcaroi.total_rbv.kind = 'hinted'\n                else:\n                    mcaroi.kind = 'omitted'\n                    mcaroi.total_rbv.kind = 'omitted'\n\n    def measure_multiple_rois(self, roilist=()):\n        '''Hint multiple ROIs for XAS use\n        '''\n        BMMuser = user_ns['BMMuser']\n        hint_potassium = profile_configuration.getboolean('experiments', 'hint_potassium')  # special consideration for molten salt experiments\n        for channel in self.iterate_channels():\n            for mcaroi in channel.iterate_mcarois():\n                if self.slots[mcaroi.mcaroi_number-1] in roilist:\n                    mcaroi.kind = 'hinted'\n                    mcaroi.total_rbv.kind = 'hinted'\n                    setattr(BMMuser, f'xs{channel.channel_number}', mcaroi.total_rbv.name) \n                    setattr(BMMuser, f'xschannel{channel.channel_number}', mcaroi.total_rbv)\n                    #EpicsSignal(mcaroi.total_rbv.pvname + \".PREC\", name='').put(1)\n                elif self.slots[mcaroi.mcaroi_number-1] == 'K' and hint_potassium is True:\n                    mcaroi.kind = 'hinted'\n                    mcaroi.total_rbv.kind = 'hinted'\n                # elif self.slots[mcaroi.mcaroi_number-1] == 'La':\n                #     mcaroi.kind = 'hinted'\n                #     mcaroi.total_rbv.kind = 'hinted'\n                else:\n                    mcaroi.kind = 'omitted'\n                    mcaroi.total_rbv.kind = 'omitted'\n\n                    \n    def livetable_precision(self, val=1):\n        '''Set sensible LiveTable precision for the ROI readback values.\n        '''\n        for i, channel in enumerate(self.iterate_channels()):\n            print(f'Channel {i+1}: ', end='', flush=True)\n            for j, mcaroi in enumerate(channel.iterate_mcarois()):\n                print(f' {j+1}', end='', flush=True)\n                EpicsSignal(mcaroi.total_rbv.pvname + \".PREC\", name='').put(1)\n            print('', flush=True)\n        whisper('\\nYou should restart bsui to have this take effect.')\n            \n    def set_roi(self, mcaroi, name='OCR', min_x=1, size_x=4095):\n        \"\"\"\n        Combine setting PVs and setting the 'name' field of a mcaroi.\n        \"\"\"\n        # if type(name) is bytes:\n        #     name.decode('utf8')\n        mcaroi.configure_mcaroi(\n            roi_name=name,\n            min_x=min_x,\n            size_x=size_x            \n        )\n        mcaroi.name = name\n        mcaroi.total_rbv.name = name\n\n\n    def set_roi_channel(self, channel, index=16, name='OCR', low=1, high=4095):\n        mcaroi = channel.get_mcaroi(mcaroi_number=index)\n        mcaroi.total_rbv.name = name\n        mcaroi.min_x.put(low)\n        mcaroi.size_x.put(high - low)\n\n        \n    def reset_rois(self, el=None, tab='', quiet = False):\n        BMMuser = user_ns['BMMuser']\n        if el is None:\n            el = BMMuser.element\n        if el in self.slots:\n            if quiet is False:\n                whisper(f'{tab}Resetting rois with {el} as the active ROI')\n            BMMuser.element = el\n            self.set_rois()\n            self.measure_roi()\n        else:\n            error_msg(f'{tab}Cannot reset rois, {el} is not in {self.name}.slots')\n\n    def roi_details(self):\n        first_channel_number = self.channel_numbers[0]\n        first_channel = self.get_channel(channel_number=first_channel_number)\n\n        print('\\n     El   hinting                low    high')\n        print('==============================================')\n        for i,x in enumerate(list(first_channel.iterate_mcarois())):\n            name = re.sub(r'\\d', '', x.name)\n            print(f\" {i+1:>2d}  {name:<4s}  {x.kind.name:<20s}  {10*x.min_x.get():>5d}  {10*(x.min_x.get()+x.size_x.get()):>5d}\")\n    list_rois = roi_details\n                \n\n    def show_rois(self):\n        BMMuser = user_ns['BMMuser']\n        text  = '[bold green]    1      2      3      4      5      6      7      8      9     10[/bold green]\\n'\n        text += ' '\n        for i in range(10):\n            if self.slots[i] == BMMuser.element:\n                text += '[yellow1]%4.4s' % self.slots[i]\n                text += '[/yellow1]   '\n            else:\n                text += '%4.4s' % self.slots[i]\n                text += '   '\n        text += '\\n\\n'\n        text += '[bold green]   11     12     13     14     15     16     17     18     19     20[/bold green]\\n'\n        text += ' '\n        for i in range(10, 20):\n            if self.slots[i] == BMMuser.element:\n                text += '[yellow1]%4.4s' % self.slots[i]\n                text += '[/yellow1]   '\n            else:\n                text += '%4.4s' % self.slots[i]\n                text += '   '\n        #text += '\\n'\n        boxedtext(text, title=\"Xspress3 ROIs\", color='yellow')\n\n\n    def check_element(self, element, edge):\n        '''Check that the current element and edge is tabulated in rois.json\n        '''\n        with open(os.path.join(startup_dir, 'rois.json'), 'r') as fl:\n            js = fl.read()\n        allrois = json.loads(js)\n        if element.capitalize() not in allrois:\n            #print(f'{element} is not a tabulated element')\n            return False\n        this = allrois[element]\n        if edge.lower() not in this:\n            #print(f'ROI for the {element} {edge} edge are not tabulated')\n            return False\n        if this[edge.lower()]['low'] == 0 or this[edge.lower()]['high'] == 0:\n            #print(f'ROI for the {element} {edge} edge are not tabulated')\n            return False\n        return True\n    \n\n    def measure_xrf(self, exposure=1.0, doplot=True):\n        '''Measure, table, plot -- in a package suitable for an ipython magic.\n        '''\n        uid = None\n        self.total_points.put(1)\n        self.cam.acquire_time.put(exposure)\n        self.cam.acquire.put(1)\n        ttime.sleep(exposure + 0.5)\n        self.table()\n        if doplot:\n            self.plot(add=True, uid=uid)\n        \n\n    def hinted_roi(self):\n        chan = self.channel01\n        for i in range(1,21):\n            roi = getattr(chan, f'mcaroi{i:02d}')\n            if int(roi.kind) == 7:\n                return roi\n        return None\n            \n            \n    def plot(self, uid=None, add=False, only=None, show_roi=True): \n        '''Make a plot appropriate for the N-element detector.\n\n        The default is to sum the four channels.\n        \n        Parameters\n        ----------\n        uid : str\n            DataBroker UID. If None, use the current values in the IOC\n        add : bool\n            If True, plot the sum of the four channels\n        only : int\n            plot only the signal from a specific channel -- (1) / (1-4) / (1-7)\n        \n        '''\n        if uid is not None:\n            kafka_message({'xrf': 'plot', 'uid': uid, 'add': add, 'only': only})\n        else:\n            dcm, BMMuser = user_ns['dcm'], user_ns['BMMuser']\n            plt.clf()\n            plt.xlabel('Energy  (eV)')\n            plt.ylabel('counts')\n            plt.grid(which='major', axis='both')\n            plt.xlim(2500, round(dcm.energy.position, -2)+500)\n            plt.title(f'XRF Spectrum {BMMuser.element} {BMMuser.edge}')\n            s = list()\n            for channel in self.iterate_channels():\n                s.append(channel.mca.array_data.get())\n            e = numpy.arange(0, len(s[0])) * 10\n            plt.ion()\n            if only is not None and only in range(1, len(list(self.iterate_channels()))+1):\n                channel = self.get_channel(channel_number=only)\n                this = channel.mca.array_data\n                plt.plot(e, this.get(), label=f'channel {only}')\n            elif add is True:\n                plt.plot(e, sum(s), label=f'sum of {len(list(self.iterate_channels()))} channels')\n            else:\n                for i, sig in enumerate(s):\n                    plt.plot(e, sig, label=f'channel {i+1}')\n            z = Z_number(BMMuser.element)\n            roicolor = '#aaaaaadd'\n            if BMMuser.edge.lower() == 'k':\n                label = f'{BMMuser.element} K\u03b1 ROI'\n                ke = (2*xraylib.LineEnergy(z, xraylib.KL3_LINE) + xraylib.LineEnergy(z, xraylib.KL2_LINE))*1000/3\n                plt.axvline(x = ke/1.0016,  color = roicolor, linewidth=1, label=label)\n                    \n            elif BMMuser.edge.lower() == 'l3':\n                label = f'{BMMuser.element} L\u03b1 ROI'\n                plt.axvline(x = xraylib.LineEnergy(z, xraylib.L3M5_LINE)*1000, color = roicolor, linewidth=1, label=label)\n            elif BMMuser.edge.lower() == 'l2':\n                label = f'{BMMuser.element} K\u03b21 ROI'\n                plt.axvline(x = xraylib.LineEnergy(z, xraylib.L2M4_LINE)*1000, color = roicolor, linewidth=1, label=label)\n            elif BMMuser.edge.lower() == 'l1':\n                label = f'{BMMuser.element} K\u03b23 ROI'\n                plt.axvline(x = xraylib.LineEnergy(z, xraylib.L1M3_LINE)*1000, color = roicolor, linewidth=1, label=label)\n\n            ## highlight the ROI\n            if show_roi is True:\n                roi = self.hinted_roi()\n                if roi is not None:\n                    lower = roi.min_x.get() * 10\n                    upper = lower + roi.size_x.get() * 10\n                    #plt.axvline(x=lower,  color = 'tab:gray', linewidth=1, label=label)\n                    #plt.axvline(x=upper,  color = 'tab:gray', linewidth=1, label=label)\n                    axis = plt.gca()\n                    ymin, ymax = axis.get_ylim()\n                    axis.add_patch(Rectangle((lower,ymin), upper-lower, ymax-ymin, facecolor=roicolor))\n            plt.legend()\n            #plt.show()\n    \n    def table(self):\n        '''Pretty print a table of values for each ROI and for all N channels.\n        '''\n        BMMuser, dcm = user_ns['BMMuser'], user_ns['dcm']\n\n        edge = xraylib.EdgeEnergy(Z_number(BMMuser.element), int(edge_number(BMMuser.edge)))*1000\n\n        if dcm.energy.position > edge:\n            print(f'{BMMuser.element} {BMMuser.edge} -- current energy: {round(dcm.energy.position, 1)}\\n')\n        else:\n            warning_msg(f'{BMMuser.element} {BMMuser.edge} -- current energy: {round(dcm.energy.position, 1)}  *** Below Edge! ***\\n')\n\n        print(' ROI     ', end='')\n        for i, channel in enumerate(self.iterate_channels()):\n            print(f' Chan{i+1}     ', end='')\n        print()\n        print('========', end='')\n        print('==========='*len(list(self.iterate_channels())))\n\n        first_channel_number = self.channel_numbers[0]\n        first_channel = self.get_channel(channel_number=first_channel_number)\n        for r in first_channel.mcaroi_numbers:\n            el = first_channel.get_mcaroi(mcaroi_number=r).name\n            if len(el) > 3:\n                continue\n            if el != 'OCR':\n                el = el[:-1]\n            if '_value' in el:\n                print(' None', end='')\n                for channel_number in self.channel_numbers:\n                    print(f\"  {0:7}  \", end='')\n                print('')\n            elif el == BMMuser.element or el == 'OCR':\n                if dcm.energy.position > edge:\n                    go_msg(f' {el:3} ', end='')\n                else:\n                    warning_msg(f' {el:3} ', end='') \n                for channel in self.iterate_channels():\n                    mcaroi = channel.get_mcaroi(mcaroi_number=r)\n                    val = mcaroi.total_rbv.get()\n                    if math.isnan(val):\n                        val = 0\n                    if dcm.energy.position > edge:\n                        go_msg(f\"  {int(val):7}  \", end='')\n                    else:\n                        warning_msg(f\"  {int(val):7}  \", end='')\n                        \n                print('')\n            else:                \n                print(f' {el:3} ', end='')\n\n                for channel in self.iterate_channels():\n                    mcaroi = channel.get_mcaroi(mcaroi_number=r)\n                    val = mcaroi.total_rbv.get()\n                    if math.isnan(val):\n                        val = 0\n                    print(f\"  {int(val):7}  \", end='')\n                print('')"
  },
  {
    "class_name": "Busy",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/busy.py",
    "source": "class Busy(Device):\n    \"\"\"\n    A \"busy\" device that takes a fixed amount of time in seconds to report complete.\n\n\n    \"\"\"\n\n    def set(self, delay):\n        return BusyStatus(self, delay, tick=max(1, min(0.1, delay / 100)))"
  },
  {
    "class_name": "Vacuum",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/utilities.py",
    "source": "class Vacuum(Device):\n    current  = Cpt(EpicsSignal, '-IP:1}I-I')\n    pressure = Cpt(EpicsSignal, '-CCG:1}P:Raw-I')\n\n    def _pressure(self):\n        #print(self.pressure.get())\n        #print(type(self.pressure.get()))\n        if self.connected is False:\n            return('[magenta]?????[/magenta]')\n        if self.pressure.get() == 'OFF':\n            return('[magenta]-1.1E-15[/magenta]')\n\n        if type(self.pressure.get()) is str and self.pressure.get() == 'LO<E-11':\n            return('[bold black]1.00e-11[/bold black]')\n        if float(self.pressure.get()) > 1e-6:\n            return('[bold red]' + str(self.pressure.get()) + '[/bold red]')\n        if float(self.pressure.get()) > 1e-8:\n            return('[bold yellow]' + str(self.pressure.get())  + '[/bold yellow]')\n        return(f'[white]{self.pressure.get()}[/white]')\n\n    def _current(self):\n        if self.connected is False:\n            return('[magenta]?????[/magenta]')\n        curr = float(self.current.get())\n        if curr > 2e-3:\n            out = '%.1f' % (1e3*curr)\n            return(f'[bold red]{out}[/bold red]')\n        if curr > 5e-4:\n            out = '%.1f' % (1e3*curr)\n            return(f'[bold yellow]{out}[/bold yellow]')\n        out = '%.1f' % (1e6*curr)\n        return(f'[white]{out}[/white]')"
  },
  {
    "class_name": "TCG",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/utilities.py",
    "source": "class TCG(Device):\n    pressure = Cpt(EpicsSignalRO, '-TCG:1}P:Raw-I')\n\n    def _pressure(self):\n        if self.connected is False:\n            return('[magenta]?????[/magenta]')\n        if self.pressure.get() == 'OFF':\n            return('[magenta]-1.1e-15[/magenta]')\n        if float(self.pressure.get()) > 1e-1:\n            return(f'[bold yellow]{self.pressure.get()}[/bold yellow]')\n        if float(self.pressure.get()) > 6e-3:\n            return(f'[bold red]{self.pressure.get()}[/bold red]')\n        return(f'[white]{self.pressure.get()}[/white]')"
  },
  {
    "class_name": "Rack",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/utilities.py",
    "source": "class Rack(Device):\n    temperature = Cpt(EpicsSignalRO, 'T-I')\n    def _state(self, info=False):\n        if self.connected is False:\n            return('[magenta]?????[/magenta]')\n        if self.temperature.get() == 'OFF':\n            return('[magenta]OFF[/magenta]')\n        if float(self.temperature.get()) > 26:\n            return(f'[bold yellow]{self.temperature.get()}[/bold yellow]')\n        if float(self.temperature.get()) > 30:\n            return(f'[bold red]{self.temperature.get()}[/bold red]')\n        return(f'[white]{self.temperature.get()}[/white]')"
  },
  {
    "class_name": "FEVac",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/utilities.py",
    "source": "class FEVac(Device):\n    #pressure = [None,\n    p1 = Cpt(EpicsSignal, 'CCG:1}P:Raw-I')\n    p2 = Cpt(EpicsSignal, 'CCG:2}P:Raw-I')\n    p3 = Cpt(EpicsSignal, 'CCG:3}P:Raw-I')\n    p4 = Cpt(EpicsSignal, 'CCG:4}P:Raw-I')\n    p5 = Cpt(EpicsSignal, 'CCG:5}P:Raw-I')\n    p6 = Cpt(EpicsSignal, 'CCG:6}P:Raw-I')\n    c1 = Cpt(EpicsSignal, 'IP:1}P-I')\n    c2 = Cpt(EpicsSignal, 'IP:2}P-I')\n    c3 = Cpt(EpicsSignal, 'IP:3}P-I')\n    c4 = Cpt(EpicsSignal, 'IP:4}P-I')\n    c5 = Cpt(EpicsSignal, 'IP:5}P-I')\n    c6 = Cpt(EpicsSignal, 'IP:6}P-I')\n               \n    def _pressure(self, num=None):\n        if self.connected is False:\n            return('[magenta]?????[/magenta]')\n        if num is None:\n            num = 1\n        if num < 1:\n            num = 1\n        if num > 6:\n            num = 6\n        sgnl = getattr(self, 'p'+str(num))\n        #print(self.pressure.get())\n        #print(type(self.pressure.get()))\n        if sgnl.get() == 'OFF':\n            return('[magenta]-1.1e-15[/magenta]')\n\n        if float(sgnl.get()) > 1e-6:\n            return(f'[bold red]{self.pressure.get()}[/bold red]')\n        if float(sgnl.get()) > 1e-8:\n            return(f'[bold yellow]{self.pressure.get()}[/bold yellow]')\n        return(f'[white]{sgnl.get()}[/white]')\n\n    def _current(self, num=None):\n        if self.connected is False:\n            return('[magenta]?????[/magenta]')\n        if num is None:\n            num = 1\n        if num < 1:\n            num = 1\n        if num > 6:\n            num = 6\n        sgnl = getattr(self, 'c'+str(num))\n        curr = float(sgnl.get())\n        if curr > 2e-3:\n            out = '%.1f' % (1e3*curr)\n            return(f'[bold red]{out}[/bold red]')\n        if curr > 5e-4:\n            out = '%.1f' % (1e3*curr)\n            return(f'[bold yellow]{out}[/bold yellow]')\n        out = '%.1f' % (1e6*curr)\n        return(f'[white]{out}[/white]')"
  },
  {
    "class_name": "GateValve",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/utilities.py",
    "source": "class GateValve(Device):\n    state = Cpt(EpicsSignal, 'Pos-Sts')\n    cls = Cpt(EpicsSignal, 'Cmd:Cls-Cmd')\n    opn = Cpt(EpicsSignal, 'Cmd:Opn-Cmd')\n    error = Cpt(EpicsSignal,'Err-Sts')\n    permit = Cpt(EpicsSignal, 'Permit:Enbl-Sts')\n    enabled = Cpt(EpicsSignal, 'Enbl-Sts')\n\n    def open_plan(self):\n        yield from mv(self.opn, 1)\n\n    def close_plan(self):\n        yield from mv(self.cls, 1)\n\n    def open(self):\n        print('Opening {}'.format(self.name))\n        self.opn.put(1)\n\n    def close(self):\n        print('Closing {}'.format(self.name))\n        self.cls.put(1)\n\n    def _state(self):\n        #if self.connected is False:\n        #    return disconnected_msg('?????')\n        if self.state.get() == 0:\n            return('[bold red]closed[/bold red]')\n        return('open  ')"
  },
  {
    "class_name": "Thermocouple",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/utilities.py",
    "source": "class Thermocouple(Device):\n    temperature = Cpt(EpicsSignal, '-I-I')\n    warning     = Cpt(EpicsSignal, '-I_High-RB')\n    alarm       = Cpt(EpicsSignal, '-I_HiHi-RB')\n\n    def _state(self, info=False):\n        t = \"%.1f\" % self.temperature.get()\n        if self.connected is False:\n            return('[magenta]?????[/magenta]')\n        if self.temperature.get() > self.alarm.get():\n            return(f'[bold red]{t}[/bold red]')\n        if self.temperature.get() > self.warning.get():\n            return(f'[bold yellow]{t}[/bold yellow]')\n        if info is True and self.temperature.get() > (0.5 * self.warning.get()):\n            return(f'[yellow]{t}[/yellow]')\n        return(f'[white]{t}[/white]')"
  },
  {
    "class_name": "OneWireTC",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/utilities.py",
    "source": "class OneWireTC(Device):\n    temperature = Cpt(EpicsSignal, '-I')\n    warning     = Cpt(EpicsSignal, ':Hi-SP')\n    alarm       = Cpt(EpicsSignal, '-I.HIHI')\n\n    def _state(self, info=False):\n        t = \"%.1f\" % self.temperature.get()\n        if self.temperature.get() > self.alarm.get():\n            return(f'[bold red]{t}[/bold red]')\n        if self.temperature.get() > self.warning.get():\n            return(f'[bold yellow]{t}[/bold yellow]')\n        if info is True and self.temperature.get() > (0.5 * self.warning.get()):\n            return(f'[yellow]{t}[/yellow]')\n        return(f'[white]{t}[/white]')"
  },
  {
    "class_name": "BMM_DIWater",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/utilities.py",
    "source": "class BMM_DIWater(Device):\n    dcm_flow = Cpt(EpicsSignal, 'F:2-I')\n    dm1_flow = Cpt(EpicsSignal, 'F:1-I')\n    return_pressure = Cpt(EpicsSignal, 'P:Return-I')\n    return_temperature = Cpt(EpicsSignal, 'T:Return-I')\n    supply_pressure = Cpt(EpicsSignal, 'P:Supply-I')\n    supply_temperature = Cpt(EpicsSignal, 'T:Supply-I')"
  },
  {
    "class_name": "USBVideo",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/video.py",
    "source": "class USBVideo(Device):\n    '''Simple class for recording videos via the USB cameras in the\n    hutch.\n\n      usbvideo1.record_video(name, time)\n\n    name is the file stub of the output video file, which will be\n    written into the video folder in the experiment folder and given a\n    .avi extension.  time is the length of the video.\n\n    This is a bit clunky, but it hides all of the interactions with\n    the computer vision plugin.\n\n    A bit more hands on:\n\n       usbvideo1.start()\n       (do some things for a while)\n       usbvideo1.stop()\n       usbvideo1.save_video(name)\n\n    where name is the same as above.\n\n    '''\n    visionfunction3 = Cpt(EpicsSignal, 'CompVisionFunction3')\n    _path = Cpt(EpicsSignal, 'FilePath')\n    enable = Cpt(EpicsSignal, 'EnableCallbacks')\n    framerate = Cpt(EpicsSignal, 'Input1')\n    startstop = Cpt(EpicsSignal, 'Input2')\n\n    # def __init__(self):\n    #     super().__init__(*args, **kwargs)\n    #     self.visionfunction3.put(4)\n    #     self.path.put('/nsls2/data3/bmm/assets/usbcam/')\n    #     self.enable.put(0)\n    #     self.framerate.put(60)\n    #     self.startstop.put(0)\n\n    @property\n    def path(self):\n        this = ''.join(chr(x) for x in self._path.read()['usbvideo1__path']['value'])\n        return this[:-1]\n    @path.setter\n    def path(self, value):\n        self._path.put(value)\n\n    def initialize(self):\n        self.enable.put(0)\n        self.visionfunction3.put(4)\n        self.framerate.put(60)\n        self.startstop.put(0)\n        \n    def start(self):\n        self.enable.put(1)\n        time.sleep(0.5)\n        self.startstop.put(1)\n\n    def stop(self):\n        self.startstop.put(0)\n        time.sleep(0.5)\n        self.enable.put(0)\n\n    def find_video(self):\n        list_of_files = glob.glob(f'{self.path}/*')\n        latest_file = max(list_of_files, key=os.path.getctime)\n        return latest_file\n\n    def save_video(self, name='video.avi'):\n        folder = os.path.join(user_ns['BMMuser'].folder, 'video')\n        if not os.path.isdir(folder):\n            os.makedirs(folder)\n        shutil.copyfile(os.path.join(self.path, self.find_video()),\n                        os.path.join(folder, name))\n        report(f'Wrote {os.path.join(folder, name)}', slack=True)\n        \n    def record_video(self, name='video.avi', time=5):\n        folder = os.path.join(user_ns['BMMuser'].folder, 'video')\n        if not name.endswith('.avi'):\n            name = name + '.avi'\n        if os.path.isfile(os.path.join(folder, name)):\n            print(f'There is already a file called {name} in your video folder.  Abandoning video.')\n            yield from null()\n            return()\n        action = input(f'\\nWrite a {time} second video to {os.path.join(folder, name)}? ' + PROMPT)\n        if action != '':\n            if action[0].lower() == 'n' or action[0].lower() == 'q':\n                print('Abandoning video...')\n                yield from null()\n                return\n        yield from mv(self.enable, 1)\n        yield from sleep(0.5)\n        yield from mv(self.startstop, 1)\n        yield from mv(user_ns['busy'], time)\n        yield from mv(self.startstop, 0)\n        yield from sleep(0.5)\n        yield from mv(self.enable, 0)\n        print('Waiting 3 seconds to finish writing the video file...')\n        yield from mv(user_ns['busy'], 3)\n        self.save_video(name)\n        print('Done!')"
  },
  {
    "class_name": "CameraSnapshot",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/bmm-profile-collection/startup/BMM/attic/webcam_device.py",
    "source": "class CameraSnapshot(Device):\n    image = Component(ExternalFileReference, value=\"\", kind=\"normal\", shape=[])\n    beamline_id = ''\n    annotation_string = ''\n    \n    \n    def __init__(self, *args, base, url, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._base = base\n        self._root = os.path.join(self._base, *self.today().split('-'))\n        self._acquiring_lock = threading.Lock()\n        self._counter = None  # set to an itertools.count object when staged\n        self._asset_docs_cache = []\n        self._url = url\n\n    def current_folder(self):\n        folder = os.path.join(self._base, *self.today().split('-'))\n        if not os.path.isdir(folder):\n            os.makedirs(folder)\n        return folder\n            \n    def stage(self):\n        self._rel_path_template = f\"{uuid.uuid4()}_%d.jpg\"\n        self._root = self.current_folder()\n        resource, self._datum_factory = resource_factory(\n            \"BEAMLINE_WEBCAM\", self._root, self._rel_path_template, {}, \"posix\")\n        self._asset_docs_cache.append(('resource', resource))\n        self._counter = itertools.count()\n        # Set the filepath\n        return super().stage()\n\n    def collect_asset_docs(self):\n        yield from self._asset_docs_cache\n        self._asset_docs_cache.clear()\n\n    def unstage(self):\n        self._counter = None\n        self._asset_docs_cache.clear()\n        return super().unstage()\n\n    def _capture(self, status, i):\n        \"This runs on a background thread.\"\n        try:\n            if not self._acquiring_lock.acquire(timeout=0):\n                raise RuntimeError(\"Cannot trigger, currently triggering!\")\n            filename = os.path.join(self._root, self._rel_path_template % i)\n            # Kick off requests, or subprocess, or whatever with the result\n            # that a file is saved at `filename`.\n\n            CAM_PROXIES = {\"http\": None, \"https\": None,}\n            r=requests.get(self._url, proxies=CAM_PROXIES)\n            im = Image.open(BytesIO(r.content))\n            im.save(filename, 'JPEG')\n            #print(f'w: {im.width}    h: {im.height}')\n            self.image.shape = (im.height, im.width, 3)\n\n            annotation = f'{self.beamline_id}      {self.annotation_string}       {self.now()}'\n            self.annotate_image(filename, annotation)\n\n            datum = self._datum_factory({\"index\": i})\n            self._asset_docs_cache.append(('datum', datum))\n            self.image.set(datum[\"datum_id\"]).wait()\n        except Exception as exc:\n            status.set_exception(exc)\n        else:\n            status.set_finished()\n        finally:\n            self._acquiring_lock.release()\n\n    def trigger(self):\n        status = DeviceStatus(self)\n        i = next(self._counter)\n        thread = threading.Thread(target=self._capture, args=(status, i))\n        thread.start()\n        return status\n\n    def now(self, fmt=\"%Y-%m-%dT%H-%M-%S\"):\n        return datetime.datetime.now().strftime(fmt)\n    def today(self, fmt=\"%Y-%m-%d-%H\"):\n        return datetime.datetime.today().strftime(fmt)\n\n    def annotate_image(self, imagefile, text):\n        bluesky_path_as_list = bluesky.__path__[0].split('/') # crude, but finds current collection folder\n        font_path = os.path.join('/', *bluesky_path_as_list[:4], 'lib', 'python3.7', 'site-packages', 'matplotlib', 'mpl-data', 'fonts', 'ttf')\n        img = Image.open(imagefile)\n        width, height = img.size\n        draw = ImageDraw.Draw(img, 'RGBA')\n        draw.rectangle(((0, int(9.5*height/10)), (width, height)), fill=(255,255,255,125))\n        font = ImageFont.truetype(font_path + '/DejaVuSans.ttf', 24)\n        draw.text((int(0.2*width/10), int(9.6*height/10)), text, (0,0,0), font=font)\n        img.save(imagefile)"
  },
  {
    "class_name": "HxnFastShutter",
    "bases": [
      "HxnModalBase",
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/12-endstation.py",
    "source": "class HxnFastShutter(HxnModalBase, Device):\n    request_open = Cpt(EpicsSignal, '')\n\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix, **kwargs)\n        self.stage_sigs[self.request_open] = 1\n        self.mode_settings.triggers.put([])\n\n    def stage(self):\n        print('** Opening fast shutter **')\n        super().stage()\n\n    def unstage(self):\n        print('** Closing fast shutter **')\n        super().unstage()"
  },
  {
    "class_name": "HxnSlowShutter",
    "bases": [
      "HxnModalBase",
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/12-endstation.py",
    "source": "class HxnSlowShutter(HxnModalBase, Device):\n    opn = Cpt(EpicsSignal, ':Opn-Cmd')\n    cls = Cpt(EpicsSignal, ':Cls-Cmd')\n\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix, **kwargs)\n\n    def stage(self):\n        self.opn.put(1)\n        time.sleep(2)\n\n    def unstage(self):\n        self.cls.put(1)\n        time.sleep(2)"
  },
  {
    "class_name": "HxnAnc350_3",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/13-mll.py",
    "source": "class HxnAnc350_3(Device):\n    '''3 axis ANC350'''\n    ax0 = Cpt(EpicsMotor, '-Ax:0}Mtr')\n    ax1 = Cpt(EpicsMotor, '-Ax:1}Mtr')\n    ax2 = Cpt(EpicsMotor, '-Ax:2}Mtr')"
  },
  {
    "class_name": "HxnAnc350_4",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/13-mll.py",
    "source": "class HxnAnc350_4(Device):\n    '''4 axis ANC350'''\n    ax0 = Cpt(EpicsMotor, '-Ax:0}Mtr')\n    ax1 = Cpt(EpicsMotor, '-Ax:1}Mtr')\n    ax2 = Cpt(EpicsMotor, '-Ax:2}Mtr')\n    ax3 = Cpt(EpicsMotor, '-Ax:3}Mtr')"
  },
  {
    "class_name": "HxnAnc350_6",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/13-mll.py",
    "source": "class HxnAnc350_6(Device):\n    '''6 axis ANC350'''\n    ax0 = Cpt(EpicsMotor, '-Ax:0}Mtr')\n    ax1 = Cpt(EpicsMotor, '-Ax:1}Mtr')\n    ax2 = Cpt(EpicsMotor, '-Ax:2}Mtr')\n    ax3 = Cpt(EpicsMotor, '-Ax:3}Mtr')\n    ax4 = Cpt(EpicsMotor, '-Ax:4}Mtr')\n    ax5 = Cpt(EpicsMotor, '-Ax:5}Mtr')"
  },
  {
    "class_name": "HXN_FuncGen1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/68-nano-functions.py",
    "source": "class HXN_FuncGen1(Device):\n    freq = Cpt(EpicsSignal, '{FG:1}OUTPUT1:FREQ:SP') #freq.set('#.##'){.wait()}\n    freq_readout = Cpt(EpicsSignal, '{FG:1}OUTPUT1:FREQ') #freq.set('#.##'){.wait()}\n    volt = Cpt(EpicsSignal, '{FG:1}OUTPUT1:VOLT:SP')\n    volt_readout = Cpt(EpicsSignal, '{FG:1}OUTPUT1:VOLT')\n    offset = Cpt(EpicsSignal, '{FG:1}OUTPUT1:VOLT:OFFSET:SP')\n    sym = Cpt(EpicsSignal, '{FG:1}OUTPUT1:RAMP:SYMM:SP')\n    func = Cpt(EpicsSignal, '{FG:1}OUTPUT1:FUNC:SP')\n    burst_count = Cpt(EpicsSignal, '{FG:1}OUTPUT1:BURST_NCYCLES:SP')\n    burst = Cpt(EpicsSignal, '{FG:1}OUTPUT1:BURST_STATUS:SP')\n    output = Cpt(EpicsSignal, '{FG:1}OUTPUT1:STATUS:SP') #output.set('ON'){.wait()}\n    output_readout = Cpt(EpicsSignal, '{FG:1}OUTPUT1:STATUS') #output.set('ON'){.wait()}\n    trig = Cpt(EpicsSignal, '{FG:1}TRIGGER') #output.set('ON'){.wait()}\n    \n    #slt_hcen = Cpt(EpicsMotor, '{Slt:4-Ax:Top}Mtr')\n\n    def on(self):\n        yield from abs_set(self.output,\"ON\",wait=True)\n        yield from bps.sleep(0.5)\n\n    def off(self):\n        yield from abs_set(self.output,\"OFF\",wait=True)\n        yield from bps.sleep(0.5)"
  },
  {
    "class_name": "HXN_FuncGen2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/68-nano-functions.py",
    "source": "class HXN_FuncGen2(Device):\n    freq = Cpt(EpicsSignal, '{FG:1}OUTPUT2:FREQ:SP') #freq.set('#.##'){.wait()}\n    freq_readout = Cpt(EpicsSignal, '{FG:1}OUTPUT2:FREQ') #freq.set('#.##'){.wait()}\n    volt = Cpt(EpicsSignal, '{FG:1}OUTPUT2:VOLT:SP')\n    volt_readout = Cpt(EpicsSignal, '{FG:1}OUTPUT2:VOLT')\n    offset = Cpt(EpicsSignal, '{FG:1}OUTPUT2:VOLT:OFFSET:SP')\n    sym = Cpt(EpicsSignal, '{FG:1}OUTPUT2:RAMP:SYMM:SP')\n    func = Cpt(EpicsSignal, '{FG:1}OUTPUT2:FUNC:SP')\n    burst_count = Cpt(EpicsSignal, '{FG:1}OUTPUT2:BURST_NCYCLES:SP')\n    burst = Cpt(EpicsSignal, '{FG:1}OUTPUT2:BURST_STATUS:SP')\n    output = Cpt(EpicsSignal, '{FG:1}OUTPUT2:STATUS:SP') #output.set('ON'){.wait()}\n    output_readout = Cpt(EpicsSignal, '{FG:1}OUTPUT2:STATUS') #output.set('ON'){.wait()}\n    #slt_hcen = Cpt(EpicsMotor, '{Slt:4-Ax:Top}Mtr')\n\n    def on(self):\n        yield from abs_set(self.output,\"ON\",wait=True)\n        yield from bps.sleep(0.5)\n\n    def off(self):\n        yield from abs_set(self.output,\"OFF\",wait=True)\n        yield from bps.sleep(0.5)"
  },
  {
    "class_name": "SRXFlyer2D",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/69-nano-fly2d.py",
    "source": "class SRXFlyer2D(Device):\n    \"\"\"\n    This is the Zebra.\n    \"\"\"\n    LARGE_FILE_DIRECTORY_WRITE_PATH = LARGE_FILE_DIRECTORY_PATH\n    LARGE_FILE_DIRECTORY_READ_PATH = LARGE_FILE_DIRECTORY_PATH\n    LARGE_FILE_DIRECTORY_ROOT = LARGE_FILE_DIRECTORY_ROOT\n    KNOWN_DETS = {\"xs\", \"xs2\", \"merlin2\", \"eiger2\", \"dexela\", \"eiger_mobile\"}\n    fast_axis = Cpt(Signal, value=\"HOR\", kind=\"config\")\n    slow_axis = Cpt(Signal, value=\"VER\", kind=\"config\")\n\n    @property\n    def encoder(self):\n        return self._encoder\n\n    @property\n    def detectors(self):\n        return tuple(self._dets)\n\n    @detectors.setter\n    def detectors(self, value):\n        dets = tuple(value)\n        if not all(d.name in self.KNOWN_DETS for d in dets):\n            raise ValueError(\n                f\"One or more of {[d.name for d in dets]}\"\n                f\"is not known to the zebra. \"\n                f\"The known detectors are {self.KNOWN_DETS})\"\n            )\n        self._dets = dets\n\n    @property\n    def sclr(self):\n        return self._sis\n\n    def __init__(self, dets, sclr, zebra, *, reg=db.reg, **kwargs):\n        super().__init__(\"\", parent=None, **kwargs)\n        self._mode = \"idle\"\n        self._dets = dets\n        self._sis = sclr\n        self._filestore_resource = None\n        self._encoder = zebra\n\n        self.fast_axis.put('NANO2D')\n        self.slow_axis.put('NANO2D')\n\n        # self._encoder.pc.block_state_reset.put(1)\n        self.reg = reg\n        self._document_cache = []\n        self._last_bulk = None\n\n        self._point_counter = None\n        self.frame_per_point = None\n\n        self._data_exporter = ExportNanoZebraData()\n        if self._sis is not None:\n            self._data_sis_exporter = ExportSISData()\n\n    def _select_captured_data(self):\n        \"\"\"\n        Select the data to be captured by Zebra. Capturing unnecessary data slows down\n        the scans, so only necessary sources should be selected. Setting the respective\n        PVs can not be done in a fast sequence (technically setting PV is fast, but Zebra\n        parameters remain unchanged unless there is a pause after writing to each PV),\n        so the configuration can not be performed using 'stage_sigs'.\n        \"\"\"\n        dir = self.fast_axis.get()\n\n        sigs = {_: 0 for _ in [\n            self._encoder.pc.data.cap_enc1_bool,\n            self._encoder.pc.data.cap_enc2_bool,\n            self._encoder.pc.data.cap_enc3_bool,\n            self._encoder.pc.data.cap_enc4_bool,\n            self._encoder.pc.data.cap_filt1_bool,\n            self._encoder.pc.data.cap_filt2_bool,\n            self._encoder.pc.data.cap_div1_bool,\n            self._encoder.pc.data.cap_div2_bool,\n            self._encoder.pc.data.cap_div3_bool,\n            self._encoder.pc.data.cap_div4_bool\n        ]}\n\n        if dir == \"NANO2D\":\n            sigs[self._encoder.pc.data.cap_enc1_bool] = True\n            sigs[self._encoder.pc.data.cap_enc2_bool] = True\n        elif dir == \"NANOHOR\":\n            sigs[self._encoder.pc.data.cap_enc1_bool] = bool(load_positions_from_zebra)\n        elif dir == \"NANOVER\":\n            sigs[self._encoder.pc.data.cap_enc2_bool] = bool(load_positions_from_zebra)\n        elif dir == \"NANOZ\":\n            sigs[self._encoder.pc.data.cap_enc3_bool] = bool(load_positions_from_zebra)\n        else:\n            raise ValueError(f\"Unknown value: dir={dir!r}\")\n\n        # Change the PV values only if the new values is different from the current values.\n        for sig, value in sigs.items():\n            current_value = sig.get()\n            if current_value != value:\n                sig.set(value).wait()\n                ttime.sleep(0.2)  # Determined experimentally\n\n    def stage(self):\n        self._point_counter = 0\n        dir = self.fast_axis.get()\n\n        self._select_captured_data()\n\n        # # Gating info for encoder capture\n        self.stage_sigs[self._encoder.pc.gate_num] = 1\n        self.stage_sigs[self._encoder.pc.pulse_start] = 0\n\n        # This is for the merlin\n        self.stage_sigs[self._encoder.output1.ttl.addr] = 31\n\n        # Scaler\n        self.stage_sigs[self._encoder.output2.ttl.addr] = 31\n        self.stage_sigs[self._encoder.output3.ttl.addr] = 31\n\n        self.stage_sigs[self._encoder.pc.gate_source] = \"Position\"\n        self.stage_sigs[self._encoder.pc.pulse_source] = \"Time\"\n\n        if self._sis is not None:\n            # Put SIS3820 into single count (not autocount) mode\n            self.stage_sigs[self._sis.count_mode] = 0\n            self.stage_sigs[self._sis.count_on_start] = 1\n            # Stop the SIS3820\n            self._sis.stop_all.put(1)\n\n        if dir == \"NANOHOR\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc1\"\n            # self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n            # self.stage_sigs[self._encoder.pc.enc_res2] = 9.5368e-05\n        elif dir == \"NANOVER\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc2\"\n            # self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n            # self.stage_sigs[self._encoder.pc.enc_res2] = 9.5368e-05\n        elif dir == \"NANOZ\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc3\"\n            # self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n            # self.stage_sigs[self._encoder.pc.enc_res2] = 9.5368e-05\n        elif dir == \"NANO2D\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc2\"\n            # self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n            # self.stage_sigs[self._encoder.pc.enc_res2] = 9.5368e-05\n        else:\n            raise ValueError(f\"Unknown value: dir={dir!r}\")\n\n        # print(f\"stage_sigs={self.stage_sigs}\") ##\n\n        self.__filename = \"{}.h5\".format(uuid.uuid4())\n        self.__filename_sis = \"{}.h5\".format(uuid.uuid4())\n        self.__read_filepath = os.path.join(\n            self.LARGE_FILE_DIRECTORY_READ_PATH, self.__filename\n        )\n        self.__read_filepath_sis = os.path.join(\n            self.LARGE_FILE_DIRECTORY_READ_PATH, self.__filename_sis\n        )\n        self.__write_filepath = os.path.join(\n            self.LARGE_FILE_DIRECTORY_WRITE_PATH, self.__filename\n        )\n        self.__write_filepath_sis = os.path.join(\n            self.LARGE_FILE_DIRECTORY_WRITE_PATH, self.__filename_sis\n        )\n\n        self.__filestore_resource, self._datum_factory_z = resource_factory(\n            ZebraHDF5Handler.HANDLER_NAME,\n            root=self.LARGE_FILE_DIRECTORY_ROOT,\n            resource_path=self.__read_filepath,\n            resource_kwargs={\"frame_per_point\": self.frame_per_point},\n            path_semantics=\"posix\",\n        )\n        self.__filestore_resource_sis, self._datum_factory_sis = resource_factory(\n            SISHDF5Handler.HANDLER_NAME,\n            root=self.LARGE_FILE_DIRECTORY_ROOT,\n            resource_path=self.__read_filepath_sis,\n            resource_kwargs={\"frame_per_point\": self.frame_per_point},\n            path_semantics=\"posix\",\n        )\n\n        resources = [self.__filestore_resource]\n        if self._sis:\n            resources.append(self.__filestore_resource_sis)\n        self._document_cache.extend((\"resource\", _) for _ in resources)\n\n        self._data_exporter.open(self.__write_filepath)\n        if self._sis is not None:\n            sis_mca_names = self._sis_mca_names()\n            self._data_sis_exporter.open(\n                self.__write_filepath_sis, mca_names=sis_mca_names, ion=self._sis, zebra=self._encoder\n            )\n\n        super().stage()\n\n    def unstage(self):\n        self._point_counter = None\n        self._data_exporter.close()\n        if self._sis is not None:\n            self._data_sis_exporter.close()\n        super().unstage()\n\n    def describe_collect(self):\n\n        ext_spec = \"FileStore:\"\n\n        spec = {\n            \"external\": ext_spec,\n            \"dtype\": \"array\",\n            \"shape\": [self._npts],\n            \"source\": \"\",  # make this the PV of the array the det is writing\n        }\n\n        desc = OrderedDict()\n        for chan in (\"time\", \"enc1\", \"enc2\", \"enc3\"):\n            desc[chan] = spec\n            desc[chan][\"source\"] = getattr(self._encoder.pc.data, chan).pvname\n\n        # Handle the detectors we are going to get\n        for d in self._dets:\n            desc.update(d.describe())\n\n        # Handle the ion chamber that the zebra is collecting\n        if self._sis is not None:\n            sis_mca_names = self._sis_mca_names()\n            for n, name in enumerate(sis_mca_names):\n                desc[name] = spec\n                desc[name][\"source\"] = self._sis.mca_by_index[n + 1].spectrum.pvname\n\n        return {\"primary\": desc}\n\n    def kickoff(self, *, ystart, ystop, num, dwell, delta = 0.1, pulse_dur):\n        # print(f\"Kickoff: xstart={xstart} xtop={xstop} dwell={dwell}\")\n\n        self._data_exporter.set_fixed_positions()\n        self._data_exporter.set_fast_axis_parameters(fast_start=ystart, fast_stop=ystop, fast_n=num)\n\n        dets_by_name = {d.name: d for d in self.detectors}\n\n        self._encoder.pc.arm.put(0)\n        self._mode = \"kicked off\"\n        self._npts = int(num)\n        if ystart < ystop:\n            direction = 1\n        else:\n            direction = -1\n        # pxsize = np.abs(ystop - ystart) / (num - 1)\n        extent = np.abs(ystop - ystart)\n        # 2 ms delay between pulses\n        # decrement = (pxsize / dwell) * 0.0005\n        # decrement = max(decrement, 1e-5)\n\n        self._encoder.pc.dir.put((-direction/2)+0.5)\n\n        # print(f\"gate_start={xstart - direction * (pxsize/2)}\")\n        # print(f\"extent={extent}\")\n        self._encoder.pc.gate_start.put(ystart)\n        self._encoder.pc.gate_step.put(extent + delta*0.5)\n        self._encoder.pc.gate_width.put(extent + delta*0.3)\n\n        self._encoder.pc.pulse_start.put(0.0)\n        self._encoder.pc.pulse_max.put(num)\n        self._encoder.pc.pulse_width.put(dwell*pulse_dur)\n        self._encoder.pc.pulse_step.put(dwell)\n        self._encoder.pc.pulse_delay.put(dwell*pulse_dur*0.5)\n        # self._encoder.pc.pulse_width.put(pxsize * 0.2)\n\n        # # self._encoder.pc.pulse_width.put(pxsize - decrement)\n        # # If decrement is too small, then zebra will not send individual pulses\n        # # but integrate over the entire line\n        # # Hopefully taken care of with decrement check above\n\n        # The case when Merlin is configured to work in 'Trigger Enable' trigger mode.\n        # The numbers are picked using trial and error method and work for dwell time\n        #   up to 0.004 s (250 Hz acquistion rate).\n        # velocity = pxsize / dwell\n\n        # if any([(\"merlin\" in _) for _ in dets_by_name]):\n        #     x_debounce = 0.0025 * velocity  # The true debounce time is 0.0016392 s\n        # else:\n        #     x_debounce = 0\n\n        # pulse_width = pxsize * 0.9 - x_debounce\n\n        # if pulse_width < 0:\n        #     raise Exception(f\"Dwell time is too small ...\")\n        # self._encoder.pc.pulse_width.put(pulse_width)\n\n        # Arm the zebra\n        self._encoder.pc.arm.put(1)\n\n        # TODO Return a status object *first* and do the above asynchronously.\n        return NullStatus()\n\n    def _sis_mca_names(self):\n        n_mcas = n_scaler_mca\n        return [getattr(self._sis.channels, f\"chan{_}\").name for _ in range(1, n_mcas + 1)]\n\n    def complete(self):\n        \"\"\"\n        Call this when all needed data has been collected. This has no idea\n        whether that is true, so it will obligingly stop immediately. It is\n        up to the caller to ensure that the motion is actually complete.\n        \"\"\"\n\n        amk_debug_flag = False\n\n        # print(f\"Complete 1\")\n        # Our acquisition complete PV is: XF:05IDD-ES:1{Dev:Zebra1}:ARRAY_ACQ\n        while self._encoder.pc.data_in_progress.get() == 1:\n            time.sleep(0.01)\n        # print(f\"Complete 2\")\n        # ttime.sleep(.1)\n        self._mode = \"complete\"\n        self._encoder.pc.block_state_reset.put(1)\n        # see triggering errors of the xspress3 on suspension.  This is\n        # to test the reset of the xspress3 after a line.\n\n        # print(f\"Complete 3\")\n\n        for d in self._dets:\n            d.stop(success=True)\n\n        # print(f\"Complete 4\")\n\n        time_datum = self._datum_factory_z({\"column\": \"time\", \"point_number\": self._point_counter})\n        enc1_datum = self._datum_factory_z({\"column\": \"enc1\", \"point_number\": self._point_counter})\n        enc2_datum = self._datum_factory_z({\"column\": \"enc2\", \"point_number\": self._point_counter})\n        enc3_datum = self._datum_factory_z({\"column\": \"enc3\", \"point_number\": self._point_counter})\n        if self._sis:\n            sis_mca_names = self._sis_mca_names()\n            sis_datum = []\n            for name in sis_mca_names:\n                sis_datum.append(self._datum_factory_sis({\"column\": name, \"point_number\": self._point_counter}))\n\n        self._document_cache.extend(\n            (\"datum\", d)\n            for d in (\n                time_datum,\n                enc1_datum,\n                enc2_datum,\n                enc3_datum,\n            )\n        )\n\n        if self._sis:\n            self._document_cache.extend((\"datum\", d) for d in sis_datum)\n\n        # grab the asset documents from all of the child detectors\n        for d in self._dets:\n            self._document_cache.extend(d.collect_asset_docs())\n\n        # Write the file.\n        # @timer_wrapper\n        def get_zebra_data():\n            self._data_exporter.export(self._encoder, self.fast_axis.get())\n\n        if amk_debug_flag:\n            t_getzebradata = tic()\n        get_zebra_data()\n        if amk_debug_flag:\n            toc(t_getzebradata, str='Get Zebra data')\n\n        # @timer_wrapper\n        def get_sis_data():\n            if self._sis is None:\n                return\n            self._data_sis_exporter.export()\n\n            # export_sis_data(\n            #     self._sis, sis_mca_names, self.__write_filepath_sis, self._encoder\n            # )\n\n        if amk_debug_flag:\n            t_sisdata = tic()\n        get_sis_data()\n        if amk_debug_flag:\n            toc(t_sisdata, str='Get SIS data')\n\n        # Yield a (partial) Event document. The RunEngine will put this\n        # into metadatastore, as it does all readings.\n        self._last_bulk = {\n            \"time\": ttime.time(),\n            \"seq_num\": 1,\n            \"data\": {\n                \"time\": time_datum[\"datum_id\"],\n                \"enc1\": enc1_datum[\"datum_id\"],\n                \"enc2\": enc2_datum[\"datum_id\"],\n                \"enc3\": enc3_datum[\"datum_id\"],\n            },\n            \"timestamps\": {\n                \"time\": time_datum[\"datum_id\"],  # not a typo#\n                \"enc1\": time_datum[\"datum_id\"],\n                \"enc2\": time_datum[\"datum_id\"],\n                \"enc3\": time_datum[\"datum_id\"],\n            },\n        }\n        if self._sis:\n            self._last_bulk[\"data\"].update({k: v[\"datum_id\"] for k, v in zip(sis_mca_names, sis_datum)})\n            self._last_bulk[\"timestamps\"].update({k: v[\"datum_id\"] for k, v in zip(sis_mca_names, sis_datum)})\n        for d in self._dets:\n            reading = d.read()\n            self._last_bulk[\"data\"].update(\n                {k: v[\"value\"] for k, v in reading.items()}\n                )\n            self._last_bulk[\"timestamps\"].update(\n                {k: v[\"timestamp\"] for k, v in reading.items()}\n            )\n\n        return NullStatus()\n\n    def collect(self):\n        # Create records in the FileStore database.\n        # move this to stage because I thinkt hat describe_collect needs the\n        # resource id\n        # TODO use ophyd.areadectector.filestoer_mixins.resllource_factory here\n        if self._last_bulk is None:\n            raise Exception(\n                \"the order of complete and collect is brittle and out \"\n                \"of sync. This device relies on in-order and 1:1 calls \"\n                \"between complete and collect to correctly create and stash \"\n                \"the asset registry documents\"\n            )\n        yield self._last_bulk\n        self._point_counter += 1\n        self._last_bulk = None\n        self._mode = \"idle\"\n\n    def collect_asset_docs(self):\n        yield from iter(list(self._document_cache))\n        self._document_cache.clear()\n\n    def stop(self):\n        self._encoder.pc.block_state_reset.put(1)\n        pass\n\n    def pause(self):\n        \"Pausing in the middle of a kickoff nukes the partial dataset.\"\n        self._encoder.pc.block_state_reset.put(1)\n        if self._sis is not None:\n            self._sis.stop_all.put(1)\n        for d in self._dets:\n            if hasattr(d, \"settings\"):\n                d.settings.acquire.put(0)\n            if hasattr(d, \"cam\"):\n                d.cam.acquire.put(0)\n        self._mode = \"idle\"\n        self.unstage()\n\n    def resume(self):\n        self.unstage()\n        self.stage()"
  },
  {
    "class_name": "BeamlineStatus",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/10-optics.py",
    "source": "class BeamlineStatus(Device):\n    shutter_status = Cpt(EpicsSignalRO, 'SR-EPS{PLC:1}Sts:MstrSh-Sts')\n    beam_current = Cpt(EpicsSignalRO, 'SR:C03-BI{DCCT:1}I:Real-I')\n    beamline_enabled = Cpt(EpicsSignalRO,\n                           'SR:C03-EPS{PLC:1}Sts:ID_BE_Enbl-Sts')\n    cryo_filling = Cpt(EpicsSignalRO,\n                           'XF:03IDA-OP{CC:1}V3_STS')"
  },
  {
    "class_name": "HxnSlitA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/10-optics.py",
    "source": "class HxnSlitA(Device):\n    '''HXN slit device, with top/bottom/inboard/outboard'''\n    bot = Cpt(EpicsMotor, '-Ax:Btm}Mtr')\n    top = Cpt(EpicsMotor, '-Ax:Top}Mtr')\n    inb = Cpt(EpicsMotor, '-Ax:Inb}Mtr')\n    outb = Cpt(EpicsMotor, '-Ax:Outb}Mtr')"
  },
  {
    "class_name": "HxnI400",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/10-optics.py",
    "source": "class HxnI400(Device):\n    '''HXN I400 BPM current readout'''\n    # raw currents\n    i_top = Cpt(EpicsSignalRO, 'I:Raw1-I')\n    i_bottom = Cpt(EpicsSignalRO, 'I:Raw2-I')\n    i_right = Cpt(EpicsSignalRO, 'I:Raw3-I')\n    i_left = Cpt(EpicsSignalRO, 'I:Raw4-I')\n\n    # x/y position\n    x = Cpt(EpicsSignalRO, 'PosX-I')\n    y = Cpt(EpicsSignalRO, 'PosY-I')"
  },
  {
    "class_name": "SigrayMll",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/16-ptycho.py",
    "source": "class SigrayMll(Device):\n    mll_x = Cpt(EpicsMotor, 'XF:03IDC-CT{SmarAct:Sigray1}:m10')\n    mll_y = Cpt(EpicsMotor, 'XF:03IDC-CT{SmarAct:Sigray1}:m11')\n    mll_z = Cpt(EpicsMotor, 'XF:03IDC-CT{SmarAct:Sigray1}:m12')\n    mll_ry = Cpt(EpicsMotor,'XF:03IDC-CT{SmarAct:Sigray1}:m13')\n    mll_rx = Cpt(EpicsMotor, 'XF:03IDC-CT{SmarAct:Sigray1}:m14')"
  },
  {
    "class_name": "HxnPrototypeMicroscope",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/16-ptycho.py",
    "source": "class HxnPrototypeMicroscope(Device):\n    vx = Cpt(EpicsMotor, 'XF:03IDC-ES{Proto:1-Ax:1}Mtr')\n    vy = Cpt(EpicsMotor, 'XF:03IDC-ES{Proto:1-Ax:2}Mtr')\n    vz = Cpt(EpicsMotor, 'XF:03IDC-ES{MC:4-Ax:8}Mtr')\n\n    v_rz = Cpt(EpicsMotor, 'XF:03IDC-ES{Proto:1-Ax:3}Mtr')\n    v_rx = Cpt(EpicsMotor, 'XF:03IDC-ES{Proto:1-Ax:4}Mtr')\n    #v_ry = Cpt(EpicsMotor, 'XF:03IDC-ES{MCS:4-Ax:1}Mtr')\n\n    osa_rz = Cpt(EpicsMotor, 'XF:03IDC-ES{Proto:1-Ax:5}Mtr')\n    osa_ry = Cpt(EpicsMotor,'XF:03IDC-ES{MC:4-Ax:1}Mtr')\n    osay = Cpt(EpicsMotor, 'XF:03IDC-ES{Proto:1-Ax:6}Mtr')\n    osax = Cpt(EpicsMotor, 'XF:03IDC-ES{Proto:1-Ax:7}Mtr')\n    osaz = Cpt(EpicsMotor, 'XF:03IDC-ES{Proto:1-Ax:8}Mtr')"
  },
  {
    "class_name": "HxnPrototypeSample",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/16-ptycho.py",
    "source": "class HxnPrototypeSample(Device):\n    sbx = Cpt(EpicsMotor, 'XF:03IDC-ES{ANC350:9-Ax:3}Mtr')\n    sby = Cpt(EpicsMotor, 'XF:03IDC-ES{ANC350:9-Ax:2}Mtr')\n    sbz = Cpt(EpicsMotor, 'XF:03IDC-ES{ANC350:9-Ax:1}Mtr')"
  },
  {
    "class_name": "HxnPrototypePhasePlate",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/16-ptycho.py",
    "source": "class HxnPrototypePhasePlate(Device):\n    pp_x = Cpt(EpicsMotor, 'XF:03IDC-ES{PPlate:X}Mtr')\n    pp_y = Cpt(EpicsMotor, 'XF:03IDC-ES{PPlate:Y}Mtr')"
  },
  {
    "class_name": "HxnLakeShore",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/20-detectors.py",
    "source": "class HxnLakeShore(Device):\n    ch_a = Cpt(EpicsSignalRO, '-Ch:A}C:T-I')\n    ch_b = Cpt(EpicsSignalRO, '-Ch:B}C:T-I')\n    ch_c = Cpt(EpicsSignalRO, '-Ch:C}C:T-I')\n    ch_d = Cpt(EpicsSignalRO, '-Ch:D}C:T-I')\n\n    def set_names(self, cha, chb, chc, chd):\n        '''Set names of all channels\n\n        Returns channel signals\n        '''\n        self.ch_a.name = cha\n        self.ch_b.name = chb\n        self.ch_c.name = chc\n        self.ch_d.name = chd\n        return self.ch_a, self.ch_b, self.ch_c, self.ch_d"
  },
  {
    "class_name": "HxnBpm",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/20-detectors.py",
    "source": "class HxnBpm(Device):\n    x = Cpt(EpicsSignalRO, 'Pos:X-I')\n    y = Cpt(EpicsSignalRO, 'Pos:Y-I')"
  },
  {
    "class_name": "HXN_NanoStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/61-nano-es.py",
    "source": "class HXN_NanoStage(Device):\n    ssx = Cpt(EpicsMotor, '{PT:Smpl-Ax:ssx}Mtr')  # Scanning piezo X\n    ssy = Cpt(EpicsMotor, '{PT:Smpl-Ax:ssy}Mtr')\n    ssz = Cpt(EpicsMotor, '{PT:Smpl-Ax:ssz}Mtr')\n    th = Cpt(EpicsMotor, '{PT:Smpl-Ax:th}Mtr')\n    cx = Cpt(EpicsMotor, '{PT:Smpl-Ax:cx}Mtr')\n    cz = Cpt(EpicsMotor, '{PT:Smpl-Ax:cz}Mtr')\n\n    bs_x = Cpt(EpicsMotor, '{PT:BS-Ax:X}Mtr')\n    bs_y = Cpt(EpicsMotor, '{PT:BS-Ax:Y}Mtr')\n    bs_z = Cpt(EpicsMotor, '{PT:BS-Ax:Z}Mtr')\n    bs_rz = Cpt(EpicsMotor, '{PT:BS-Ax:rz}Mtr')\n\n    hm_x = Cpt(EpicsMotor, '{PT:HM-Ax:X}Mtr')\n    hm_y = Cpt(EpicsMotor, '{PT:HM-Ax:Y}Mtr')\n    hm_z = Cpt(EpicsMotor, '{PT:HM-Ax:Z}Mtr')\n    hm_ry = Cpt(EpicsMotor, '{PT:HM-Ax:ry}Mtr')\n\n    zp_x = Cpt(EpicsMotor, '{PT:OP-Ax:X}Mtr')\n    zp_y = Cpt(EpicsMotor, '{PT:OP-Ax:Y}Mtr')\n    zp_z = Cpt(EpicsMotor, '{PT:OP-Ax:Z}Mtr')\n    zp_rx = Cpt(EpicsMotor, '{PT:OP-Ax:rx}Mtr')\n    zp_ry = Cpt(EpicsMotor, '{PT:OP-Ax:ry}Mtr')\n\n    osa_x = Cpt(EpicsMotor, '{PT:OSA-Ax:X}Mtr')\n    osa_y = Cpt(EpicsMotor, '{PT:OSA-Ax:Y}Mtr')\n    osa_z = Cpt(EpicsMotor, '{PT:OSA-Ax:Z}Mtr')\n\n    sb_x = Cpt(EpicsMotor, '{PT:SmplBase-Ax:X}Mtr')\n    sb_y = Cpt(EpicsMotor, '{PT:SmplBase-Ax:Y}Mtr')\n    sb_z = Cpt(EpicsMotor, '{PT:SmplBase-Ax:Z}Mtr')\n\n    vm_x = Cpt(EpicsMotor, '{PT:VM-Ax:X}Mtr')\n    vm_y = Cpt(EpicsMotor, '{PT:VM-Ax:Y}Mtr')\n    vm_z = Cpt(EpicsMotor, '{PT:VM-Ax:Z}Mtr')\n    vm_rx = Cpt(EpicsMotor, '{PT:VM-Ax:rx}Mtr')\n    vm_rz = Cpt(EpicsMotor, '{PT:VM-Ax:rz}Mtr')\n\n    slt_vgap = Cpt(EpicsMotor, '{Slt:4-Ax:X}Mtr')\n    slt_vcen = Cpt(EpicsMotor, '{Slt:4-Ax:Y}Mtr')\n    slt_hgap = Cpt(EpicsMotor, '{Slt:4-Ax:Z}Mtr')\n    slt_hcen = Cpt(EpicsMotor, '{Slt:4-Ax:Top}Mtr')\n\n    p1_pos0 = Cpt(EpicsSignalRO, '{Pico:1}POS_0')\n    p1_pos1 = Cpt(EpicsSignalRO, '{Pico:1}POS_1')\n    p1_pos2 = Cpt(EpicsSignalRO, '{Pico:1}POS_2')"
  },
  {
    "class_name": "HxnFPSensor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/23-interferometers.py",
    "source": "class HxnFPSensor(Device):\n    ch0 = Cpt(EpicsSignalRO, '-Chan0}Pos-I')\n    ch1 = Cpt(EpicsSignalRO, '-Chan1}Pos-I')\n    ch2 = Cpt(EpicsSignalRO, '-Chan2}Pos-I')\n\n    def set_names(self, ch0, ch1, ch2):\n        '''Set names of all channels\n\n        Returns channel signals\n        '''\n        self.ch0.name = ch0\n        self.ch1.name = ch1\n        self.ch2.name = ch2\n        return self.ch0, self.ch1, self.ch2"
  },
  {
    "class_name": "ZebraPositionCaptureData",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/66-nano-zebra.py",
    "source": "class ZebraPositionCaptureData(Device):\n    \"\"\"\n    Data arrays for the Zebra position capture function and their metadata.\n    \"\"\"\n\n    # Data arrays\n    div1 = Cpt(EpicsSignal, \"PC_DIV1\")\n    div2 = Cpt(EpicsSignal, \"PC_DIV2\")\n    div3 = Cpt(EpicsSignal, \"PC_DIV3\")\n    div4 = Cpt(EpicsSignal, \"PC_DIV4\")\n    enc1 = Cpt(EpicsSignal, \"PC_ENC1\")\n    enc2 = Cpt(EpicsSignal, \"PC_ENC2\")\n    enc3 = Cpt(EpicsSignal, \"PC_ENC3\")\n    enc4 = Cpt(EpicsSignal, \"PC_ENC4\")\n    filt1 = Cpt(EpicsSignal, \"PC_FILT1\")\n    filt2 = Cpt(EpicsSignal, \"PC_FILT2\")\n    filt3 = Cpt(EpicsSignal, \"PC_FILT3\")\n    filt4 = Cpt(EpicsSignal, \"PC_FILT4\")\n    time = Cpt(EpicsSignal, \"PC_TIME\")\n    # Array sizes\n    num_cap = Cpt(EpicsSignal, \"PC_NUM_CAP\")\n    num_down = Cpt(EpicsSignal, \"PC_NUM_DOWN\")\n    # BOOLs to denote arrays with data\n    cap_enc1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B0\")\n    cap_enc2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B1\")\n    cap_enc3_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B2\")\n    cap_enc4_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B3\")\n    cap_filt1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B4\")\n    cap_filt2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B5\")\n    cap_div1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B6\")\n    cap_div2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B7\")\n    cap_div3_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B8\")\n    cap_div4_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B9\")"
  },
  {
    "class_name": "ZebraPositionCapture",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/66-nano-zebra.py",
    "source": "class ZebraPositionCapture(Device):\n    \"\"\"\n    Signals for the position capture function of the Zebra\n    \"\"\"\n\n    # Configuration settings and status PVs\n    enc = Cpt(EpicsSignalWithRBV, \"PC_ENC\")\n    egu = Cpt(EpicsSignalRO, \"M1:EGU\")\n    dir = Cpt(EpicsSignalWithRBV, \"PC_DIR\")\n    tspre = Cpt(EpicsSignalWithRBV, \"PC_TSPRE\")\n    trig_source = Cpt(EpicsSignalWithRBV, \"PC_ARM_SEL\")\n    arm = Cpt(EpicsSignal, \"PC_ARM\")\n    disarm = Cpt(EpicsSignal, \"PC_DISARM\")\n    armed = Cpt(EpicsSignalRO, \"PC_ARM_OUT\")\n    gate_source = Cpt(EpicsSignalWithRBV, \"PC_GATE_SEL\")\n    gate_start = Cpt(EpicsSignalWithRBV, \"PC_GATE_START\")\n    gate_width = Cpt(EpicsSignalWithRBV, \"PC_GATE_WID\")\n    gate_step = Cpt(EpicsSignalWithRBV, \"PC_GATE_STEP\")\n    gate_num = Cpt(EpicsSignalWithRBV, \"PC_GATE_NGATE\")\n    gated = Cpt(EpicsSignalRO, \"PC_GATE_OUT\")\n    pulse_source = Cpt(EpicsSignalWithRBV, \"PC_PULSE_SEL\")\n    pulse_start = Cpt(EpicsSignalWithRBV, \"PC_PULSE_START\")\n    pulse_width = Cpt(EpicsSignalWithRBV, \"PC_PULSE_WID\")\n    pulse_step = Cpt(EpicsSignalWithRBV, \"PC_PULSE_STEP\")\n    pulse_delay = Cpt(EpicsSignalWithRBV, \"PC_PULSE_DLY\")\n    pulse_max = Cpt(EpicsSignalWithRBV, \"PC_PULSE_MAX\")\n    pulse = Cpt(EpicsSignalRO, \"PC_PULSE_OUT\")\n    enc_pos1_sync = Cpt(EpicsSignal, \"M1:SETPOS.PROC\")\n    enc_pos2_sync = Cpt(EpicsSignal, \"M2:SETPOS.PROC\")\n    enc_pos3_sync = Cpt(EpicsSignal, \"M3:SETPOS.PROC\")\n    enc_pos4_sync = Cpt(EpicsSignal, \"M4:SETPOS.PROC\")\n    enc_res1 = Cpt(EpicsSignal, \"M1:MRES\")\n    enc_res2 = Cpt(EpicsSignal, \"M2:MRES\")\n    enc_res3 = Cpt(EpicsSignal, \"M3:MRES\")\n    enc_res4 = Cpt(EpicsSignal, \"M4:MRES\")\n    data_in_progress = Cpt(EpicsSignalRO, \"ARRAY_ACQ\")\n    block_state_reset = Cpt(EpicsSignal, \"SYS_RESET.PROC\")\n    data = Cpt(ZebraPositionCaptureData, \"\")\n\n    pos1_set = Cpt(EpicsSignal, \"POS1_SET\")\n\n    def stage(self):\n        self.arm.put(1)\n\n        super().stage()\n\n    def unstage(self):\n        self.disarm.put(1)\n        self.block_state_reset.put(1)\n\n        super().unstage()"
  },
  {
    "class_name": "SRXFlyer1Axis",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/66-nano-zebra.py",
    "source": "class SRXFlyer1Axis(Device):\n    \"\"\"\n    This is the Zebra.\n    \"\"\"\n    LARGE_FILE_DIRECTORY_WRITE_PATH = LARGE_FILE_DIRECTORY_PATH\n    LARGE_FILE_DIRECTORY_READ_PATH = LARGE_FILE_DIRECTORY_PATH\n    LARGE_FILE_DIRECTORY_ROOT = LARGE_FILE_DIRECTORY_ROOT\n    KNOWN_DETS = {\"xs\", \"xs2\", \"merlin2\", \"eiger2\", \"dexela\"}\n    fast_axis = Cpt(Signal, value=\"HOR\", kind=\"config\")\n    slow_axis = Cpt(Signal, value=\"VER\", kind=\"config\")\n\n    @property\n    def encoder(self):\n        return self._encoder\n\n    @property\n    def detectors(self):\n        return tuple(self._dets)\n\n    @detectors.setter\n    def detectors(self, value):\n        dets = tuple(value)\n        if not all(d.name in self.KNOWN_DETS for d in dets):\n            raise ValueError(\n                f\"One or more of {[d.name for d in dets]}\"\n                f\"is not known to the zebra. \"\n                f\"The known detectors are {self.KNOWN_DETS})\"\n            )\n        self._dets = dets\n\n    @property\n    def sclr(self):\n        return self._sis\n\n    def __init__(self, dets, sclr, zebra, *, reg=db.reg, **kwargs):\n        super().__init__(\"\", parent=None, **kwargs)\n        self._mode = \"idle\"\n        self._dets = dets\n        self._sis = sclr\n        self._filestore_resource = None\n        self._encoder = zebra\n\n        # # Gating info for encoder capture\n        self.stage_sigs[self._encoder.pc.gate_num] = 1\n        self.stage_sigs[self._encoder.pc.pulse_start] = 0\n\n        # This is for the merlin\n        self.stage_sigs[self._encoder.output1.ttl.addr] = 31\n\n        # Scaler\n        self.stage_sigs[self._encoder.output2.ttl.addr] = 31\n        self.stage_sigs[self._encoder.output3.ttl.addr] = 31\n\n        if self._sis is not None:\n            # Put SIS3820 into single count (not autocount) mode\n            self.stage_sigs[self._sis.count_mode] = 0\n            self.stage_sigs[self._sis.count_on_start] = 1\n            # Stop the SIS3820\n            self._sis.stop_all.put(1)\n\n        # self._encoder.pc.block_state_reset.put(1)\n        self.reg = reg\n        self._document_cache = []\n        self._last_bulk = None\n\n        self._point_counter = None\n        self.frame_per_point = None\n\n        self._data_exporter = ExportNanoZebraData()\n        if self._sis is not None:\n            self._data_sis_exporter = ExportSISData()\n\n    def _select_captured_data(self):\n        \"\"\"\n        Select the data to be captured by Zebra. Capturing unnecessary data slows down\n        the scans, so only necessary sources should be selected. Setting the respective\n        PVs can not be done in a fast sequence (technically setting PV is fast, but Zebra\n        parameters remain unchanged unless there is a pause after writing to each PV),\n        so the configuration can not be performed using 'stage_sigs'.\n        \"\"\"\n        dir = self.fast_axis.get()\n\n        sigs = {_: 0 for _ in [\n            self._encoder.pc.data.cap_enc1_bool,\n            self._encoder.pc.data.cap_enc2_bool,\n            self._encoder.pc.data.cap_enc3_bool,\n            self._encoder.pc.data.cap_enc4_bool,\n            self._encoder.pc.data.cap_filt1_bool,\n            self._encoder.pc.data.cap_filt2_bool,\n            self._encoder.pc.data.cap_div1_bool,\n            self._encoder.pc.data.cap_div2_bool,\n            self._encoder.pc.data.cap_div3_bool,\n            self._encoder.pc.data.cap_div4_bool\n        ]}\n\n        if dir == \"NANOHOR\":\n            sigs[self._encoder.pc.data.cap_enc1_bool] = bool(load_positions_from_zebra)\n        elif dir == \"NANOVER\":\n            sigs[self._encoder.pc.data.cap_enc2_bool] = bool(load_positions_from_zebra)\n        elif dir == \"NANOZ\":\n            sigs[self._encoder.pc.data.cap_enc3_bool] = bool(load_positions_from_zebra)\n        else:\n            raise ValueError(f\"Unknown value: dir={dir!r}\")\n\n        # Change the PV values only if the new values is different from the current values.\n        for sig, value in sigs.items():\n            current_value = sig.get()\n            if current_value != value:\n                sig.set(value).wait()\n                ttime.sleep(0.2)  # Determined experimentally\n\n    def stage(self):\n        self._point_counter = 0\n        dir = self.fast_axis.get()\n\n        self._select_captured_data()\n\n        if dir == \"NANOHOR\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc1\"\n            # self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n            # self.stage_sigs[self._encoder.pc.enc_res2] = 9.5368e-05\n        elif dir == \"NANOVER\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc2\"\n            # self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n            # self.stage_sigs[self._encoder.pc.enc_res2] = 9.5368e-05\n        elif dir == \"NANOZ\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc3\"\n            # self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n            # self.stage_sigs[self._encoder.pc.enc_res2] = 9.5368e-05\n        else:\n            raise ValueError(f\"Unknown value: dir={dir!r}\")\n\n        # print(f\"stage_sigs={self.stage_sigs}\") ##\n\n        self.__filename = \"{}.h5\".format(uuid.uuid4())\n        self.__filename_sis = \"{}.h5\".format(uuid.uuid4())\n        self.__read_filepath = os.path.join(\n            self.LARGE_FILE_DIRECTORY_READ_PATH, self.__filename\n        )\n        self.__read_filepath_sis = os.path.join(\n            self.LARGE_FILE_DIRECTORY_READ_PATH, self.__filename_sis\n        )\n        self.__write_filepath = os.path.join(\n            self.LARGE_FILE_DIRECTORY_WRITE_PATH, self.__filename\n        )\n        self.__write_filepath_sis = os.path.join(\n            self.LARGE_FILE_DIRECTORY_WRITE_PATH, self.__filename_sis\n        )\n\n        self.__filestore_resource, self._datum_factory_z = resource_factory(\n            ZebraHDF5Handler.HANDLER_NAME,\n            root=self.LARGE_FILE_DIRECTORY_ROOT,\n            resource_path=self.__read_filepath,\n            resource_kwargs={\"frame_per_point\": self.frame_per_point},\n            path_semantics=\"posix\",\n        )\n        self.__filestore_resource_sis, self._datum_factory_sis = resource_factory(\n            SISHDF5Handler.HANDLER_NAME,\n            root=self.LARGE_FILE_DIRECTORY_ROOT,\n            resource_path=self.__read_filepath_sis,\n            resource_kwargs={\"frame_per_point\": self.frame_per_point},\n            path_semantics=\"posix\",\n        )\n\n        resources = [self.__filestore_resource]\n        if self._sis:\n            resources.append(self.__filestore_resource_sis)\n        self._document_cache.extend((\"resource\", _) for _ in resources)\n\n        self._data_exporter.open(self.__write_filepath)\n        if self._sis is not None:\n            sis_mca_names = self._sis_mca_names()\n            self._data_sis_exporter.open(\n                self.__write_filepath_sis, mca_names=sis_mca_names, ion=self._sis, zebra=self._encoder\n            )\n\n        super().stage()\n\n    def unstage(self):\n        self._point_counter = None\n        self._data_exporter.close()\n        if self._sis is not None:\n            self._data_sis_exporter.close()\n        super().unstage()\n\n    def describe_collect(self):\n\n        ext_spec = \"FileStore:\"\n\n        spec = {\n            \"external\": ext_spec,\n            \"dtype\": \"array\",\n            \"shape\": [self._npts],\n            \"source\": \"\",  # make this the PV of the array the det is writing\n        }\n\n        desc = OrderedDict()\n        for chan in (\"time\", \"enc1\", \"enc2\", \"enc3\"):\n            desc[chan] = spec\n            desc[chan][\"source\"] = getattr(self._encoder.pc.data, chan).pvname\n\n        # Handle the detectors we are going to get\n        for d in self._dets:\n            desc.update(d.describe())\n\n        # Handle the ion chamber that the zebra is collecting\n        if self._sis is not None:\n            sis_mca_names = self._sis_mca_names()\n            for n, name in enumerate(sis_mca_names):\n                desc[name] = spec\n                desc[name][\"source\"] = self._sis.mca_by_index[n + 1].spectrum.pvname\n\n        return {\"primary\": desc}\n\n    def kickoff(self, *, xstart, xstop, xnum, dwell):\n        # print(f\"Kickoff: xstart={xstart} xtop={xstop} dwell={dwell}\")\n\n        self._data_exporter.set_fixed_positions()\n        self._data_exporter.set_fast_axis_parameters(fast_start=xstart, fast_stop=xstop, fast_n=xnum)\n\n        dets_by_name = {d.name: d for d in self.detectors}\n\n        self._encoder.pc.arm.put(0)\n        self._mode = \"kicked off\"\n        self._npts = int(xnum)\n        if xstart < xstop:\n            direction = 1\n        else:\n            direction = -1\n        pxsize = np.abs(xstop - xstart) / (xnum - 1)\n        extent = np.abs(xstop - xstart) + pxsize\n        # 2 ms delay between pulses\n        decrement = (pxsize / dwell) * 0.0005\n        decrement = max(decrement, 1e-5)\n\n        # print(f\"gate_start={xstart - direction * (pxsize/2)}\")\n        # print(f\"extent={extent}\")\n        self._encoder.pc.gate_source.put(0) # Sst to position trigger\n        self._encoder.pc.gate_start.put(xstart - direction * (pxsize / 2))\n        self._encoder.pc.gate_step.put(extent + 0.060)\n        self._encoder.pc.gate_width.put(extent + 0.050)\n\n        self._encoder.pc.pulse_source.put(0) # Sst to position trigger\n        self._encoder.pc.pulse_start.put(0.0)\n        self._encoder.pc.pulse_max.put(xnum)\n        self._encoder.pc.pulse_step.put(pxsize)\n        # self._encoder.pc.pulse_width.put(pxsize * 0.2)\n\n        # # self._encoder.pc.pulse_width.put(pxsize - decrement)\n        # # If decrement is too small, then zebra will not send individual pulses\n        # # but integrate over the entire line\n        # # Hopefully taken care of with decrement check above\n\n        # The case when Merlin is configured to work in 'Trigger Enable' trigger mode.\n        # The numbers are picked using trial and error method and work for dwell time\n        #   up to 0.004 s (250 Hz acquistion rate).\n        velocity = pxsize / dwell\n\n        if any([(\"merlin\" in _) for _ in dets_by_name]):\n            x_debounce = 0.0025 * velocity  # The true debounce time is 0.0016392 s\n        else:\n            x_debounce = 0\n\n        pulse_width = pxsize * 0.9 - x_debounce\n\n        if pulse_width < 0:\n            raise Exception(f\"Dwell time is too small ...\")\n        self._encoder.pc.pulse_width.put(pulse_width)\n\n        # Arm the zebra\n        self._encoder.pc.arm.put(1)\n\n        # TODO Return a status object *first* and do the above asynchronously.\n        return NullStatus()\n\n    def _sis_mca_names(self):\n        n_mcas = n_scaler_mca\n        return [getattr(self._sis.channels, f\"chan{_}\").name for _ in range(1, n_mcas + 1)]\n\n    def complete(self):\n        \"\"\"\n        Call this when all needed data has been collected. This has no idea\n        whether that is true, so it will obligingly stop immediately. It is\n        up to the caller to ensure that the motion is actually complete.\n        \"\"\"\n\n        amk_debug_flag = False\n\n        # print(f\"Complete 1\")\n        # Our acquisition complete PV is: XF:05IDD-ES:1{Dev:Zebra1}:ARRAY_ACQ\n        while self._encoder.pc.data_in_progress.get() == 1:\n            ttime.sleep(0.01)\n        # print(f\"Complete 2\")\n        # ttime.sleep(.1)\n        self._mode = \"complete\"\n        self._encoder.pc.block_state_reset.put(1)\n        # see triggering errors of the xspress3 on suspension.  This is\n        # to test the reset of the xspress3 after a line.\n\n        # print(f\"Complete 3\")\n\n        for d in self._dets:\n            d.stop(success=True)\n\n        # print(f\"Complete 4\")\n\n        time_datum = self._datum_factory_z({\"column\": \"time\", \"point_number\": self._point_counter})\n        enc1_datum = self._datum_factory_z({\"column\": \"enc1\", \"point_number\": self._point_counter})\n        enc2_datum = self._datum_factory_z({\"column\": \"enc2\", \"point_number\": self._point_counter})\n        enc3_datum = self._datum_factory_z({\"column\": \"enc3\", \"point_number\": self._point_counter})\n        if self._sis:\n            sis_mca_names = self._sis_mca_names()\n            sis_datum = []\n            for name in sis_mca_names:\n                sis_datum.append(self._datum_factory_sis({\"column\": name, \"point_number\": self._point_counter}))\n\n        self._document_cache.extend(\n            (\"datum\", d)\n            for d in (\n                time_datum,\n                enc1_datum,\n                enc2_datum,\n                enc3_datum,\n            )\n        )\n\n        if self._sis:\n            self._document_cache.extend((\"datum\", d) for d in sis_datum)\n\n        # grab the asset documents from all of the child detectors\n        for d in self._dets:\n            self._document_cache.extend(d.collect_asset_docs())\n\n        # Write the file.\n        # @timer_wrapper\n        def get_zebra_data():\n            self._data_exporter.export(self._encoder, self.fast_axis.get())\n\n        if amk_debug_flag:\n            t_getzebradata = tic()\n        get_zebra_data()\n        if amk_debug_flag:\n            toc(t_getzebradata, str='Get Zebra data')\n\n        # @timer_wrapper\n        def get_sis_data():\n            if self._sis is None:\n                return\n            self._data_sis_exporter.export()\n\n            # export_sis_data(\n            #     self._sis, sis_mca_names, self.__write_filepath_sis, self._encoder\n            # )\n\n        if amk_debug_flag:\n            t_sisdata = tic()\n        get_sis_data()\n        if amk_debug_flag:\n            toc(t_sisdata, str='Get SIS data')\n\n        # Yield a (partial) Event document. The RunEngine will put this\n        # into metadatastore, as it does all readings.\n        self._last_bulk = {\n            \"time\": ttime.time(),\n            \"seq_num\": 1,\n            \"data\": {\n                \"time\": time_datum[\"datum_id\"],\n                \"enc1\": enc1_datum[\"datum_id\"],\n                \"enc2\": enc2_datum[\"datum_id\"],\n                \"enc3\": enc3_datum[\"datum_id\"],\n            },\n            \"timestamps\": {\n                \"time\": time_datum[\"datum_id\"],  # not a typo#\n                \"enc1\": time_datum[\"datum_id\"],\n                \"enc2\": time_datum[\"datum_id\"],\n                \"enc3\": time_datum[\"datum_id\"],\n            },\n        }\n        if self._sis:\n            self._last_bulk[\"data\"].update({k: v[\"datum_id\"] for k, v in zip(sis_mca_names, sis_datum)})\n            self._last_bulk[\"timestamps\"].update({k: v[\"datum_id\"] for k, v in zip(sis_mca_names, sis_datum)})\n        for d in self._dets:\n            reading = d.read()\n            self._last_bulk[\"data\"].update(\n                {k: v[\"value\"] for k, v in reading.items()}\n                )\n            self._last_bulk[\"timestamps\"].update(\n                {k: v[\"timestamp\"] for k, v in reading.items()}\n            )\n\n        return NullStatus()\n\n    def collect(self):\n        # Create records in the FileStore database.\n        # move this to stage because I thinkt hat describe_collect needs the\n        # resource id\n        # TODO use ophyd.areadectector.filestoer_mixins.resllource_factory here\n        if self._last_bulk is None:\n            raise Exception(\n                \"the order of complete and collect is brittle and out \"\n                \"of sync. This device relies on in-order and 1:1 calls \"\n                \"between complete and collect to correctly create and stash \"\n                \"the asset registry documents\"\n            )\n        yield self._last_bulk\n        self._point_counter += 1\n        self._last_bulk = None\n        self._mode = \"idle\"\n\n    def collect_asset_docs(self):\n        yield from iter(list(self._document_cache))\n        self._document_cache.clear()\n\n    def stop(self):\n        self._encoder.pc.block_state_reset.put(1)\n        pass\n\n    def pause(self):\n        \"Pausing in the middle of a kickoff nukes the partial dataset.\"\n        self._encoder.pc.block_state_reset.put(1)\n        if self._sis is not None:\n            self._sis.stop_all.put(1)\n        for d in self._dets:\n            if hasattr(d, \"settings\"):\n                d.settings.acquire.put(0)\n            if hasattr(d, \"cam\"):\n                d.cam.acquire.put(0)\n        self._mode = \"idle\"\n        self.unstage()\n\n    def resume(self):\n        self.unstage()\n        self.stage()"
  },
  {
    "class_name": "DATA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class DATA(Device):\n    hdf_directory = Cpt(EpicsSignal, \"HDFDirectory\", string=True)\n    hdf_file_name = Cpt(EpicsSignal, \"HDFFileName\", string=True)\n    num_capture = Cpt(EpicsSignal, \"NumCapture\")\n    num_captured = Cpt(EpicsSignal, \"NumCaptured\")\n    flush_period = Cpt(EpicsSignal, \"FlushPeriod\")\n    capture = Cpt(EpicsSignal, \"Capture\")\n    capture_mode = Cpt(EpicsSignal, \"CaptureMode\", string=True)\n    status = Cpt(EpicsSignal, \"Status\", string=True)"
  },
  {
    "class_name": "PCOMP",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class PCOMP(Device):\n    pre_start = Cpt(EpicsSignal, \"PRE_START\")\n    start = Cpt(EpicsSignal, \"START\")\n    width = Cpt(EpicsSignal, \"WIDTH\")\n    step = Cpt(EpicsSignal, \"STEP\")\n    pulses = Cpt(EpicsSignal, \"PULSES\")"
  },
  {
    "class_name": "PCAP",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class PCAP(Device):\n    arm = Cpt(EpicsSignal, \"ARM\")\n    active = Cpt(EpicsSignal, \"ACTIVE\")"
  },
  {
    "class_name": "CLOCK",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class CLOCK(Device):\n    enable = Cpt(EpicsSignal, \"ENABLE\")\n    period = Cpt(EpicsSignal, \"PERIOD\")\n    period_units = Cpt(EpicsSignal, \"PERIOD:UNITS\")"
  },
  {
    "class_name": "COUNTER",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class COUNTER(Device):\n    enable = Cpt(EpicsSignal, \"ENABLE\")\n    start = Cpt(EpicsSignal, \"START\")\n    step = Cpt(EpicsSignal, \"STEP\")\n    max = Cpt(EpicsSignal, \"MAX\")\n    min = Cpt(EpicsSignal, \"MIN\")"
  },
  {
    "class_name": "INENC",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class INENC(Device):\n    val = Cpt(EpicsSignal, \"VAL\")\n    setp = Cpt(EpicsSignal, \"SETP\")"
  },
  {
    "class_name": "POSITION",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class POSITION(Device):\n    units = Cpt(EpicsSignal, \"UNITS\", string=True)\n    scale = Cpt(EpicsSignal, \"SCALE\")\n    offset = Cpt(EpicsSignal, \"OFFSET\")"
  },
  {
    "class_name": "POSITIONS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class POSITIONS(Device):\n    inenc1 = Cpt(POSITION, \"12:\")\n    inenc2 = Cpt(POSITION, \"13:\")"
  },
  {
    "class_name": "PULSE",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class PULSE(Device):\n    delay_units = Cpt(EpicsSignal, \"DELAY:UNITS\", string=True)\n    delay = Cpt(EpicsSignal, \"DELAY\")\n    width_units = Cpt(EpicsSignal, \"WIDTH:UNITS\", string=True)\n    width = Cpt(EpicsSignal, \"WIDTH\")\n    pulses = Cpt(EpicsSignal, \"PULSES\")\n    step_units = Cpt(EpicsSignal, \"STEP:UNITS\", string=True)\n    step = Cpt(EpicsSignal, \"STEP\")\n    trig_edge = Cpt(EpicsSignal, \"TRIG_EDGE\", string=True)"
  },
  {
    "class_name": "BITS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class BITS(Device):\n    A = Cpt(EpicsSignal, \"A\")\n    B = Cpt(EpicsSignal, \"B\")\n    C = Cpt(EpicsSignal, \"C\")\n    D = Cpt(EpicsSignal, \"D\")"
  },
  {
    "class_name": "PandA_Ophyd1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class PandA_Ophyd1(Device):\n    pcap = Cpt(PCAP, \"PCAP:\")\n    data = Cpt(DATA, \"DATA:\")\n    pcomp1 = Cpt(PCOMP, \"PCOMP1:\")\n    pcomp2 = Cpt(PCOMP, \"PCOMP2:\")\n    clock1 = Cpt(CLOCK, \"CLOCK1:\")\n    clock2 = Cpt(CLOCK, \"CLOCK2:\")\n    counter1 = Cpt(COUNTER, \"COUNTER1:\")\n    counter2 = Cpt(COUNTER, \"COUNTER2:\")\n    counter3 = Cpt(COUNTER, \"COUNTER3:\")\n    inenc1 = Cpt(INENC, \"INENC1:\")\n    inenc2 = Cpt(INENC, \"INENC2:\")\n    inenc3 = Cpt(INENC, \"INENC3:\")\n    inenc4 = Cpt(INENC, \"INENC4:\")\n    pulse1 = Cpt(PULSE, \"PULSE1:\")\n    pulse2 = Cpt(PULSE, \"PULSE2:\")\n    pulse3 = Cpt(PULSE, \"PULSE3:\")\n    pulse4 = Cpt(PULSE, \"PULSE4:\")\n    positions = Cpt(POSITIONS, \"POSITIONS:\")\n    bits = Cpt(BITS, \"BITS:\")"
  },
  {
    "class_name": "HXNFlyerPanda",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/93-scanplan-panda.py",
    "source": "class HXNFlyerPanda(Device):\n    \"\"\"\n    This is the Panda1.\n    \"\"\"\n\n    LARGE_FILE_DIRECTORY_WRITE_PATH = LARGE_FILE_DIRECTORY_PATH\n    LARGE_FILE_DIRECTORY_READ_PATH = LARGE_FILE_DIRECTORY_PATH\n    LARGE_FILE_DIRECTORY_ROOT = LARGE_FILE_DIRECTORY_ROOT\n\n    @property\n    def detectors(self):\n        return tuple(self._dets)\n\n    @detectors.setter\n    def detectors(self, value):\n        dets = tuple(value)\n        # if not all([d.name in self.KNOWN_DETS for d in dets]):\n        #     raise ValueError(\n        #         f\"One or more of {[d.name for d in dets]}\"\n        #         f\"is not known to the panda. \"\n        #         f\"The known detectors are {self.KNOWN_DETS})\"\n        #     )\n        self._dets = dets\n\n    @property\n    def sclr(self):\n        return self._sis\n\n    def __init__(self, panda,dets,sclr, motor=None, root_dir=None, **kwargs):\n        super().__init__(\"\", parent=None, **kwargs)\n        self.name = \"PandaFlyer\"\n        if root_dir is None:\n            root_dir = self.LARGE_FILE_DIRECTORY_ROOT\n        self._mode = \"idle\"\n        self._dets = dets\n        self._sis = sclr\n        self._root_dir = root_dir\n        self._resource_document, self._datum_factory = None, None\n        self._document_cache = deque()\n        self._last_bulk = None\n\n        self._point_counter = None\n        self.frame_per_point = None\n\n        self.panda = panda\n        self.motor = motor\n\n        self._document_cache = []\n        self._resource_document = None\n        self._datum_factory = None\n\n        if self._sis is not None:\n            self._data_sis_exporter = ExportSISDataPanda()\n\n        self._xsp_roi_exporter = None\n\n        type_map = {\"int32\": \"<i4\", \"float32\": \"<f4\", \"float64\": \"<f8\"}\n\n        self.fields = {\n            # \"counter1_out\": {\n            #     \"value\": \"COUNTER1.OUT.Value\",\n            #     \"dtype_str\": type_map[\"float64\"],\n            # },\n            \"inenc1_val\": {\n                \"value\": \"INENC1.VAL.Value\",\n                \"dtype_str\": type_map[\"int32\"],\n            },\n            \"inenc2_val\": {\n                \"value\": \"INENC2.VAL.Value\",\n                \"dtype_str\": type_map[\"int32\"],\n            },\n            \"inenc3_val\": {\n                \"value\": \"INENC3.VAL.Value\",\n                \"dtype_str\": type_map[\"int32\"],\n            },\n            \"inenc4_val\": {\n                \"value\": \"INENC4.VAL.Value\",\n                \"dtype_str\": type_map[\"int32\"],\n            },\n            \"pcap_ts_trig\": {\n                \"value\": \"PCAP.TS_TRIG.Value\",\n                \"dtype_str\": type_map[\"float64\"],\n            },\n        }\n        self.panda.data.hdf_directory.put_complete = True\n        self.panda.data.hdf_file_name.put_complete = True\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        self._point_counter = None\n        if self._sis is not None:\n            self._data_sis_exporter.close()\n        if self._xsp_roi_exporter is not None:\n            self._xsp_roi_exporter.close()\n        super().unstage()\n\n    def kickoff(self, *, num):\n        \"\"\"Kickoff the acquisition process.\"\"\"\n        # Prepare parameters:\n        self._document_cache = deque()\n        self._datum_docs = {}\n        self._counter = itertools.count()\n        self._point_counter = 0\n\n        self.frame_per_point = int(num)\n        self._npts = int(num)\n        # Prepare 'resource' factory.\n        now = datetime.now()\n        self.fl_path = self.LARGE_FILE_DIRECTORY_WRITE_PATH\n        self.fl_name = f\"panda_rbdata_{now.strftime('%Y%m%d_%H%M%S')}_{short_uid()}.h5\"\n\n        resource_path = self.fl_name\n        self._resource_document, self._datum_factory, _ = compose_resource(\n            start={\"uid\": \"needed for compose_resource() but will be discarded\"},\n            spec=\"PANDA\",\n            root=self.fl_path,\n            resource_path=resource_path,\n            resource_kwargs={},\n        )\n        # now discard the start uid, a real one will be added later\n        self._resource_document.pop(\"run_start\")\n        self._document_cache.append((\"resource\", self._resource_document))\n\n        for key, value in self.fields.items():\n            datum_document = self._datum_factory(datum_kwargs={\"field\": value[\"value\"]})\n            self._document_cache.append((\"datum\", datum_document))\n            self._datum_docs[key] = datum_document\n\n\n        ## Scaler\n        if self._sis is not None:\n            # Stop the SIS3820\n            self._sis.stop_all.put(1)\n\n        self.__filename_sis = \"{}.h5\".format(uuid.uuid4())\n        self.__read_filepath_sis = os.path.join(\n            self.LARGE_FILE_DIRECTORY_READ_PATH, self.__filename_sis\n        )\n        self.__write_filepath_sis = os.path.join(\n            self.LARGE_FILE_DIRECTORY_WRITE_PATH, self.__filename_sis\n        )\n\n        self.__filestore_resource_sis, self._datum_factory_sis = resource_factory(\n            SISHDF5Handler.HANDLER_NAME,\n            root=self.LARGE_FILE_DIRECTORY_ROOT,\n            resource_path=self.__read_filepath_sis,\n            resource_kwargs={\"frame_per_point\": self.frame_per_point},\n            path_semantics=\"posix\",\n        )\n\n        resources = [self.__filestore_resource_sis]\n\n        self._xsp_roi_exporter = None\n        ## Xspress3 ROIs\n        for d in self._dets:\n            if d.name == 'xspress3' or d.name == 'xspress3_det2':\n\n                self.xsp = d\n\n                self.__filename_xsp_roi = \"ROI0_{}.h5\".format(uuid.uuid4())\n                self.__read_filepath_xsp_roi = os.path.join(\n                    self.LARGE_FILE_DIRECTORY_READ_PATH, self.__filename_xsp_roi\n                )\n                self.__write_filepath_xsp_roi = os.path.join(\n                    self.LARGE_FILE_DIRECTORY_WRITE_PATH, self.__filename_xsp_roi\n                )\n\n                self._xsp_roi_exporter = ExportXpsROI()\n                self._xsp_roi_exporter.open(\n                    self. __write_filepath_xsp_roi, d\n                )\n\n                self.__filestore_resource_xsp_roi, self._datum_factory_xsp_roi = resource_factory(\n                    'ROI_HDF5_FLY',\n                    root=self.LARGE_FILE_DIRECTORY_ROOT,\n                    resource_path=self.__read_filepath_xsp_roi,\n                    resource_kwargs={},\n                    path_semantics=\"posix\",\n                )\n\n\n                resources.append(self.__filestore_resource_xsp_roi)\n\n        # if self._sis:\n        #     resources.append(self.__filestore_resource_sis)\n\n        self._document_cache.extend((\"resource\", _) for _ in resources)\n\n        if self._sis is not None:\n            sis_mca_names = self._sis_mca_names()\n            self._data_sis_exporter.open(\n                self.__write_filepath_sis, mca_names=sis_mca_names, ion=self._sis, panda=self.panda\n            )\n\n\n        # Kickoff panda process:\n        print(f\"[Panda]Starting acquisition ...\")\n\n        self.panda.position_supersample = self.position_supersample\n\n        self.panda.data.hdf_directory.set(self.fl_path).wait()\n        self.panda.data.hdf_file_name.set(self.fl_name).wait()\n        #self.panda.data.flush_period.set(1).wait()\n\n        self.panda.data.capture_mode.set(\"FIRST_N\").wait()\n        self.panda.data.num_capture.set(self.frame_per_point).wait()\n\n        self.panda.pcap.arm.set(1).wait()\n\n        self.panda.data.capture.set(1).wait()\n\n        print(f\"[Panda]Panda kickoff complete ...\")\n\n        return NullStatus()\n\n    def complete(self):\n        print(\"[Panda]complete\")\n        \"\"\"Wait for the acquisition process started in kickoff to complete.\"\"\"\n        # Wait until done\n        timeout = 60\n        counter = 0\n        while (self.panda.data.capture.get() == 1) and (counter<timeout):\n            time.sleep(0.1)\n            counter+=1\n\n        self.panda.pcap.arm.set(0).wait()\n        self.panda.data.capture.put(0)\n\n        for d in self._dets:\n            d.stop(success=True)\n\n        now = ttime.time()  # TODO: figure out how to get it from PandABox (maybe?)\n\n        data_dict = {\n            key: datum_doc[\"datum_id\"] for key, datum_doc in self._datum_docs.items()\n        }\n\n        self._last_bulk = {\n            \"data\": data_dict,\n            \"timestamps\": {key: now for key in self._datum_docs},\n            \"time\": now,\n            \"filled\": {key: False for key in self._datum_docs},\n        }\n\n        if self._sis:\n            sis_mca_names = self._sis_mca_names()\n            sis_datum = []\n            for name in sis_mca_names:\n                sis_datum.append(self._datum_factory_sis({\"column\": name, \"point_number\": self._point_counter}))\n            self._document_cache.extend((\"datum\", d) for d in sis_datum)\n\n        # @timer_wrapper\n        def get_sis_data():\n            if self._sis is None:\n                return\n            self._data_sis_exporter.export()\n\n        get_sis_data()\n\n        if self._xsp_roi_exporter is not None:\n            self._xsp_roi_exporter.export(int(self.frame_per_point/self.position_supersample))\n\n            panda_live_plot.update_plot(True)\n\n            roi_datum = []\n            for roi in self.xsp.enabled_rois:\n                roi_datum.append(self._datum_factory_xsp_roi({\"det_elem\": roi.name}))\n            self._last_bulk[\"data\"].update({k: v[\"datum_id\"] for k, v in zip([roi.name for roi in self.xsp.enabled_rois], roi_datum)})\n            self._last_bulk[\"timestamps\"].update({k: v[\"datum_id\"] for k, v in zip([roi.name for roi in self.xsp.enabled_rois], roi_datum)})\n            self._document_cache.extend((\"datum\", d) for d in roi_datum)\n\n        for d in self._dets:\n            if d.name != 'fs' and d.name != 'bshutter' and d.name != 'xspress3':\n                self._document_cache.extend(d.collect_asset_docs())\n            if d.name == 'xspress3':\n                doc_cnt = 0\n                for doc in d.collect_asset_docs():\n                    self._document_cache.append(doc)\n                    doc_cnt += 1\n                    if doc_cnt == 4:\n                        break\n\n        print(\"[Panda]collect data\")\n\n        if self._sis:\n            self._last_bulk[\"data\"].update({k: v[\"datum_id\"] for k, v in zip(sis_mca_names, sis_datum)})\n            self._last_bulk[\"timestamps\"].update({k: v[\"datum_id\"] for k, v in zip(sis_mca_names, sis_datum)})\n\n        for d in self._dets:\n            if d.name == 'merlin1' or d.name == 'merlin2':\n                reading = d.read()\n                self._last_bulk[\"data\"].update(\n                    {k: v[\"value\"] for k, v in reading.items()}\n                    )\n                self._last_bulk[\"timestamps\"].update(\n                    {k: v[\"timestamp\"] for k, v in reading.items()}\n                )\n            if d.name.startswith('eiger'):\n                reading = d.read()\n                self._last_bulk[\"data\"].update(\n                    {k: v[\"value\"] for k, v in reading.items()}\n                    )\n                self._last_bulk[\"timestamps\"].update(\n                    {k: v[\"timestamp\"] for k, v in reading.items()}\n                )\n            if d.name == 'xspress3':\n                reading = d.read()\n                self._last_bulk[\"data\"].update(\n                    {k: v[\"value\"] for k, v in reading.items() if k.startswith('xspress3')}\n                )\n                self._last_bulk[\"timestamps\"].update(\n                    {k: v[\"timestamp\"] for k, v in reading.items() if k.startswith('xspress3')}\n                )\n            if d.name == 'xspress3_det2':\n                reading = d.read()\n                self._last_bulk[\"data\"].update(\n                    {k: v[\"value\"] for k, v in reading.items()}\n                )\n                self._last_bulk[\"timestamps\"].update(\n                    {k: time.time() for k, v in reading.items()}\n                )\n\n        return NullStatus()\n\n    def describe_collect(self):\n        \"\"\"Describe the data structure.\"\"\"\n        return_dict = {\"primary\": OrderedDict()}\n        desc = return_dict[\"primary\"]\n\n        ext_spec = \"FileStore:\"\n\n        spec = {\n            \"external\": ext_spec,\n            \"dtype\": \"array\",\n            \"shape\": [self._npts],\n            \"source\": \"\",  # make this the PV of the array the det is writing\n        }\n\n        for key, value in self.fields.items():\n            desc.update(\n                {\n                    key: {\n                        \"source\": \"PANDA\",\n                        \"dtype\": \"array\",\n                        \"dtype_str\": value[\"dtype_str\"],\n                        \"shape\": [\n                            self.frame_per_point\n                        ],  # TODO: figure out variable shape\n                        \"external\": \"FILESTORE:\",\n                    }\n                }\n            )\n\n        for d in self._dets:\n            if d.name == 'merlin1' or d.name == 'merlin2':\n                desc.update(d.describe())\n            if d.name.startswith('eiger'):\n                desc.update(d.describe())\n            if d.name == 'xspress3':\n                desc.update([(k, v) for k,v in d.describe().items() if k.startswith('xspress3')])\n            if d.name == 'xspress3_det2':\n                desc.update(d.describe())\n\n        if self._sis is not None:\n            sis_mca_names = self._sis_mca_names()\n            for n, name in enumerate(sis_mca_names):\n                desc[name] = spec\n                desc[name][\"source\"] = self._sis.mca_by_index[n + 1].spectrum.pvname\n\n        if self._xsp_roi_exporter is not None:\n            for roi in self.xsp.enabled_rois:\n                desc[roi.name] = spec\n                if hasattr(roi,'settings'):\n                    desc[roi.name][\"source\"] = roi.settings.array_data.pvname\n                else:\n                    desc[roi.name][\"source\"] = roi.ts_total.pvname\n\n\n        return return_dict\n\n    def collect(self):\n        yield self._last_bulk\n        self._point_counter += 1\n\n    def collect_asset_docs(self):\n        \"\"\"The method to collect resource/datum documents.\"\"\"\n        items = list(self._document_cache)\n        self._document_cache.clear()\n        yield from items\n\n    def _sis_mca_names(self):\n        n_mcas = n_scaler_mca\n        return [getattr(self._sis.channels, f\"chan{_}\").name for _ in range(1, n_mcas + 1)]"
  },
  {
    "class_name": "HXNTimeScan",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/91-timescan.py",
    "source": "class HXNTimeScan(Device):\n\n    LARGE_FILE_DIRECTORY_WRITE_PATH = LARGE_FILE_DIRECTORY_PATH\n    LARGE_FILE_DIRECTORY_READ_PATH = LARGE_FILE_DIRECTORY_PATH\n    LARGE_FILE_DIRECTORY_ROOT = LARGE_FILE_DIRECTORY_ROOT\n\n    KNOWN_DETS = {\"eiger_mobile\"}\n\n    @property\n    def detectors(self):\n        return tuple(self._dets)\n\n    @detectors.setter\n    def detectors(self, value):\n        dets = tuple(value)\n        if not all(d.name in self.KNOWN_DETS for d in dets):\n            raise ValueError(\n                f\"One or more of {[d.name for d in dets]}\"\n                f\"is not known to the zebra. \"\n                f\"The known detectors are {self.KNOWN_DETS})\"\n            )\n        self._dets = dets\n\n    @property\n    def sclr(self):\n        return self._sis\n\n    def __init__(self,dets,sclr, motor=None, root_dir=None, **kwargs):\n        super().__init__(\"\", parent=None, **kwargs)\n        self.name = \"TimeFlyer\"\n        if root_dir is None:\n            root_dir = self.LARGE_FILE_DIRECTORY_ROOT\n        self._mode = \"idle\"\n        self._dets = dets\n        self._sis = sclr\n        self._root_dir = root_dir\n        self._resource_document, self._datum_factory = None, None\n        self._document_cache = deque()\n        self._last_bulk = None\n\n        self._point_counter = None\n        self.frame_per_point = None\n\n        self.motor = motor\n\n        self._document_cache = []\n        self._resource_document = None\n        self._datum_factory = None\n\n        if self._sis is not None:\n            self._data_sis_exporter = ExportSISDataTime()\n\n        type_map = {\"int32\": \"<i4\", \"float32\": \"<f4\", \"float64\": \"<f8\"}\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        self._point_counter = None\n        if self._sis is not None:\n            self._data_sis_exporter.close()\n        super().unstage()\n\n    def kickoff(self, *, num, dwell):\n        \"\"\"Kickoff the acquisition process.\"\"\"\n        # Prepare parameters:\n        self._document_cache = deque()\n        self._datum_docs = {}\n        self._counter = itertools.count()\n        self._point_counter = 0\n\n        self.frame_per_point = int(num)\n        self._npts = int(num)\n        # Prepare 'resource' factory.\n        now = datetime.now()\n        self.fl_path = self.LARGE_FILE_DIRECTORY_WRITE_PATH\n        self.fl_name = f\"panda_rbdata_{now.strftime('%Y%m%d_%H%M%S')}_{short_uid()}.h5\"\n\n        resource_path = self.fl_name\n        self._resource_document, self._datum_factory, _ = compose_resource(\n            start={\"uid\": \"needed for compose_resource() but will be discarded\"},\n            spec=\"PANDA\",\n            root=self.fl_path,\n            resource_path=resource_path,\n            resource_kwargs={},\n        )\n        # now discard the start uid, a real one will be added later\n        self._resource_document.pop(\"run_start\")\n        self._document_cache.append((\"resource\", self._resource_document))\n\n        if self._sis is not None:\n            # Put SIS3820 into single count (not autocount) mode\n            self.stage_sigs[self._sis.count_mode] = 0\n            self.stage_sigs[self._sis.count_on_start] = 1\n            # Stop the SIS3820\n            self._sis.stop_all.put(1)\n\n        self.__filename_sis = \"{}.h5\".format(uuid.uuid4())\n        print(self.__filename_sis)\n        self.__read_filepath_sis = os.path.join(\n            self.LARGE_FILE_DIRECTORY_READ_PATH, self.__filename_sis\n        )\n        self.__write_filepath_sis = os.path.join(\n            self.LARGE_FILE_DIRECTORY_WRITE_PATH, self.__filename_sis\n        )\n\n        self.__filestore_resource_sis, self._datum_factory_sis = resource_factory(\n            SISHDF5Handler.HANDLER_NAME,\n            root=self.LARGE_FILE_DIRECTORY_ROOT,\n            resource_path=self.__read_filepath_sis,\n            resource_kwargs={\"frame_per_point\": self.frame_per_point},\n            path_semantics=\"posix\",\n        )\n\n        resources = [self.__filestore_resource_sis]\n        if self._sis:\n            resources.append(self.__filestore_resource_sis)\n        self._document_cache.extend((\"resource\", _) for _ in resources)\n\n        if self._sis is not None:\n            sis_mca_names = self._sis_mca_names()\n            self._data_sis_exporter.open(\n                self.__write_filepath_sis, mca_names=sis_mca_names, ion=self._sis\n            )\n\n        return NullStatus()\n\n    def complete(self):\n        for d in self._dets:\n            d.stop(success=True)\n\n\n        if self._sis:\n            sis_mca_names = self._sis_mca_names()\n            sis_datum = []\n            for name in sis_mca_names:\n                sis_datum.append(self._datum_factory_sis({\"column\": name, \"point_number\": self._point_counter}))\n\n\n        if self._sis:\n            self._document_cache.extend((\"datum\", d) for d in sis_datum)\n\n        for d in self._dets:\n            if d.name != \"fs\":\n                self._document_cache.extend(d.collect_asset_docs())\n\n        # @timer_wrapper\n        def get_sis_data():\n            if self._sis is None:\n                return\n            self._data_sis_exporter.export()\n\n        get_sis_data()\n\n        data_dict = {\n            key: datum_doc[\"datum_id\"] for key, datum_doc in self._datum_docs.items()\n        }\n\n        now = ttime.time()  # TODO: figure out how to get it from PandABox (maybe?)\n        self._last_bulk = {\n            \"data\": data_dict,\n            \"timestamps\": {key: now for key in self._datum_docs},\n            \"time\": now,\n            \"filled\": {key: False for key in self._datum_docs},\n        }\n\n        if self._sis:\n            self._last_bulk[\"data\"].update({k: v[\"datum_id\"] for k, v in zip(sis_mca_names, sis_datum)})\n            self._last_bulk[\"timestamps\"].update({k: v[\"datum_id\"] for k, v in zip(sis_mca_names, sis_datum)})\n\n        for d in self._dets:\n            reading = d.read()\n            self._last_bulk[\"data\"].update(\n                {k: v[\"value\"] for k, v in reading.items()}\n                )\n            self._last_bulk[\"timestamps\"].update(\n                {k: v[\"timestamp\"] for k, v in reading.items()}\n            )\n\n        return NullStatus()\n\n    def describe_collect(self):\n        \"\"\"Describe the data structure.\"\"\"\n        return_dict = {\"primary\": OrderedDict()}\n        desc = return_dict[\"primary\"]\n\n        ext_spec = \"FileStore:\"\n\n        spec = {\n            \"external\": ext_spec,\n            \"dtype\": \"array\",\n            \"shape\": [self._npts],\n            \"source\": \"\",  # make this the PV of the array the det is writing\n        }\n\n        for d in self._dets:\n            desc.update(d.describe())\n\n        if self._sis is not None:\n            sis_mca_names = self._sis_mca_names()\n            for n, name in enumerate(sis_mca_names):\n                desc[name] = spec\n                desc[name][\"source\"] = self._sis.mca_by_index[n + 1].spectrum.pvname\n\n        return return_dict\n\n    def collect(self):\n        yield self._last_bulk\n        self._point_counter += 1\n\n    def collect_asset_docs(self):\n        \"\"\"The method to collect resource/datum documents.\"\"\"\n        items = list(self._document_cache)\n        self._document_cache.clear()\n        yield from items\n\n    def _sis_mca_names(self):\n        n_mcas = n_scaler_mca\n        return [getattr(self._sis.channels, f\"chan{_}\").name for _ in range(1, n_mcas + 1)]"
  },
  {
    "class_name": "InsertionDevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/11-machine.py",
    "source": "class InsertionDevice(Device):\n    gap = Cpt(EpicsMotor, '-Ax:Gap}-Mtr',\n              kind='hinted', name='', settle_time=.1)\n    brake = Cpt(EpicsSignal, '}BrakesDisengaged-Sts',\n                write_pv='}BrakesDisengaged-SP',\n                kind='omitted', add_prefix=('read_pv', 'write_pv', 'suffix'))\n\n\n    def set(self, *args, **kwargs):\n        # from ophyd.utils import set_and_wait\n        # set_and_wait(self.brake, 1)\n        self.brake.set(1).wait()\n        return self.gap.set(*args, **kwargs)\n\n    def stop(self, *, success=False):\n        return self.gap.stop(success=success)\n\n    @property\n    def position(self):\n        return self.gap.position"
  },
  {
    "class_name": "Xspress3FileStoreHXN",
    "bases": [
      "Xspress3FileStore"
    ],
    "file": "profile-collections/hxn-profile-collection/startup/21-xspress3.py",
    "source": "class Xspress3FileStoreHXN(Xspress3FileStore):\n    def read(self):\n        self._locked_key_list = self._staged == Staged.yes\n        res = super().read()\n        for k, v in self._datum_uids.items():\n            res[k] = v.pop(0)\n        return res\n    \n    def stage(self):\n                # if should external trigger\n        ext_trig = self.parent.external_trig.get()\n\n        logger.debug('Stopping xspress3 acquisition')\n        # really force it to stop acquiring\n        self.settings.acquire.put(0, wait=True)\n\n        total_points = self.parent.total_points.get()\n        if total_points < 1:\n            raise RuntimeError(\"You must set the total points\")\n        spec_per_point = self.parent.spectra_per_point.get()\n        total_capture = total_points * spec_per_point\n\n        # stop previous acquisition\n        self.stage_sigs[self.settings.acquire] = 0\n\n        # re-order the stage signals and disable the calc record which is\n        # interfering with the capture count\n        self.stage_sigs.pop(self.num_capture, None)\n        self.stage_sigs.pop(self.settings.num_images, None)\n        self.stage_sigs[self.num_capture_calc_disable] = 1\n\n        if ext_trig:\n            logger.debug('Setting up external triggering')\n            self.stage_sigs[self.settings.trigger_mode] = 'TTL Both'\n            self.stage_sigs[self.settings.num_images] = total_capture\n        else:\n            logger.debug('Setting up internal triggering')\n            # self.settings.trigger_mode.put('Internal')\n            # self.settings.num_images.put(1)\n            self.stage_sigs[self.settings.trigger_mode] = 'Internal'\n            self.stage_sigs[self.settings.num_images] = spec_per_point\n\n        self.stage_sigs[self.auto_save] = 'No'\n        logger.debug('Configuring other filestore stuff')\n\n        logger.debug('Making the filename')\n        filename, read_path, write_path = self.make_filename()\n\n        logger.debug('Setting up hdf5 plugin: ioc path: %s filename: %s',\n                     write_path, filename)\n\n        logger.debug('Erasing old spectra')\n        self.settings.erase.put(1, wait=True)\n\n        # this must be set after self.settings.num_images because at the Epics\n        # layer  there is a helpful link that sets this equal to that (but\n        # not the other way)\n        self.stage_sigs[self.num_capture] = total_capture\n\n        # actually apply the stage_sigs\n        ret = FileStorePluginBase.stage(self)\n        #ret = super(Xspress3FileStore,self).stage()\n\n        self._fn = self.file_template.get() % (self._fp,\n                                               self.file_name.get(),\n                                               self.file_number.get())\n\n        if not self.file_path_exists.get():\n            raise IOError(\"Path {} does not exits on IOC!! Please Check\"\n                          .format(self.file_path.get()))\n\n        logger.debug('Inserting the filestore resource: %s', self._fn)\n        self._generate_resource({})\n\n        self._filestore_res = self._asset_docs_cache[-1][-1]\n\n        # this gets auto turned off at the end\n        self.capture.put(1)\n\n        # Xspress3 needs a bit of time to configure itself...\n        # this does not play nice with the event loop :/\n        time.sleep(self._config_time)\n\n        return ret"
  },
  {
    "class_name": "ZebraSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraSignalWithRBV(EpicsSignal):\n    # An EPICS signal that uses the Zebra convention of 'pvname' being the\n    # setpoint and 'pvname:RBV' being the read-back\n\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix + ':RBV', write_pv=prefix, **kwargs)"
  },
  {
    "class_name": "ZebraPulse",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraPulse(Device):\n    width = Cpt(ZebraSignalWithRBV, 'WID')\n    input_addr = Cpt(ZebraSignalWithRBV, 'INP')\n    input_str = Cpt(EpicsSignalRO, 'INP:STR', string=True)\n    input_status = Cpt(EpicsSignalRO, 'INP:STA')\n    delay = Cpt(ZebraSignalWithRBV, 'DLY')\n    delay_sync = Cpt(EpicsSignal, 'DLY:SYNC')\n    time_units = Cpt(ZebraSignalWithRBV, 'PRE', string=True)\n    output = Cpt(EpicsSignal, 'OUT')\n\n    input_edge = FC(EpicsSignal,\n                    '{self._zebra_prefix}POLARITY:{self._edge_addr}')\n\n    _edge_addrs = {1: 'BC',\n                   2: 'BD',\n                   3: 'BE',\n                   4: 'BF',\n                   }\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['input_status', 'output']\n        if configuration_attrs is None:\n            configuration_attrs = list(self.component_names) + ['input_edge']\n\n        zebra = parent\n        self.index = index\n        self._zebra_prefix = zebra.prefix\n        self._edge_addr = self._edge_addrs[index]\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, parent=parent, **kwargs)"
  },
  {
    "class_name": "ZebraOutputBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraOutputBase(Device):\n    '''The base of all zebra outputs (1~8)\n\n        Front outputs\n        # TTL  LVDS  NIM  PECL  OC  ENC\n        1  o    o     o\n        2  o    o     o\n        3  o    o               o\n        4  o          o    o\n\n        Rear outputs\n        # TTL  LVDS  NIM  PECL  OC  ENC\n        5                            o\n        6                            o\n        7                            o\n        8                            o\n\n    '''\n    def __init__(self, prefix, *, index=None, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        self.index = index\n\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = list(self.component_names)  # _get_configuration_attrs(self.__class__)\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraOutputType",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraOutputType(Device):\n    '''Shared by all output types (ttl, lvds, nim, pecl, out)'''\n    addr = Cpt(ZebraSignalWithRBV, '')\n    status = Cpt(EpicsSignalRO, ':STA')\n    string = Cpt(EpicsSignalRO, ':STR', string=True)\n    sync = Cpt(EpicsSignal, ':SYNC')\n    write_output = Cpt(EpicsSignal, ':SET')\n\n    def __init__(self, prefix, *, read_attrs=None, configuration_attrs=None,\n                 **kwargs):\n        if read_attrs is None:\n            read_attrs = ['status']\n        if configuration_attrs is None:\n            configuration_attrs = ['addr']\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraEncoder",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraEncoder(Device):\n    motor_pos = FC(EpicsSignalRO, '{self._zebra_prefix}M{self.index}:RBV')\n    zebra_pos = FC(EpicsSignal, '{self._zebra_prefix}POS{self.index}_SET')\n    encoder_res = FC(EpicsSignal, '{self._zebra_prefix}M{self.index}:MRES')\n    encoder_off = FC(EpicsSignal, '{self._zebra_prefix}M{self.index}:OFF')\n    _copy_pos_signal = FC(EpicsSignal, '{self._zebra_prefix}M{self.index}:SETPOS.PROC')\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = ['encoder_res', 'encoder_off']\n\n        self.index = index\n        self._zebra_prefix = parent.prefix\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         parent=parent, **kwargs)\n\n    def copy_position(self):\n        self._copy_pos_signal.put(1, wait=True)"
  },
  {
    "class_name": "ZebraGateInput",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraGateInput(Device):\n    addr = Cpt(ZebraSignalWithRBV, '')\n    string = Cpt(EpicsSignalRO, ':STR', string=True)\n    status = Cpt(EpicsSignalRO, ':STA')\n    sync = Cpt(EpicsSignal, ':SYNC')\n    write_input = Cpt(EpicsSignal, ':SET')\n\n    # Input edge index depends on the gate number (these are set in __init__)\n    edge = FC(EpicsSignal,\n              '{self._zebra_prefix}POLARITY:B{self._input_edge_idx}')\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['status']\n        if configuration_attrs is None:\n            configuration_attrs = ['addr', 'edge']\n\n        gate = parent\n        zebra = gate.parent\n\n        self.index = index\n        self._zebra_prefix = zebra.prefix\n        self._input_edge_idx = gate._input_edge_idx[self.index]\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         parent=parent, **kwargs)"
  },
  {
    "class_name": "ZebraGate",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraGate(Device):\n    input1 = Cpt(ZebraGateInput, 'INP1', index=1)\n    input2 = Cpt(ZebraGateInput, 'INP2', index=2)\n    output = Cpt(EpicsSignal, 'OUT')\n\n    def __init__(self, prefix, *, index=None, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        self.index = index\n        self._input_edge_idx = {1: index - 1,\n                                2: 4 + index - 1\n                                }\n\n        if read_attrs is None:\n            read_attrs = ['output']\n        if configuration_attrs is None:\n            configuration_attrs = ['input1', 'input2']\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n\n    def set_input_edges(self, edge1, edge2):\n        set_and_wait(self.input1.edge, int(edge1))\n        set_and_wait(self.input2.edge, int(edge2))"
  },
  {
    "class_name": "ZebraPositionCaptureDeviceBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraPositionCaptureDeviceBase(Device):\n    source = Cpt(ZebraSignalWithRBV, 'SEL', put_complete=True)\n    input_addr = Cpt(ZebraSignalWithRBV, 'INP')\n    input_str = Cpt(EpicsSignalRO, 'INP:STR', string=True)\n    input_status = Cpt(EpicsSignalRO, 'INP:STA', auto_monitor=True)\n    output = Cpt(EpicsSignalRO, 'OUT', auto_monitor=True)\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n\n        if read_attrs is None:\n            read_attrs = []\n        read_attrs += ['input_status', 'output']\n\n        if configuration_attrs is None:\n            configuration_attrs = []\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraPositionCaptureData",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraPositionCaptureData(Device):\n    num_captured = Cpt(EpicsSignalRO, 'NUM_CAP')\n    num_downloaded = Cpt(EpicsSignalRO, 'NUM_DOWN')\n\n    time = Cpt(EpicsSignalRO, 'TIME')\n\n    enc1 = Cpt(EpicsSignalRO, 'ENC1')\n    enc2 = Cpt(EpicsSignalRO, 'ENC2')\n    enc3 = Cpt(EpicsSignalRO, 'ENC3')\n    enc4 = Cpt(EpicsSignalRO, 'ENC4')\n\n    sys1 = Cpt(EpicsSignalRO, 'SYS1')\n    sys2 = Cpt(EpicsSignalRO, 'SYS2')\n\n    div1 = Cpt(EpicsSignalRO, 'DIV1')\n    div2 = Cpt(EpicsSignalRO, 'DIV2')\n    div3 = Cpt(EpicsSignalRO, 'DIV3')\n    div4 = Cpt(EpicsSignalRO, 'DIV4')\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n\n        if read_attrs is None:\n            read_attrs = list(self.component_names)  # _get_configuration_attrs(self.__class__, signal_class=EpicsSignalRO)\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraPositionCapture",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraPositionCapture(Device):\n    source = Cpt(ZebraSignalWithRBV, 'ENC')\n    direction = Cpt(ZebraSignalWithRBV, 'DIR')\n    time_units = Cpt(ZebraSignalWithRBV, 'TSPRE')\n\n    arm = Cpt(ZebraPositionCaptureArm, 'ARM_')\n    gate = Cpt(ZebraPositionCaptureGate, 'GATE_')\n    pulse = Cpt(ZebraPositionCapturePulse, 'PULSE_')\n\n    capture_enc1 = Cpt(EpicsSignal, 'BIT_CAP:B0')\n    capture_enc2 = Cpt(EpicsSignal, 'BIT_CAP:B1')\n    capture_enc3 = Cpt(EpicsSignal, 'BIT_CAP:B2')\n    capture_enc4 = Cpt(EpicsSignal, 'BIT_CAP:B3')\n\n    capture_sys1 = Cpt(EpicsSignal, 'BIT_CAP:B4')\n    capture_sys2 = Cpt(EpicsSignal, 'BIT_CAP:B5')\n\n    capture_div1 = Cpt(EpicsSignal, 'BIT_CAP:B6')\n    capture_div2 = Cpt(EpicsSignal, 'BIT_CAP:B7')\n    capture_div3 = Cpt(EpicsSignal, 'BIT_CAP:B8')\n    capture_div4 = Cpt(EpicsSignal, 'BIT_CAP:B9')\n\n    data = Cpt(ZebraPositionCaptureData, '')\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n\n        if read_attrs is None:\n            read_attrs = ['data']\n        if configuration_attrs is None:\n            configuration_attrs = (\n                ['source', 'direction', 'time_units',\n                 'arm', 'gate', 'pulse'] +\n                [f'capture_enc{i}' for i in range(1,5)] +\n                [f'capture_sys{i}' for i in range(1,3)] +\n                [f'capture_div{i}' for i in range(1,5)]\n            )\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraBase(Device):\n    soft_input1 = Cpt(EpicsSignal, 'SOFT_IN:B0')\n    soft_input2 = Cpt(EpicsSignal, 'SOFT_IN:B1')\n    soft_input3 = Cpt(EpicsSignal, 'SOFT_IN:B2')\n    soft_input4 = Cpt(EpicsSignal, 'SOFT_IN:B3')\n\n    pulse1 = Cpt(ZebraPulse, 'PULSE1_', index=1)\n    pulse2 = Cpt(ZebraPulse, 'PULSE2_', index=2)\n    pulse3 = Cpt(ZebraPulse, 'PULSE3_', index=3)\n    pulse4 = Cpt(ZebraPulse, 'PULSE4_', index=4)\n\n    output1 = Cpt(ZebraFrontOutput12, 'OUT1_', index=1)\n    output2 = Cpt(ZebraFrontOutput12, 'OUT2_', index=2)\n    output3 = Cpt(ZebraFrontOutput3, 'OUT3_', index=3)\n    output4 = Cpt(ZebraFrontOutput4, 'OUT4_', index=4)\n\n    output5 = Cpt(ZebraRearOutput, 'OUT5_', index=5)\n    output6 = Cpt(ZebraRearOutput, 'OUT6_', index=6)\n    output7 = Cpt(ZebraRearOutput, 'OUT7_', index=7)\n    output8 = Cpt(ZebraRearOutput, 'OUT8_', index=8)\n\n    gate1 = Cpt(ZebraGate, 'GATE1_', index=1)\n    gate2 = Cpt(ZebraGate, 'GATE2_', index=2)\n    gate3 = Cpt(ZebraGate, 'GATE3_', index=3)\n    gate4 = Cpt(ZebraGate, 'GATE4_', index=4)\n\n    encoder1 = Cpt(ZebraEncoder, '', index=1)\n    encoder2 = Cpt(ZebraEncoder, '', index=2)\n    encoder3 = Cpt(ZebraEncoder, '', index=3)\n    encoder4 = Cpt(ZebraEncoder, '', index=4)\n\n    pos_capt = Cpt(ZebraPositionCapture, 'PC_')\n    download_status = Cpt(EpicsSignalRO, 'ARRAY_ACQ')\n    reset = Cpt(EpicsSignal, 'SYS_RESET.PROC')\n\n    addresses = ZebraAddresses\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = (\n                [f'soft_input{i}' for i in range(1,5)] +\n                [f'pulse{i}' for i in range(1,5)] +\n                [f'output{i}' for i in range(1,9)] +\n                [f'gate{i}' for i in range(1,5)] +\n                [f'encoder{i}' for i in range(1,5)] +\n                ['pos_capt']\n            )\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n\n        self.pulse = dict(self._get_indexed_devices(ZebraPulse))\n        self.output = dict(self._get_indexed_devices(ZebraOutputBase))\n        self.gate = dict(self._get_indexed_devices(ZebraGate))\n        self.encoder = dict(self._get_indexed_devices(ZebraEncoder))\n\n    def _get_indexed_devices(self, cls):\n        for attr in self._sub_devices:\n            dev = getattr(self, attr)\n            if isinstance(dev, cls):\n                yield dev.index, dev\n\n    def trigger(self):\n        # Re-implement this to trigger as desired in bluesky\n        status = DeviceStatus(self)\n        status._finished()\n        return status"
  },
  {
    "class_name": "ZebraArmSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraArmSignalWithRBV(EpicsSignal):\n        def __init__(self, prefix, **kwargs):\n            super().__init__(prefix + 'ARM_OUT', write_pv=prefix+'ARM', **kwargs)"
  },
  {
    "class_name": "ZebraDisarmSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/25-zebra.py",
    "source": "class ZebraDisarmSignalWithRBV(EpicsSignal):\n        def __init__(self, prefix, **kwargs):\n            super().__init__(prefix + 'ARM_OUT', write_pv=prefix+'DISARM', **kwargs)"
  },
  {
    "class_name": "TestMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class TestMotor(Device):\n    e = Cpt(EpicsMotor, \"-Ax:E}Mtr\")\n    f = Cpt(EpicsMotor, \"-Ax:F}Mtr\")\n    ctr = Cpt(EpicsMotor, \"-Ax:XCtr}Mtr\")\n    gap = Cpt(EpicsMotor, \"-Ax:XGap}Mtr\")"
  },
  {
    "class_name": "XYMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class XYMotor(Device):\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    y = Cpt(EpicsMotor, \"-Ax:Y}Mtr\")"
  },
  {
    "class_name": "Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class Slits(Device):\n    b = Cpt(EpicsMotor, \"-Ax:B}Mtr\")\n    i = Cpt(EpicsMotor, \"-Ax:I}Mtr\")\n    o = Cpt(EpicsMotor, \"-Ax:O}Mtr\")\n    t = Cpt(EpicsMotor, \"-Ax:T}Mtr\")\n    x_ctr = Cpt(EpicsMotor, \"-Ax:XCtr}Mtr\")\n    x_gap = Cpt(EpicsMotor, \"-Ax:XGap}Mtr\")\n    y_ctr = Cpt(EpicsMotor, \"-Ax:YCtr}Mtr\")\n    y_gap = Cpt(EpicsMotor, \"-Ax:YGap}Mtr\")"
  },
  {
    "class_name": "DCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class DCM(Device):\n    # Virtual Motor\n    energy = Cpt(EpicsMotor, \"-Ax:E}Mtr\")\n    c2_bnd = Cpt(EpicsMotor, \"-Ax:C2Bnd}Mtr\")\n    fine_pitch = Cpt(EpicsMotor, \"-Ax:FP}Mtr\")\n    fine_roll = Cpt(EpicsMotor, \"-Ax:FR}Mtr\")\n\n    # Real Motors\n    bragg = Cpt(EpicsMotor, \"-Ax:B}Mtr\")\n    perp = Cpt(EpicsMotor, \"-Ax:Perp}Mtr\")\n    para = Cpt(EpicsMotor, \"-Ax:Para}Mtr\")\n    pitch = Cpt(EpicsMotor, \"-Ax:P}Mtr\")\n    roll = Cpt(EpicsMotor, \"-Ax:R}Mtr\")\n    yaw = Cpt(EpicsMotor, \"-Ax:Yaw}Mtr\")\n    c2_bnd1 = Cpt(EpicsMotor, \"-Ax:Bnd1}Mtr\")\n    c2_bnd2 = Cpt(EpicsMotor, \"-Ax:Bnd2}Mtr\")\n    c1_bnd = Cpt(EpicsMotor, \"-Ax:Bnd}Mtr\")"
  },
  {
    "class_name": "Mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class Mirror(Device):\n    y = Cpt(EpicsMotor, \"-Ax:Y}Mtr\")\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    p = Cpt(EpicsMotor, \"-Ax:P}Mtr\")\n    r = Cpt(EpicsMotor, \"-Ax:R}Mtr\")\n    bnd1 = Cpt(EpicsMotor, \"-Ax:Bnd1}Mtr\")\n    bnd2 = Cpt(EpicsMotor, \"-Ax:Bnd2}Mtr\")"
  },
  {
    "class_name": "SampleCam",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class SampleCam(Device):\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    z = Cpt(EpicsMotor, \"-Ax:Z}Mtr\")\n    focus = Cpt(EpicsMotor, \"-Ax:F}Mtr\")"
  },
  {
    "class_name": "BeamPipe",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class BeamPipe(Device):\n    pitch = Cpt(EpicsMotor, \"-Ax:P\")"
  },
  {
    "class_name": "Global",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class Global(Device):\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    yaw = Cpt(EpicsMotor, \"-Ax:Yaw}Mtr\")"
  },
  {
    "class_name": "Goniometer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class Goniometer(Device):\n    omega = Cpt(EpicsMotor, \"-Ax:O}Mtr\")\n    vert = Cpt(EpicsMotor, \"-Ax:V}Mtr\")\n    x = Cpt(EpicsMotor, \"-Ax:X}Mtr\")\n    y = Cpt(EpicsMotor, \"-Ax:Y}Mtr\")\n    z = Cpt(EpicsMotor, \"-Ax:Z}Mtr\")\n    kappa = Cpt(EpicsMotor, \"-Ax:K}Mtr\")"
  },
  {
    "class_name": "Optic",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class Optic(Device):\n    vert = Cpt(EpicsMotor, \"-Ax:V}Mtr\")"
  },
  {
    "class_name": "BeamStop",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class BeamStop(Device):\n    vert = Cpt(EpicsMotor, \"-Ax:V}Mtr\")\n    horiz = Cpt(EpicsMotor, \"-Ax:H}Mtr\")\n    z = Cpt(EpicsMotor, \"-Ax:Z}Mtr\")"
  },
  {
    "class_name": "Table",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class Table(Device):\n    vctr = Cpt(EpicsMotor, \"-Ax:VCtr}Mtr\")\n    vo = Cpt(EpicsMotor, \"-Ax:VO}Mtr\")\n    vi = Cpt(EpicsMotor, \"-Ax:VI}Mtr\")\n    hu = Cpt(EpicsMotor, \"-Ax:HU}Mtr\")\n    hd = Cpt(EpicsMotor, \"-Ax:HD}Mtr\")"
  },
  {
    "class_name": "Detector",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class Detector(Device):\n    z = Cpt(EpicsMotor, \"-Ax:Z}Mtr\")"
  },
  {
    "class_name": "Robot",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/nyx-profile-collection/startup/10-motors.py",
    "source": "class Robot(Device):\n    lid = Cpt(EpicsMotor, \"-Ax:Lid}Mtr\")"
  },
  {
    "class_name": "FastShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/esm.py",
    "source": "class FastShutter(Device):\n    OPEN_SHUTTER = \"open\"\n    CLOSE_SHUTTER = \"closed\"\n    SETTLE_TIME = 0.1  # seconds\n    output = Cpt(EpicsSignal,'{shutter:1}sts', string=True, put_complete=True)\n\n    def open(self):\n        self.output.set(FastShutter.OPEN_SHUTTER, settle_time=FastShutter.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(FastShutter.CLOSE_SHUTTER, settle_time=FastShutter.SETTLE_TIME)"
  },
  {
    "class_name": "Scintillator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/esm.py",
    "source": "class Scintillator(Device):\n    OPEN_SHUTTER = \"open\"\n    CLOSE_SHUTTER = \"closed\"\n    SETTLE_TIME = 0.1  # seconds\n    output = Cpt(EpicsSignal,'{shutter:2}sts', string=True, put_complete=True)\n\n    def open(self):\n        self.output.set(Scintillator.OPEN_SHUTTER, settle_time=Scintillator.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(Scintillator.CLOSE_SHUTTER, settle_time=Scintillator.SETTLE_TIME)"
  },
  {
    "class_name": "PhotonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/esm.py",
    "source": "class PhotonShutter(Device):\n    OPEN_SHUTTER = \"Open\"\n    CLOSE_SHUTTER = \"Not Open\"\n    output = Cpt(EpicsSignal, '{PSh}Pos-Sts', string=True, put_complete=True)\n    \n    def open(self):\n        self.output.set(Scintillator.OPEN_SHUTTER)\n        \n    def close(self):\n        self.output.set(Scintillator.CLOSE_SHUTTER)"
  },
  {
    "class_name": "FastShutter2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/esm.py",
    "source": "class FastShutter2(Device):\n    OPEN_SHUTTER = \"Force High\"\n    CLOSE_SHUTTER = \"Force Low\"\n    SETTLE_TIME = 0.1  # seconds\n    delay = Cpt(EpicsSignal, '-DlyGen:0}Delay-SP')\n    width = Cpt(EpicsSignal, '-DlyGen:0}Width-SP')\n    output = Cpt(EpicsSignal,'-Out:FP0}Src:Scale-SP', string=True, put_complete=True)\n\n    \n    def open(self):\n        self.output.set(FastShutter2.OPEN_SHUTTER, settle_time=FastShutter2.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(FastShutter2.CLOSE_SHUTTER, settle_time=FastShutter2.SETTLE_TIME)"
  },
  {
    "class_name": "FastShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/40-ESM_plans_elio.py",
    "source": "class FastShutter(Device):\n    OPEN_SHUTTER = \"open\"\n    CLOSE_SHUTTER = \"closed\"\n    SETTLE_TIME = 0.1  # seconds\n    output = Cpt(EpicsSignal,'{shutter:1}sts', string=True, put_complete=True)\n\n    def open(self):\n        self.output.set(FastShutter.OPEN_SHUTTER, settle_time=FastShutter.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(FastShutter.CLOSE_SHUTTER, settle_time=FastShutter.SETTLE_TIME)"
  },
  {
    "class_name": "Scintillator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/40-ESM_plans_elio.py",
    "source": "class Scintillator(Device):\n    OPEN_SHUTTER = \"open\"\n    CLOSE_SHUTTER = \"closed\"\n    SETTLE_TIME = 0.1  # seconds\n    output = Cpt(EpicsSignal,'{shutter:2}sts', string=True, put_complete=True)\n\n    def open(self):\n        self.output.set(Scintillator.OPEN_SHUTTER, settle_time=Scintillator.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(Scintillator.CLOSE_SHUTTER, settle_time=Scintillator.SETTLE_TIME)"
  },
  {
    "class_name": "PhotonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/40-ESM_plans_elio.py",
    "source": "class PhotonShutter(Device):\n    OPEN_SHUTTER = \"Open\"\n    CLOSE_SHUTTER = \"Not Open\"\n    output = Cpt(EpicsSignal, '{PSh}Pos-Sts', string=True, put_complete=True)\n    \n    def open(self):\n        self.output.set(Scintillator.OPEN_SHUTTER)\n        \n    def close(self):\n        self.output.set(Scintillator.CLOSE_SHUTTER)"
  },
  {
    "class_name": "FastShutter2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/40-ESM_plans_elio.py",
    "source": "class FastShutter2(Device):\n    OPEN_SHUTTER = \"Force High\"\n    CLOSE_SHUTTER = \"Force Low\"\n    SETTLE_TIME = 0.1  # seconds\n    delay = Cpt(EpicsSignal, '-DlyGen:0}Delay-SP')\n    width = Cpt(EpicsSignal, '-DlyGen:0}Width-SP')\n    output = Cpt(EpicsSignal,'-Out:FP0}Src:Scale-SP', string=True, put_complete=True)\n\n    \n    def open(self):\n        self.output.set(FastShutter2.OPEN_SHUTTER, settle_time=FastShutter2.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(FastShutter2.CLOSE_SHUTTER, settle_time=FastShutter2.SETTLE_TIME)"
  },
  {
    "class_name": "Pol_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class Pol_mtr(Device):\n    Rz = Comp(EpicsMotor,'Mtr', kind='hinted')"
  },
  {
    "class_name": "LL_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class LL_mtr(Device):\n    Claw_Trans = Comp(EpicsMotor,'2-Claw:EA3_1-Ax:T}Mtr', kind='hinted')\n    Claw_Rotate = Comp(EpicsMotor,'2-Claw:EA3_1-Ax:R}Mtr', kind='hinted')\n    Claw_Grab = Comp(EpicsMotor,'2-Claw:EA3_1-Ax:C}Mtr', kind='hinted')\n    Dock_Trans = Comp(EpicsMotor,'1-Dock:EA4_1-Ax:F}Mtr', kind='hinted')"
  },
  {
    "class_name": "SP_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class SP_mtr(Device):\n    X = Comp(EpicsMotor,\"-Ax:X}Mtr\", kind='hinted')\n    Y = Comp(EpicsMotor,\"-Ax:Y}Mtr\", kind='hinted')\n    Z = Comp(EpicsMotor,\"-Ax:Z}Mtr\", kind='hinted')\n    Rx = Comp(EpicsMotor,\"-Ax:Rx}Mtr\", kind='hinted')"
  },
  {
    "class_name": "An_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class An_mtr(Device):\n\n    #Add micro-scanning stage motors here when done\n    Claw_Trans = Comp(EpicsMotor,\"{ST:1-Claw:EA1_1-Ax:T}Mtr\", kind='hinted')\n    Claw_Grab = Comp(EpicsMotor,\"{ST:1-Claw:EA1_1-Ax:C}Mtr\", kind='hinted')"
  },
  {
    "class_name": "Analyzer_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class Analyzer_mtr(Device):\n    Rz = Comp(EpicsMotor,\"{SA:1-DPRF:EA1_1-Ax:1}Mtr\", kind='hinted')"
  },
  {
    "class_name": "M1_mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class M1_mirror(Device):\n    X = Comp(EpicsMotor,\"Trans}Mtr\", kind='hinted')\n    Mirror_Trans = Comp(EpicsMotor,\"Trans}Mtr\")\n    Mirror_InOut = Comp(EpicsMotor,\"Trans}Mtr\")\n    Ry = Comp(EpicsMotor,\"Pitch}Mtr\", kind='hinted')\n    Mirror_Pitch = Comp(EpicsMotor,\"Pitch}Mtr\")\n    Rz = Comp(EpicsMotor,\"Roll}Mtr\", kind='hinted')\n    Mirror_Roll = Comp(EpicsMotor,\"Roll}Mtr\")"
  },
  {
    "class_name": "Hexapod_Mir",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class Hexapod_Mir(Device):\n    X = Comp(EpicsMotor,\"_X}Mtr\", kind='hinted')\n    Mirror_Trans = Comp(EpicsMotor,\"_X}Mtr\")\n    Mirror_InOut = Comp(EpicsMotor,\"_X}Mtr\")\n    Y = Comp(EpicsMotor,\"_Y}Mtr\", kind='hinted')\n    Mirror_Stripe = Comp(EpicsMotor,\"_Y}Mtr\")\n    Mirror_Exchange = Comp(EpicsMotor,\"_Y}Mtr\")\n    Z = Comp(EpicsMotor,\"_Z}Mtr\", kind='hinted')\n    Rx = Comp(EpicsMotor,\"_Rx}Mtr\", kind='hinted')\n    Mirror_Roll = Comp(EpicsMotor,\"_Rz}Mtr\")\n    Ry = Comp(EpicsMotor,\"_Ry}Mtr\", kind='hinted')\n    Mirror_Pitch = Comp(EpicsMotor,\"_Ry}Mtr\")\n    Rz = Comp(EpicsMotor,\"_Rz}Mtr\", kind='hinted')\n    Mirror_Yaw = Comp(EpicsMotor,\"_Rx}Mtr\")"
  },
  {
    "class_name": "Monochromator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class Monochromator(Device):\n    Focus_Const = Comp(EpicsMotor,\"-Ax:8_Cff}Mtr\", kind='hinted')\n    Energy = Comp(EpicsMotor,\"-Ax:8_Eng}Mtr\", kind='hinted')\n    Grating_Trans = Comp(EpicsMotor,\"-Ax:8_GT}Mtr\")\n    Mirror_Pitch = Comp(EpicsMotor,\"-Ax:8_MP}Mtr\")\n    Mirror_Pitch_off = Comp(EpicsSignal,\"-Ax:8_MP}Mtr.OFF\")\n    Mirror_Pitch_set = Comp(EpicsSignal,\"-Ax:8_MP}Mtr.SET\")\n    Mirror_Pitch_kill = Comp(EpicsSignal, \"-Ax:8_MP}Cmd:Kill-Cmd\")\n    Grating_Pitch = Comp(EpicsMotor,\"-Ax:8_GP}Mtr\")\n    Grating_Pitch_off = Comp(EpicsSignal,\"-Ax:8_GP}Mtr.OFF\")\n    Grating_Pitch_set = Comp(EpicsSignal,\"-Ax:8_GP}Mtr.SET\")\n    Grating_Pitch_kill = Comp(EpicsSignal, \"-Ax:8_GP}Cmd:Kill-Cmd\")\n    Grating_lines = Comp(EpicsSignal,\"}:LINES:RBV\",write_pv=\"}:LINES:SET\",put_complete=False, kind='hinted')"
  },
  {
    "class_name": "EpicsSignalLastElement",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class EpicsSignalLastElement(EpicsSignal):\n    def get(self):\n        return float(super().get()[-1])"
  },
  {
    "class_name": "BEST_Xaxis",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class BEST_Xaxis(Device):\n    def __init__(self,*args,**kwargs):\n        super().__init__(*args,**kwargs)\n        self.readback.name = self.name\n\n    readback = Comp(EpicsSignalLastElement,\"FM}:BPM0:PosX\", kind='hinted')  # Make these EpicsSignal, 'PV:...'\n    setpoint = Comp(EpicsSignal,\"FM}:PID:SetpointX\")\n    tolerance = 0.1\n\n        \n    # Define the class properties here\n    @property\n    def read_val(self):\n        return self.get()\n\n    @property\n    def hints(self):\n        return{'fields':[self.readback.name]}\n\n    \n    def set(self, value):\n        desired_value = value\n        status = DeviceStatus(self)\n\n        def are_we_there_yet(value, *args, **kwargs):\n            if abs(value[-1] - desired_value) < self.tolerance:\n                # This alerts the RunEngine that it can move on.\n                status._finished()\n\n        # Start us moving.\n        self.setpoint.put(desired_value)\n        # The function are_we_there_yet will receive\n        # updates from pyepics as the readback changes.\n        self.readback.subscribe(are_we_there_yet)\n        # Hand this back the RunEngine immediately.\n        return status"
  },
  {
    "class_name": "BEST_Yaxis",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class BEST_Yaxis(Device):\n    def __init__(self,*args,**kwargs):\n        super().__init__(*args,**kwargs)\n        self.readback.name = self.name\n\n    readback = Comp(EpicsSignalLastElement,\"FM}:BPM0:PosY\", kind='hinted')  # Make these EpicsSignal, 'PV:...'\n    setpoint = Comp(EpicsSignal,\"FM}:PID:SetpointY\")\n    tolerance = 0.1\n\n    def set(self, value):\n        desired_value = value\n        status = DeviceStatus(self)\n\n        def are_we_there_yet(value, *args, **kwargs):\n            if abs(value[-1] - desired_value) < self.tolerance:\n                # This alerts the RunEngine that it can move on.\n                status._finished()\n\n        # Start us moving.\n        self.setpoint.put(desired_value)\n        # The function are_we_there_yet will receive\n        # updates from pyepics as the readback changes.\n        self.readback.subscribe(are_we_there_yet)\n        # Hand this back the RunEngine immediately.\n        return status"
  },
  {
    "class_name": "KB_pair",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class KB_pair(Device):\n    VFM_Y = Comp(EpicsMotor,\"Ax:A4_VFMTy}Mtr\", kind='hinted')\n    VFM_Mirror_InOut = Comp(EpicsMotor,\"Ax:A4_VFMTy}Mtr\")\n    VFM_Mirror_Trans = Comp(EpicsMotor,\"Ax:A4_VFMTy}Mtr\")\n    VFM_Z = Comp(EpicsMotor,\"Ax:A4_VFMTz}Mtr\", kind='hinted')\n    VFM_Mirror_Astig = Comp(EpicsMotor,\"Ax:A4_VFMTz}Mtr\")\n    VFM_Mirror_Horizontal = Comp(EpicsMotor,\"Ax:A4_VFM_Astig}Mtr\")\n    VFM_Mirror_Incline = Comp(EpicsMotor,\"Ax:A4_VFM_IO}Mtr\")\n\n    HFM_Z = Comp(EpicsMotor,\"Ax:A4_HFM_Astig}Mtr\", kind='hinted')\n    HFM_X = Comp(EpicsMotor,\"Ax:A4_HFM_IO}Mtr\", kind='hinted')\n    HFM_Mirror_Astig = Comp(EpicsMotor,\"Ax:A4_HFM_Astig}Mtr\")\n    HFM_Mirror_InOut = Comp(EpicsMotor,\"Ax:A4_HFM_IO}Mtr\")\n    HFM_Mirror_Trans = Comp(EpicsMotor,\"Ax:A4_HFM_IO}Mtr\")\n\n    HFM_Au_Mesh = Comp(EpicsMotor,\"Ax:A4_HGM}Mtr\")\n    VFM_Au_Mesh = Comp(EpicsMotor,\"Ax:A4_VGM}Mtr\")\n\n    VFM_Rx = Comp(BEST_Xaxis,\"\", kind='hinted')\n    VFM_Pitch = Comp(BEST_Xaxis,\"\")\n    HFM_Ry = Comp(BEST_Yaxis,\"\", kind='hinted')\n    HFM_Pitch = Comp(BEST_Yaxis,\"\")"
  },
  {
    "class_name": "ESM_Diagon",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class ESM_Diagon(Device):\n    H_mirror = Comp(EpicsMotor,\"-Ax:3_HLPM}Mtr\", kind='hinted')\n    H_Yag = Comp(EpicsMotor,\"-Ax:3_HLPF}Mtr\", kind='hinted')\n    V_mirror = Comp(EpicsMotor,\"-Ax:3_VLPM}Mtr\", kind='hinted')\n    V_Yag = Comp(EpicsMotor,\"-Ax:3_VLPF}Mtr\", kind='hinted')"
  },
  {
    "class_name": "ESMSlit_type1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class ESMSlit_type1(Device):\n    inboard = Comp(EpicsMotor,\"-Ax:I}Mtr\")\n    outboard = Comp(EpicsMotor,\"-Ax:O}Mtr\")\n    bottom = Comp(EpicsMotor,\"-Ax:B}Mtr\")\n    top = Comp(EpicsMotor,\"-Ax:T}Mtr\")\n    h_gap = Comp(EpicsMotor,\"-Ax:HG}Mtr\", kind='hinted')\n    h_center = Comp(EpicsMotor,\"-Ax:HC}Mtr\", kind='hinted')\n    v_gap = Comp(EpicsMotor,\"-Ax:VG}Mtr\", kind='hinted')\n    v_center = Comp(EpicsMotor,\"-Ax:VC}Mtr\", kind='hinted')"
  },
  {
    "class_name": "ESMSlit_type2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class ESMSlit_type2(Device):\n    h_scan = Comp(EpicsMotor,\"-Ax:HS}Mtr\")\n    h_apperture = Comp(EpicsMotor,\"-Ax:HA}Mtr\")\n    v_scan = Comp(EpicsMotor,\"-Ax:VS}Mtr\")\n    v_apperture = Comp(EpicsMotor,\"-Ax:VA}Mtr\")\n    h_gap = Comp(EpicsMotor,\"-Ax:HG}Mtr\", kind='hinted')\n    h_center = Comp(EpicsMotor,\"-Ax:HC}Mtr\", kind='hinted')\n    v_gap = Comp(EpicsMotor,\"-Ax:VG}Mtr\", kind='hinted')\n    v_center = Comp(EpicsMotor,\"-Ax:VC}Mtr\", kind='hinted')"
  },
  {
    "class_name": "ExitSlit",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class ExitSlit(Device):\n    v_gap = Comp(EpicsMotor,\"_VG}Mtr\")\n    h_gap = Comp(EpicsMotor,\"_HG}Mtr\", kind='hinted')\n    h_def = Comp(EpicsMotor,\"_HDS}Mtr\")\n    v_def = Comp(EpicsMotor,\"_VDS}Mtr\", kind='hinted')"
  },
  {
    "class_name": "DIAG",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class DIAG(Device):\n    trans = Comp(EpicsMotor,\"}Mtr\", kind='hinted')"
  },
  {
    "class_name": "Virtual_Motor_Center_And_Gap",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class Virtual_Motor_Center_And_Gap(Device):\n#This is used to combine the gap centre and size classes from above into a single class object\n    h_gap = Comp(Virtual_Size,'12-Ax:X}', kind='hinted')\n    h_center = Comp(Virtual_Center,'12-Ax:X}', kind='hinted')\n    v_gap = Comp(Virtual_Size,'12-Ax:Y}', kind='hinted')\n    v_center = Comp(Virtual_Center,'12-Ax:Y}', kind='hinted')"
  },
  {
    "class_name": "Blades",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/10-machine.py",
    "source": "class Blades(Device):\n#This creates a class for the independent motion of each of the front end slit \"blades\"\n    outboard = Comp(EpicsMotor, \"1-Ax:O}Mtr\")\n    inboard = Comp(EpicsMotor, \"2-Ax:I}Mtr\")\n    top = Comp(EpicsMotor, \"1-Ax:T}Mtr\")\n    bottom = Comp(EpicsMotor, \"2-Ax:B}Mtr\")"
  },
  {
    "class_name": "EPU",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/11-undulator.py",
    "source": "class EPU(Device):\n    gap = Cpt(UgapPositioner, '', settle_time=0, kind='hinted')\n    phase = Cpt(UphasePositioner, '', settle_time=0, kind='hinted')"
  },
  {
    "class_name": "Source",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/11-undulator.py",
    "source": "class Source(Device):\n    #This is a class to be used to define the readback values of the beam source front the\n    #front end.\n\n        #define the channels in the readback device.\n        Current=Comp(EpicsSignalRO,'OPS-BI{DCCT:1}I:Real-I', kind='hinted')\n        Xoffset=Comp(EpicsSignalRO,'C31-{AI}Aie21:Offset-x-Cal', kind='hinted')\n        Xangle=Comp(EpicsSignalRO,'C31-{AI}Aie21:Angle-x-Cal', kind='hinted')\n        Yoffset=Comp(EpicsSignalRO,'C31-{AI}Aie21:Offset-y-Cal', kind='hinted')\n        Yangle=Comp(EpicsSignalRO,'C31-{AI}Aie21:Angle-y-Cal', kind='hinted')\n\n        def status(self, output='string'):\n            '''\n            Reads the status of every axis defined for the device and outputs the result as a dictioanry or a\n            formatted string.\n\n            Reads the position of every axis for the device and returns a dictionary, returns a formatted string\n            or appends to a file.\n\n            PARAMETERS\n            ----------\n\n            output : str, optional\n                Indicates what to do with the output, default is to return a formatted string. Can take the values:\n                    - 'string', indicates the routine should return a formatted string.\n                    - 'string_and_file', indicates the routine should return a formatted string and append to a\n                       status file for the device.\n                    - 'dict', indicates the routine should return a dictionary of positions.\n\n            f_string : str\n                Possible output string for formatting.\n\n            status_dict : dict\n                Possible outputted dictionary, which has keywords for each motor in the axis list and contains\n                a dictionary of axes names and positions.\n\n            '''\n            #Define the list of EPICS signal status values.\n            det_status_dict={}\n            det_status_dict[self.name]={self.name+'_Current':self.Current.get(),\n                                        self.name+'_Xoffset':self.Xoffset.get(),\n                                        self.name+'_Xangle':self.Xangle.get(),\n                                        self.name+'_Yoffset':self.Yoffset.get(),\n                                        self.name+'_Yangle':self.Yangle.get()}\n\n            #Define the list of EPICS motor status values.\n            status_dict={}\n            status_dict['EPU_105']={'EPU105_gap':EPU105.gap.position,\n                                    'EPU105_phase':EPU105.phase.position}\n\n            status_dict['EPU57']={'EPU57_gap':EPU57.gap.position,\n                                  'EPU57_phase':EPU57.phase.position}\n\n            status_dict['FEslit']={'FEslit_h_center':FEslit.h_center.position,\n                                 'FEslit_h_gap':FEslit.h_gap.position,\n                                 'FEslit_v_center':FEslit.v_center.position,\n                                 'FEslit_v_gap':FEslit.v_gap.position}\n\n            f_string='************************************************************\\n'\n            f_string+=self.name+' STATUS:  '+time.strftime(\"%c\") + '\\n'\n            f_string+='************************************************************\\n\\n'\n\n            #step through the detectors and read the values.\n            f_string+='EPICS SIGNAL COMPONENTS\\n'\n            f_string+='-----------------------\\n'\n            for key in list(det_status_dict.keys()):\n                f_string+='    '+key+':\\n'\n                key_dict = det_status_dict[key]\n                for det in key_dict:\n                    obj,_,attr = det.partition('_')\n                    f_string+='\\t '+det+' -->  %f\\n' % getattr(ip.user_ns[obj],attr).get()\n                f_string+='\\n'\n\n            # step through the motors and read the values\n            f_string+='EPICS MOTOR COMPONENTS\\n'\n            f_string+='-----------------------\\n'\n            for key in list(status_dict.keys()):\n                f_string+='    '+key+':\\n'\n                key_dict = status_dict[key]\n                for axis in key_dict:\n                    obj,_,attr = axis.partition('_')\n                    f_string+='\\t '+axis+' -->  %f\\n' % getattr(ip.user_ns[obj],attr).position\n                    f_string+='\\n'\n\n            if output.startswith('string'):\n                print (f_string)\n\n            if output.endswith('file'):\n                fl=\"/direct/XF21ID1/status_files/\"\n                fl+=self.name+'_status'\n                f = open(fl, \"a\")\n                f.write(f_string)\n                f.close()\n\n            if output == 'dict':\n                return status_dict"
  },
  {
    "class_name": "LEEMDetector",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-xpeem-profile-collection/startup/46-ESM_LEEM.py",
    "source": "class LEEMDetector(Device):\n    acquire = Cpt(EpicsSignal, 'start_acq')\n    fileinc = Cpt(EpicsSignal, 'fileinc')\n    filepath = Cpt(EpicsSignal, 'filepath')\n    filename = Cpt(EpicsSignal, 'filename')\n\n#    def __init__(self, *args, **kwargs):\n#        super().__init__(*args, **kwargs)\n        # On a background thread, listen for the server's response.\n#        self.st = None\n\n    def trigger(self):\n        status = DeviceStatus(self)\n        # Write to server.\n        def check_if_done(old_value, value, **kwargs):\n            if value == 0 and old_value == 1:\n                status._finished()\n                self.acquire.clear_sub(check_if_done)\n\n        self.acquire.subscribe(check_if_done, run=False)\n        self.acquire.put(1)\n        return status"
  },
  {
    "class_name": "ScalerMCA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/90-softGluescalar.py",
    "source": "class ScalerMCA(Device):\n    _default_read_attrs = (\"channels\", \"current_channel\")\n    _default_configuration_attrs = (\"nuse\", \"prescale\")\n\n    # things to be read as data\n    channels = DDC({f\"mca{k:02d}\": (EpicsSignal, f\"mca{k}\", {}) for k in range(1, 21)})\n    current_channel = C(EpicsSignal, \"CurrentChannel\")\n    # configuration details\n    nuse = C(EpicsSignal, \"NuseAll\", kind=\"config\")\n    prescale = C(EpicsSignal, \"Prescale\", kind=\"config\")\n    channel_advance = C(EpicsSignal, \"ChannelAdvance\")\n\n    # control PVs\n\n    # high is acquiring\n    with kind_context(\"omitted\") as Co:\n        status = Co(EpicsSignal, \"Acquiring\", string=True)\n        startall = Co(EpicsSignal, \"StartAll\", string=True)\n        stopall = Co(EpicsSignal, \"StopAll\", string=True)\n        eraseall = Co(EpicsSignal, \"EraseAll\", string=True)\n        erasestart = Co(EpicsSignal, \"EraseStart\", string=True)\n\n    def stage(self):\n        staged_cmpts = super().stage()\n        self.eraseall.put(\"Erase\")\n        return staged_cmpts\n\n    def stop(self):\n        self.stopall.put(\"Stop\")\n\n    def trigger(self):\n        self.erasestart.put(\"Erase\")\n\n        return StatusBase(done=True, success=True)\n\n    def read(self):\n        # TODO handle file writing and document generation\n        return super().read()"
  },
  {
    "class_name": "Scaler",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/90-softGluescalar.py",
    "source": "class Scaler(Device):\n    # MCAs\n    mcas = C(ScalerMCA, \"\")\n    # TODO maybe an issue with the timing around the triggering?\n    cnts = C(FixedScalerCH, \"scaler1\")\n\n    def __init__(self, *args, mode=\"counting\", **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_mode(mode)\n\n    def match_names(self, N=20):\n        self.cnts.match_names()\n        for j in range(1, N + 1):\n            mca_ch = getattr(self.mcas.channels, f\"mca{j:02d}\")\n            ct_ch = getattr(self.cnts.channels, f\"chan{j:02d}\")\n            mca_ch.name = ct_ch.chname.get()\n\n    # TODO put a soft signal around this so we can stage it\n    def set_mode(self, mode):\n        if mode == \"counting\":\n            self.read_attrs = [\"cnts\"]\n            self.configuration_attrs = [\"cnts\"]\n        elif mode == \"flying\":\n            self.read_attrs = [\"mcas\"]\n            self.configuration_attrs = [\"mcas\"]\n        else:\n            raise ValueError\n\n        self._mode = mode\n\n    def trigger(self):\n        if self._mode == \"counting\":\n            return self.cnts.trigger()\n        elif self._mode == \"flying\":\n            return self.mcas.trigger()\n        else:\n            raise ValueError\n\n    def stage(self):\n        if self._mode == \"counting\":\n            staged_cmpts = self.cnts.stage()\n        elif self._mode == \"flying\":\n            staged_cmpts = self.mcas.stage()\n        else:\n            raise ValueError\n        self.match_names()\n        return staged_cmpts\n\n    def unstage(self):\n        if self._mode == \"counting\":\n            unstaged_cmpts = self.cnts.unstage()\n        elif self._mode == \"flying\":\n            unstaged_cmpts = self.mcas.unstage()\n        else:\n            raise ValueError\n        self.match_names()\n        return unstaged_cmpts"
  },
  {
    "class_name": "NanoSignal",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/02-nanops.py",
    "source": "class NanoSignal(Device):\n    svolt = Cpt(EpicsSignalRO, 'scan_volt_RBV', name = 'svolt')\n    svoltscan = Cpt(EpicsSignal, 'scan_volt_RBV.SCAN', name = 'svoltscan')\n    noslip = Cpt(EpicsSignal, 'noslip_tog_RBV', name = 'noslip', write_pv = 'noslip_tog')\n    # 20210216 added following John's idea of checking the temperatures as\n    # a potential reason for periodic and unpredictable jumps during meshes\n    temp = Cpt(EpicsSignalRO, 'Ch_Temp', name = 'temp')"
  },
  {
    "class_name": "NanoBundleSignal",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/02-nanops.py",
    "source": "class NanoBundleSignal(Device):\n    tx = Cpt(NanoSignal, 'TopX}')\n    ty = Cpt(NanoSignal, 'TopY}')\n    tz = Cpt(NanoSignal, 'TopZ}')\n    bx = Cpt(NanoSignal, 'BtmX}')\n    by = Cpt(NanoSignal, 'BtmY}')\n    bz = Cpt(NanoSignal, 'BtmZ}')"
  },
  {
    "class_name": "MotorPairX",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/02-nanops.py",
    "source": "class MotorPairX(Device):\n    tx = Cpt(NanoMotorWithGentleStop, nanop.tx.prefix)\n    bx = Cpt(NanoMotorWithGentleStop, nanop.bx.prefix)\n    def __init__(self, *args, **kwargs):\n        \"\"\"A bundle device to move a pair of motors to the same distance\"\"\"\n        super().__init__(*args, **kwargs)\n        self.update_diff()\n\n    def update_diff(self):\n        self.diff = self.tx.user_readback.get() - self.bx.user_readback.get()\n\n    def set(self, value):\n        st_leader = self.tx.set(value)  # leading motor\n        st_follower = self.bx.set(value - self.diff)  # following motor\n        return st_leader & st_follower"
  },
  {
    "class_name": "MotorPairY",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/02-nanops.py",
    "source": "class MotorPairY(Device):\n    ty = Cpt(NanoMotorWithGentleStop, nanop.ty.prefix)\n    by = Cpt(NanoMotorWithGentleStop, nanop.by.prefix)\n    def __init__(self, *args, **kwargs):\n        \"\"\"A bundle device to move a pair of motors to the same distance\"\"\"\n        super().__init__(*args, **kwargs)\n        self.update_diff()\n\n    def update_diff(self):\n        self.diff = self.ty.user_readback.get() - self.by.user_readback.get()\n\n    def set(self, value):\n        st_leader = self.ty.set(value)  # leading motor\n        st_follower = self.by.set(value - self.diff)  # following motor\n        return st_leader & st_follower"
  },
  {
    "class_name": "MotorPairZ",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/02-nanops.py",
    "source": "class MotorPairZ(Device):\n    tz = Cpt(NanoMotorWithGentleStop, nanop.tz.prefix)\n    bz = Cpt(NanoMotorWithGentleStop, nanop.bz.prefix)\n    def __init__(self, *args, **kwargs):\n        \"\"\"A bundle device to move a pair of motors to the same distance\"\"\"\n        super().__init__(*args, **kwargs)\n        self.update_diff()\n\n    def update_diff(self):\n        self.diff = self.tz.user_readback.get() - self.bz.user_readback.get()\n\n    def set(self, value):\n        st_leader = self.tz.set(value)  # leading motor\n        st_follower = self.bz.set(value - self.diff)  # following motor\n        return st_leader & st_follower"
  },
  {
    "class_name": "Interpolator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/epu.py",
    "source": "class Interpolator(Device):\n    input = Cpt(EpicsSignal, 'Val:Inp1-SP')\n    input_offset = Cpt(EpicsSignal, 'Val:InpOff1-SP')\n    # {'Enabled', 'Disabled'}\n    input_link = Cpt(EpicsSignal, 'Enbl:Inp1-Sel', string=True)\n    input_pv = Cpt(EpicsSignal, 'Val:Inp1-SP.DOL$', string=True)\n    output = Cpt(EpicsSignalRO, 'Val:Out1-I')\n    # {'Enable', 'Disable'}\n    output_link = Cpt(EpicsSignalRO, 'Enbl:Out1-Sel', string=True)\n    output_pv = Cpt(EpicsSignal, 'Calc1.OUT$', string=True)\n    output_deadband = Cpt(EpicsSignal, 'Val:DBand1-SP')\n    output_drive = Cpt(EpicsSignalRO, 'Val:OutDrv1-I')\n    interpolation_status = Cpt(EpicsSignalRO, 'Sts:Interp1-Sts', string=True)"
  },
  {
    "class_name": "EPU",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/epu.py",
    "source": "class EPU(Device):\n    gap = Cpt(EPUMotor, '-Ax:Gap}', stop_suffix='-Ax:Gap}')\n    phase = Cpt(EPUMotor, '-Ax:Phase}', stop_suffix='-Ax:Phase}')\n    x_off = FmCpt(EpicsSignalRO,'{self._ai_prefix}:FPGA:x_mm-I')\n    x_ang = FmCpt(EpicsSignalRO,'{self._ai_prefix}:FPGA:x_mrad-I')\n    y_off = FmCpt(EpicsSignalRO,'{self._ai_prefix}:FPGA:y_mm-I')\n    y_ang = FmCpt(EpicsSignalRO,'{self._ai_prefix}:FPGA:y_mrad-I')\n    flt = Cpt(Interpolator, '-FLT}')\n    rlt = Cpt(Interpolator, '-RLT}')\n    table = Cpt(EpicsSignal, '}Val:Table-Sel', name='table')# this pv has no FLT\n\n    def __init__(self, *args, ai_prefix=None, epu_prefix=None, **kwargs):\n        self._ai_prefix = ai_prefix\n        self._epu_prefix = epu_prefix\n        super().__init__(*args, **kwargs)"
  },
  {
    "class_name": "BPM_signal",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/epu.py",
    "source": "class BPM_signal(Device):\n    setpoint = Cpt(EpicsSignalRO, '-SP')\n    deviation = Cpt(EpicsSignalRO, 'S-I')"
  },
  {
    "class_name": "BPMAxis",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/epu.py",
    "source": "class BPMAxis(Device):\n    pos = FmCpt(BPM_signal, '{prefix}Pos{self.axis}')\n    angle = FmCpt(BPM_signal, '{prefix}Angle{self.axis}')\n\n    def __init__(self, *args, axis : str, **kwargs):\n        self.axis = axis\n        super().__init__(*args, **kwargs)"
  },
  {
    "class_name": "BPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/epu.py",
    "source": "class BPM(Device):\n    x = Cpt(BPMAxis, '', axis = 'X')\n    y = Cpt(BPMAxis, '', axis = 'Y')"
  },
  {
    "class_name": "Lakeshore336Channel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/lakeshore.py",
    "source": "class Lakeshore336Channel(Device):\n    T = Cpt(EpicsSignalRO, 'T-I')\n    V = Cpt(EpicsSignalRO, 'Val:Sens-I')\n    status = Cpt(EpicsSignalRO, 'T-Sts')"
  },
  {
    "class_name": "Lakeshore336",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/lakeshore.py",
    "source": "class Lakeshore336(Device):\n    temp = DDC(_temp_fields(['A','B','C','D']))\n    ctrl1 = Cpt(Lakeshore336Setpoint, '-Out:1}')\n    ctrl2 = Cpt(Lakeshore336Setpoint, '-Out:2}')"
  },
  {
    "class_name": "Lakeshore336Picky",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/lakeshore.py",
    "source": "class Lakeshore336Picky(Device):\n    setpoint = Cpt(EpicsSignal, read_pv='-Out:1}T-RB', write_pv='-Out:1}T-SP',\n                   add_prefix=('read_pv', 'write_pv'))\n    # TODO expose ramp rate\n    ramp_done = Cpt(EpicsSignalRO, '-Out:1}Sts:Ramp-Sts')\n    ramp_enabled = Cpt(EpicsSignal, '-Out:1}Enbl:Ramp-Sel')\n    ramp_rate = Cpt(EpicsSignal, read_pv='-Out:1}Val:Ramp-RB',\n                    write_pv='-Out:1}Val:Ramp-SP',\n                    add_prefix=('read_pv', 'write_pv'))\n\n    chanA = Cpt(Lakeshore336Channel, '-Chan:A}')\n    chanB = Cpt(Lakeshore336Channel, '-Chan:B}')\n\n    def __init__(self, *args, timeout=60*60*30, target='chanA', **kwargs):\n        # do the base stuff\n        super().__init__(*args, **kwargs)\n        # status object for communication\n        self._done_sts = None\n\n        # state for deciding if we are done or not\n        self._cache = deque()\n        self._start_time = 0\n        self._setpoint = None\n        self._count = -1\n\n        # longest we can wait before giving up\n        self._timeout = timeout\n        self._lagtime = 120\n\n        # the channel to watch to see if we are done\n        self._target_channel = target\n\n        # parameters for done testing\n        self.mean_thresh = .01\n        self.ptp_thresh = .1\n\n    def _value_cb(self, value, timestamp, **kwargs):\n        self._cache.append((value, timestamp))\n\n        if (timestamp - self._cache[0][1]) < self._lagtime / 2:\n            return\n\n        while (timestamp - self._cache[0][1]) > self._lagtime:\n            self._cache.popleft()\n\n        buff = np.array([v[0] for v in self._cache])\n        if self._done_test(self._setpoint, buff):\n            self._done_sts._finished()\n            self._reset()\n\n    def _setpoint_cb(self, value, **kwargs):\n        print('in cb', value)\n        if value == self._setpoint:\n            self._done_sts._finished()\n            self.setpoint.clear_sub(self._setpoint_cb, 'value')\n\n    def _reset(self):\n        if self._target_channel == 'setpoint':\n            target = self.setpoint\n            target.clear_sub(self._setpoint_cb, 'value')\n        else:\n            target = getattr(self, self._target_channel).T\n            target.clear_sub(self._value_cb, 'value')\n        self._done_sts = None\n        self._setpoint = None\n        self._cache.clear()\n\n    def _done_test(self, target, buff):\n        mn = np.mean(np.abs(buff - target))\n\n        if mn > self.mean_thresh:\n            return False\n\n        if np.ptp(buff) > self.ptp_thresh:\n            return False\n\n        return True\n\n\n    def set(self, new_position, *, timeout=None):\n        # to be subscribed to 'value' cb on readback\n        sts = self._done_sts = DeviceStatus(self, timeout=timeout)\n        if self.setpoint.get() == new_position:\n            self._done_sts._finished()\n            self._done_sts = None\n            return sts\n\n        self._setpoint = new_position\n\n        self.setpoint.set(self._setpoint)\n\n        # todo, set up subscription forwarding\n        if self._target_channel == 'setpoint':\n            self.setpoint.subscribe(self._setpoint_cb, 'value')\n        else:\n            target = getattr(self, self._target_channel).T\n            target.subscribe(self._value_cb, 'value')\n\n        return self._done_sts"
  },
  {
    "class_name": "DelayGeneratorChan",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/lakeshore.py",
    "source": "class DelayGeneratorChan(EpicsSignal):\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix + '-RB', write_pv=prefix + '-SP', **kwargs)"
  },
  {
    "class_name": "DelayGenerator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/lakeshore.py",
    "source": "class DelayGenerator(Device):\n    A = Cpt(DelayGeneratorChan, '-Chan:A}DO:Dly')\n    B = Cpt(DelayGeneratorChan, '-Chan:B}DO:Dly')\n    C = Cpt(DelayGeneratorChan, '-Chan:C}DO:Dly')\n    D = Cpt(DelayGeneratorChan, '-Chan:D}DO:Dly')\n    E = Cpt(DelayGeneratorChan, '-Chan:E}DO:Dly')\n    F = Cpt(DelayGeneratorChan, '-Chan:F}DO:Dly')\n    G = Cpt(DelayGeneratorChan, '-Chan:G}DO:Dly')\n    H = Cpt(DelayGeneratorChan, '-Chan:H}DO:Dly')"
  },
  {
    "class_name": "LookupRow",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/motor_lookup.py",
    "source": "class LookupRow(Device):\n        \"\"\"A class representing a single row in a lookup table for motor positions.\n\n        Attributes\n        ----------\n        values : DynamicDeviceComponent\n            A dynamic device component containing the values for each column in the lookup row.\n        key : Cpt(EpicsSignal)\n            An EpicsSignal component representing the key for the lookup row\n        \"\"\"\n\n        values = DynamicDeviceComponent(defn)\n        key = Cpt(EpicsSignal, ((\"-\" + lut_suffix + \"}Pos-Sel.\" + pos_sel_extensions[row_number])))\n\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            \n        \n        def get_row(self):\n            \"\"\"Return a dictionary representation of the row following the structure:\n            {key: {col_name: value, ...}} where key is the position selection value and col_name is the name of each column.\n            \"\"\"\n\n            row = {}\n            row_key = self.key.get()\n            row[row_key] = {}\n            for key in defn:\n                row[row_key][key] = getattr(self.values, key).get()\n            return row"
  },
  {
    "class_name": "PrototypeEpicsScaler",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/scaler.py",
    "source": "class PrototypeEpicsScaler(Device):\n    '''SynApps Scaler Record interface'''\n\n    # tigger + trigger mode\n    count = Cpt(EpicsSignal, '.CNT', trigger_value=1)\n    count_mode = Cpt(EpicsSignal, '.CONT', string=True)\n\n    # delay from triggering to starting counting\n    delay = Cpt(EpicsSignal, '.DLY')\n    auto_count_delay = Cpt(EpicsSignal, '.DLY1')\n\n    # the data\n    channels = DDCpt(_scaler_fields('chan', '.S', range(1, 33)))\n    names = DDCpt(_scaler_fields('name', '.NM', range(1, 33)))\n\n    time = Cpt(EpicsSignal, '.T')\n    freq = Cpt(EpicsSignal, '.FREQ')\n\n    preset_time = Cpt(EpicsSignal, '.TP')\n    auto_count_time = Cpt(EpicsSignal, '.TP1')\n\n    presets = DDCpt(_scaler_fields('preset', '.PR', range(1, 33)))\n    gates = DDCpt(_scaler_fields('gate', '.G', range(1, 33)))\n\n    update_rate = Cpt(EpicsSignal, '.RATE')\n    auto_count_update_rate = Cpt(EpicsSignal, '.RAT1')\n\n    egu = Cpt(EpicsSignal, '.EGU')\n\n    def __init__(self, prefix, *, read_attrs=None, configuration_attrs=None,\n                 name=None, parent=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['channels', 'time']\n\n        if configuration_attrs is None:\n            configuration_attrs = ['preset_time', 'presets', 'gates',\n                                   'names', 'freq', 'auto_count_time',\n                                   'count_mode', 'delay',\n                                   'auto_count_delay', 'egu']\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         name=name, parent=parent, **kwargs)\n\n        self.stage_sigs.update([(self.count_mode, 0)])"
  },
  {
    "class_name": "StruckSIS3820MCS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/scaler.py",
    "source": "class StruckSIS3820MCS(Device):\n    _default_configuration_attrs = ('input_mode', 'output_mode',\n                                    'output_polarity', 'channel_advance',\n                                    'count_on_start', 'max_channels')\n    _default_read_attrs = ('wfrm',)\n\n    erase_start = Cpt(EpicsSignal, 'EraseStart')\n    erase_all = Cpt(EpicsSignal, 'EraseAll')\n    start_all = Cpt(EpicsSignal, 'StartAll')\n    stop_all = Cpt(EpicsSignal, 'StopAll', put_complete=True)\n    acquiring = Cpt(EpicsSignalRO, 'Acquiring')\n\n    input_mode = Cpt(EpicsSignal, 'InputMode')\n    output_mode = Cpt(EpicsSignal, 'OutputMode')\n    output_polarity = Cpt(EpicsSignal, 'OutputPolarity')\n\n    channel_advance = Cpt(EpicsSignal, 'ChannelAdvance')\n    soft_channel_advance = Cpt(EpicsSignal, 'SoftwareChannelAdvance',\n                               put_complete=True)\n\n    count_on_start = Cpt(EpicsSignal, 'CountOnStart')\n    acquire_mode = Cpt(EpicsSignal, 'AcquireMode')\n\n    max_channels = Cpt(EpicsSignalRO, 'MaxChannels')\n\n    read_all = Cpt(EpicsSignal, 'ReadAll')\n    n_use_all = Cpt(EpicsSignal, 'NUseAll')\n\n    current_channel = Cpt(EpicsSignalRO, 'CurrentChannel')\n\n    wfrm = DDCpt(_mcs_fields(EpicsSignalRO,\n                           'wfrm', 'Wfrm:', range(1, 33), ''))\n    wfrm_proc = DDCpt(_mcs_fields(EpicsSignal,\n                                'wfrm_proc', 'Wfrm:', range(1, 33), '.PROC',\n                                put_complete=True))\n\n    def trigger(self):\n        self.erase_start.put(1)\n        return super().trigger()\n\n    def read(self):\n        # Here we stop and poke the proc fields\n        self.soft_channel_advance.put(1, wait=True)\n        self.stop_all.put(1, wait=True)\n\n        for sn in self.wfrm_proc.component_names:\n            getattr(self.wfrm_proc, sn).put(1)\n\n        return super().read()\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.stage_sigs['input_mode'] = 3\n        self.stage_sigs['acquire_mode'] = 0\n        self.stage_sigs['count_on_start'] = 0\n        self.stage_sigs['channel_advance'] = 1"
  },
  {
    "class_name": "TriggeredCamExposure",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/areadetector.py",
    "source": "class TriggeredCamExposure(Device):\n    def __init__(self, *args, **kwargs):\n        self._Tc = 0.004\n        self._To = 0.0035\n        self._readout = 0.080\n        super().__init__(*args, **kwargs)\n\n    def set(self, exp):\n        # Exposure time = 0\n        # Cycle time = 1\n\n        # A NullStatus is always immediate 'done'.\n        # This will be AND-ed with non-null statuses below, if applicable,\n        # effectively reporting that this set operation is done when *all* the\n        # individual set operations are done.\n        status = NullStatus()  \n\n        if exp[0] is not None:\n            Efccd = exp[0] + self._Tc + self._To\n            # To = start of FastCCD Exposure\n            aa = 0                          # Shutter open\n            bb = Efccd - self._Tc + aa      # Shutter close\n            cc = self._To * 3               # diag6 gate start\n            dd = exp[0] - (self._Tc * 2)    # diag6 gate stop\n            ee = 0                          # Channel Adv Start\n            ff = 0.001                      # Channel Adv Stop\n            gg = self._To                   # MCS Count Gate Start\n            hh = exp[0] + self._To          # MCS Count Gate Stop\n\n            # Set delay generator\n            status &= self.parent.dg1.A.set(aa)\n            status &= self.parent.dg1.B.set(bb)\n            status &= self.parent.dg1.C.set(cc)\n            status &= self.parent.dg1.D.set(dd)\n            status &= self.parent.dg1.E.set(ee)\n            status &= self.parent.dg1.F.set(ff)\n            status &= self.parent.dg1.G.set(gg)\n            status &= self.parent.dg1.H.set(hh)\n            status &= self.parent.dg2.A.set(0)\n            status &= self.parent.dg2.B.set(0.0005)\n\n            # Set AreaDetector\n            status &= self.parent.cam.acquire_time.set(Efccd)\n\n        # Now do period\n        if exp[1] is not None:\n            if exp[1] < (Efccd + self._readout):\n                p = Efccd + self._readout\n            else:\n                p = exp[1]\n\n        status &= self.parent.cam.acquire_period.set(p)\n\n        if exp[2] is not None:\n            status &= self.parent.cam.num_images.set(exp[2])\n\n        return status\n\n    def get(self):\n        return None"
  },
  {
    "class_name": "EPSTwoStateDevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/eps.py",
    "source": "class EPSTwoStateDevice(Device):\n    # @tcaswell, the names don't need to be fixed. These commands run\n    # when the record is processed, you could as easily poke .PROC\n    state1_cmd = FmtCpt(EpicsSignal, '{self.prefix}Cmd:{self._state1_nm}-Cmd',\n                        string=True)\n    state2_cmd = FmtCpt(EpicsSignal, '{self.prefix}Cmd:{self._state2_nm}-Cmd',\n                        string=True)\n\n    status = Cpt(EpicsSignalRO, 'Pos-Sts', string=True)\n    fail_to_state2 = FmtCpt(EpicsSignalRO,\n                            '{self.prefix}Sts:Fail{self._state2_nm}-Sts',\n                            string=True)\n    fail_to_state1 = FmtCpt(EpicsSignalRO,\n                            '{self.prefix}Sts:Fail{self._state1_nm}-Sts',\n                            string=True)\n\n    def set(self, val):\n        if self._set_st is not None:\n            raise RuntimeError('trying to set while a set is in progress')\n\n        cmd_map = {self.state1_str: self.state1_cmd,\n                   self.state2_str: self.state2_cmd}\n        target_map = {self.state1_str: self.state1_val,\n                      self.state2_str: self.state2_val}\n\n        cmd_sig = cmd_map[val]\n        target_val = target_map[val]\n\n        st = self._set_st = DeviceStatus(self)\n        enums = self.status.enum_strs\n\n        def shutter_cb(value, timestamp, **kwargs):\n            try:\n                value = enums[int(value)]\n            except (ValueError, TypeError):\n                # we are here because value is a str not int\n                # just move on\n                ...\n            if value == target_val:\n                self.status.clear_sub(shutter_cb)\n                cmd_sig.clear_sub(cmd_retry_cb)\n                # This was a race condition, fixed.\n                # First clear self._set_st to allow future moves to start,\n                # and _then_ mark the current move as done.\n                self._set_st = None\n                st.set_finished()\n\n        cmd_enums = cmd_sig.enum_strs\n        count = 0\n        MAX_RETRIES = 10\n        WAIT_FOR_RETRY = 0.5  # seconds\n        def cmd_retry_cb(value, timestamp, **kwargs):\n            nonlocal count\n            try:\n                value = cmd_enums[int(value)]\n            except (ValueError, TypeError):\n                # we are here because value is a str not int\n                # just move on\n                ...\n            count += 1\n            if count > MAX_RETRIES:\n                cmd_sig.clear_sub(cmd_retry_cb)\n                err = Exception(f\"Retried {MAX_RETRIES} times and did not finish.\")\n                st.set_exception(err)\n            if value == 'None':\n                ttime.sleep(WAIT_FOR_RETRY)\n                if not st.done:\n                    # Retry setting the command to 1.\n                    cmd_sig.set(1)\n                    ts = datetime.datetime.fromtimestamp(timestamp).strftime(_time_fmtstr)\n                    print('** ({}) Had to reactuate shutter while {}ing v2'.format(ts, val))\n\n        cmd_sig.subscribe(cmd_retry_cb, run=False)\n        self.status.subscribe(shutter_cb)\n        cmd_sig.set(1)\n\n        return st\n\n    def __init__(self, *args, state1='Open', state2='Closed',\n                 cmd_str1='Open', cmd_str2='Close',\n                 nm_str1='Opn', nm_str2='Cls', **kwargs):\n\n        self._state1_nm = nm_str1\n        self._state2_nm = nm_str2\n\n        super().__init__(*args, **kwargs)\n\n        self._set_st = None\n        self.read_attrs = ['status']\n\n        self.state1_str = cmd_str1\n        self.state2_str = cmd_str2\n        self.state1_val = state1\n        self.state2_val = state2"
  },
  {
    "class_name": "PMACKiller",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/devices.py",
    "source": "class PMACKiller(EpicsSignal):\n    \"\"\"stop gap to kill epics motors within the bluesky RE so that the amplifier and control-loop are disabled. \n\n    kill_delta = PMACKiller(write_pv=\"XF:23ID1-ES{Dif-Ax:Del}Cmd:Kill-Cmd.PROC\", read_pv=\"XF:23ID1-CT{MC:12-Ax:1}Kill-Sts\")\n\n    RE(bps.mv(kill_delta, 0))\n\n    Args:\n        writepv : full PV for a controller and axis kill-cmd that is a PROC record\n        readpv : full PV for a controller and axis kill-status\n    \"\"\"\n    def set(self, value, *args, **kwargs):\n        if value != 1: \n            logging.getLogger(__name__).warning(\"The value of the PMACKiller should only ever be set to 1. \"\n                \"Changing the setpoint to 1 now.\")\n            value = 1\n        return super().set(value, *args, **kwargs)"
  },
  {
    "class_name": "LakeshoreChannel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/devices.py",
    "source": "class LakeshoreChannel(Device):\n    T = Cpt(EpicsSignalRO, 'T-I')\n    V = Cpt(EpicsSignalRO, 'Val:Sens-I')\n    status = Cpt(EpicsSignalRO, 'T-Sts')\n\n    def __init__(self, *args, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['T']\n        super().__init__(*args, read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "Lakeshore336Picky",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/devices.py",
    "source": "class Lakeshore336Picky(Device):\n    setpoint = Cpt(EpicsSignal, read_pv='-Out:1}T-RB', write_pv='-Out:1}T-SP',\n                   add_prefix=('read_pv', 'write_pv'))\n    # TODO expose ramp rate\n    ramp_done = Cpt(EpicsSignalRO, '-Out:1}Sts:Ramp-Sts')\n    ramp_enabled = Cpt(EpicsSignal, '-Out:1}Enbl:Ramp-Sel')\n    ramp_rate = Cpt(EpicsSignal, read_pv='-Out:1}Val:Ramp-RB',\n                    write_pv='-Out:1}Val:Ramp-SP',\n                    add_prefix=('read_pv', 'write_pv'))\n\n    chanA = Cpt(LakeshoreChannel, '-Chan:A}')\n    chanB = Cpt(LakeshoreChannel, '-Chan:B}')\n\n    def __init__(self, *args, timeout=60*60*30, target='chanA', **kwargs):\n        # do the base stuff\n        super().__init__(*args, **kwargs)\n        # status object for communication\n        self._done_sts = None\n\n        # state for deciding if we are done or not\n        self._cache = deque()\n        self._start_time = 0\n        self._setpoint = None\n        self._count = -1\n\n        # longest we can wait before giving up\n        self._timeout = timeout\n        self._lagtime = 120\n\n        # the channel to watch to see if we are done\n        self._target_channel = target\n\n        # parameters for done testing\n        self.mean_thresh = .01\n        self.ptp_thresh = .1\n\n    def _value_cb(self, value, timestamp, **kwargs):\n        self._cache.append((value, timestamp))\n\n        if (timestamp - self._cache[0][1]) < self._lagtime / 2:\n            return\n\n        while (timestamp - self._cache[0][1]) > self._lagtime:\n            self._cache.popleft()\n\n        buff = np.array([v[0] for v in self._cache])\n        if self._done_test(self._setpoint, buff):\n            self._done_sts._finished()\n            self._reset()\n\n    def _setpoint_cb(self, value, **kwargs):\n        print('in cb', value)\n        if value == self._setpoint:\n            self._done_sts._finished()\n            self.setpoint.clear_sub(self._setpoint_cb, 'value')\n\n    def _reset(self):\n        if self._target_channel == 'setpoint':\n            target = self.setpoint\n            target.clear_sub(self._setpoint_cb, 'value')\n        else:\n            target = getattr(self, self._target_channel).T\n            target.clear_sub(self._value_cb, 'value')\n        self._done_sts = None\n        self._setpoint = None\n        self._cache.clear()\n\n    def _done_test(self, target, buff):\n        mn = np.mean(np.abs(buff - target))\n\n        if mn > self.mean_thresh:\n            return False\n\n        if np.ptp(buff) > self.ptp_thresh:\n            return False\n\n        return True\n\n\n    def set(self, new_position, *, timeout=None):\n        # to be subscribed to 'value' cb on readback\n        sts = self._done_sts = DeviceStatus(self, timeout=timeout)\n        if self.setpoint.get() == new_position:\n            self._done_sts._finished()\n            self._done_sts = None\n            return sts\n\n        self._setpoint = new_position\n\n        self.setpoint.set(self._setpoint)\n\n        # todo, set up subscription forwarding\n        if self._target_channel == 'setpoint':\n            self.setpoint.subscribe(self._setpoint_cb, 'value')\n        else:\n            target = getattr(self, self._target_channel).T\n            target.subscribe(self._value_cb, 'value')\n\n        return self._done_sts"
  },
  {
    "class_name": "DelayGeneratorChan",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/devices.py",
    "source": "class DelayGeneratorChan(EpicsSignal):\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix + '-RB', write_pv=prefix + '-SP', **kwargs)"
  },
  {
    "class_name": "DelayGenerator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/devices.py",
    "source": "class DelayGenerator(Device):\n    A = Cpt(DelayGeneratorChan, '-Chan:A}DO:Dly')\n    B = Cpt(DelayGeneratorChan, '-Chan:B}DO:Dly')\n    C = Cpt(DelayGeneratorChan, '-Chan:C}DO:Dly')\n    D = Cpt(DelayGeneratorChan, '-Chan:D}DO:Dly')\n    E = Cpt(DelayGeneratorChan, '-Chan:E}DO:Dly')\n    F = Cpt(DelayGeneratorChan, '-Chan:F}DO:Dly')\n    G = Cpt(DelayGeneratorChan, '-Chan:G}DO:Dly')\n    H = Cpt(DelayGeneratorChan, '-Chan:H}DO:Dly')"
  },
  {
    "class_name": "M3AMirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/optics.py",
    "source": "class M3AMirror(Device):\n    \"a mirror with EpicsMotors, used for M3A\"\n    x = Cpt(EpicsMotor, '-Ax:XAvg}Mtr')\n    pit = Cpt(EpicsMotor, '-Ax:P}Mtr')\n    bdr = Cpt(EpicsMotor, '-Ax:Bdr}Mtr')"
  },
  {
    "class_name": "MonoFly",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/optics.py",
    "source": "class MonoFly(Device):\n    start_sig = Cpt(EpicsSignal, '}Enrgy:Start-SP')\n    stop_sig = Cpt(EpicsSignal, '}Enrgy:Stop-SP')\n    velocity = Cpt(EpicsSignal, '}Enrgy:FlyVelo-SP')\n\n    fly_start = Cpt(EpicsSignal, '}Cmd:FlyStart-Cmd.PROC')\n    fly_stop = Cpt(EpicsSignal, '}Cmd:Stop-Cmd.PROC')\n    scan_status = Cpt(EpicsSignalRO, '}Sts:Scan-Sts', string=True)"
  },
  {
    "class_name": "PGM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/optics.py",
    "source": "class PGM(Device):\n    energy = Cpt(PGMEnergy, '')\n    mir_pit = Cpt(EpicsMotor, 'o-Ax:MirP}Mtr')\n    mir_x = Cpt(EpicsMotor, 'o-Ax:MirX}Mtr')\n    grt_pit = Cpt(EpicsMotor, 'o-Ax:GrtP}Mtr')\n    grt_x = Cpt(EpicsMotor, 'o-Ax:GrtX}Mtr')\n\n    fly = Cpt(MonoFly, 'o')\n\n    mir_temp_in = FmtCpt(EpicsSignalRO, '{self._temp_pv}-Chan:A}}T-I')\n    grt_temp_in = FmtCpt(EpicsSignalRO, '{self._temp_pv}-Chan:B}}T-I')\n    mir_temp_out = FmtCpt(EpicsSignalRO, '{self._temp_pv}-Chan:C}}T-I')\n    grt_temp_out = FmtCpt(EpicsSignalRO, '{self._temp_pv}-Chan:D}}T-I')\n    air_temp = FmtCpt(EpicsSignalRO, '{self._temp_pv}-Chan:D5}}T-I')\n\n    grt1_temp = Cpt(EpicsSignalRO, '-Grt:1}T-I')\n    grt2_temp = Cpt(EpicsSignalRO, '-Grt:2}T-I')\n    grt3_temp = Cpt(EpicsSignalRO, '-Grt:3}T-I')\n    grt4_temp = Cpt(EpicsSignalRO, '-Grt:4}T-I')\n\n    def __init__(self, *args, temp_pv=None, **kwargs):\n        self._temp_pv = temp_pv\n        super().__init__(*args, **kwargs)"
  },
  {
    "class_name": "Nanopositioner",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/optics.py",
    "source": "class Nanopositioner(Device):\n    tx = Cpt(EpicsMotor, '-Ax:TopX}Mtr')\n    ty = Cpt(EpicsMotor, '-Ax:TopY}Mtr')\n    tz = Cpt(EpicsMotor, '-Ax:TopZ}Mtr')\n    bx = Cpt(EpicsMotor, '-Ax:BtmX}Mtr')\n    by = Cpt(EpicsMotor, '-Ax:BtmY}Mtr')\n    bz = Cpt(EpicsMotor, '-Ax:BtmZ}Mtr')"
  },
  {
    "class_name": "FMBHexapodMirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/optics.py",
    "source": "class FMBHexapodMirror(Device):\n    z = Cpt(FMBHexapodMirrorAxis, '-Ax:Z}')\n    y = Cpt(FMBHexapodMirrorAxis, '-Ax:Y}')\n    x = Cpt(FMBHexapodMirrorAxis, '-Ax:X}')\n    pit = Cpt(FMBHexapodMirrorAxis, '-Ax:Pit}')\n    yaw = Cpt(FMBHexapodMirrorAxis, '-Ax:Yaw}')\n    rol = Cpt(FMBHexapodMirrorAxis, '-Ax:Rol}')"
  },
  {
    "class_name": "SlitsGapCenter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/optics.py",
    "source": "class SlitsGapCenter(Device):\n    xg = Cpt(EpicsMotor, '-Ax:XGap}Mtr')\n    xc = Cpt(EpicsMotor, '-Ax:XCtr}Mtr')\n    yg = Cpt(EpicsMotor, '-Ax:YGap}Mtr')\n    yc = Cpt(EpicsMotor, '-Ax:YCtr}Mtr')"
  },
  {
    "class_name": "SlitsXY",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/optics.py",
    "source": "class SlitsXY(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr', name='x')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr', name='y')"
  },
  {
    "class_name": "FEAxis",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/optics.py",
    "source": "class FEAxis(Device):\n    gap = FmtCpt(acc_slit, '{prefix}-Ax:{self.axis}}}')\n    cent = FmtCpt(acc_slit_cent, '{prefix}-Ax:{self.axis}}}')\n\n    def __init__(self, *args, axis : str, **kwargs):\n        self.axis = axis\n        super().__init__(*args, **kwargs)"
  },
  {
    "class_name": "FrontEndSlit",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/csx-profile-collection/startup/csx1/devices/optics.py",
    "source": "class FrontEndSlit(Device):\n    x = Cpt(FEAxis, '', axis = 'X')\n    y = Cpt(FEAxis, '', axis = 'Y')"
  },
  {
    "class_name": "Vortex",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/01-classes.py",
    "source": "class Vortex(Device):\n    mca = Cpt(EpicsMCA, 'mca1')\n    vortex = Cpt(EpicsDXP, 'dxp1:')\n\n    @property\n    def trigger_signals(self):\n        return [self.mca.erase_start]\n\n    def describe(self):\n        ret = super().describe()\n        ret[\"vortex_mca_spectrum\"].setdefault(\"dtype_str\", \"<i8\")  # Update specificity for dtype as 'array'\n        return ret"
  },
  {
    "class_name": "Valve",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/11-valves.py",
    "source": "class Valve(Device):\n    open_cmd = Cpt(EpicsSignal, 'Cmd:Opn-Cmd')\n    close_cmd = Cpt(EpicsSignal, 'Cmd:Cls-Cmd')\n    pos_sts = Cpt(EpicsSignal, 'Pos-Sts')"
  },
  {
    "class_name": "TwoButtonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/11-valves.py",
    "source": "class TwoButtonShutter(Device):\n    # TODO this needs to be fixed in EPICS as these names make no sense\n    # the vlaue comingout of the PV do not match what is shown in CSS\n    open_cmd = Cpt(EpicsSignal, 'Cmd:Opn-Cmd', string=True)\n    open_val = 'Not Closed'\n\n    close_cmd = Cpt(EpicsSignal, 'Cmd:Cls-Cmd', string=True)\n    close_val = 'Closed'\n\n    status = Cpt(EpicsSignalRO, 'Pos-Sts', string=True)\n    fail_to_close = Cpt(EpicsSignalRO, 'Sts:FailCls-Sts', string=True)\n    fail_to_open = Cpt(EpicsSignalRO, 'Sts:FailOpn-Sts', string=True)\n    # user facing commands\n    open_str = 'Open'\n    close_str = 'Close'\n\n    def set(self, val):\n        if self._set_st is not None:\n            raise RuntimeError('trying to set while a set is in progress')\n\n        cmd_map = {self.open_str: self.open_cmd,\n                   self.close_str: self.close_cmd}\n        target_map = {self.open_str: self.open_val,\n                      self.close_str: self.close_val}\n\n        cmd_sig = cmd_map[val]\n        target_val = target_map[val]\n\n        st = self._set_st = DeviceStatus(self)\n        enums = self.status.enum_strs\n\n        def shutter_cb(value, timestamp, **kwargs):\n            value = enums[int(value)]\n            if value == target_val:\n                self._set_st._finished()\n                self._set_st = None\n                self.status.clear_sub(shutter_cb)\n\n        cmd_enums = cmd_sig.enum_strs\n        count = 0\n        def cmd_retry_cb(value, timestamp, **kwargs):\n            nonlocal count\n            value = cmd_enums[int(value)]\n            # ts = datetime.datetime.fromtimestamp(timestamp).strftime(_time_fmtstr)\n            # print('sh', ts, val, st)\n            count += 1\n            if count > 5:\n                cmd_sig.clear_sub(cmd_retry_cb)\n                st._finished(success=False)\n            if value == 'None':\n                if not st.done:\n                    time.sleep(.5)\n                    cmd_sig.set(1)\n                    ts = datetime.datetime.fromtimestamp(timestamp).strftime(_time_fmtstr)\n                    print('** ({}) Had to reactuate shutter while {}ing'.format(ts, val))\n                else:\n                    cmd_sig.clear_sub(cmd_retry_cb)\n\n        cmd_sig.subscribe(cmd_retry_cb, run=False)\n        cmd_sig.set(1)\n        self.status.subscribe(shutter_cb)\n\n\n        return st\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._set_st = None\n        self.read_attrs = ['status']"
  },
  {
    "class_name": "Interpolator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/10-machine.py",
    "source": "class Interpolator(Device):\n    input = Cpt(EpicsSignal, 'Val:Inp1-SP')\n    input_offset = Cpt(EpicsSignal, 'Val:InpOff1-SP')\n    # {'Enabled', 'Disabled'}\n    input_link = Cpt(EpicsSignal, 'Enbl:Inp1-Sel', string=True)\n    input_pv = Cpt(EpicsSignal, 'Val:Inp1-SP.DOL$', string=True)\n    output = Cpt(EpicsSignalRO, 'Val:Out1-I')\n    # {'Enable', 'Disable'}\n    output_link = Cpt(EpicsSignalRO, 'Enbl:Out1-Sel', string=True)\n    output_pv = Cpt(EpicsSignal, 'Calc1.OUT$', string=True)\n    output_deadband = Cpt(EpicsSignal, 'Val:DBand1-SP')\n    output_drive = Cpt(EpicsSignalRO, 'Val:OutDrv1-I')\n    interpolation_status = Cpt(EpicsSignalRO, 'Sts:Interp1-Sts', string=True)"
  },
  {
    "class_name": "EPU1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/10-machine.py",
    "source": "class EPU1(Device):\n    gap = Cpt(GapMotor1, '-Ax:Gap}')\n    phase = Cpt(PhaseMotor1, '-Ax:Phase}')\n    flt = Cpt(Interpolator, '-FLT}')\n    rlt = Cpt(Interpolator, '-RLT}')\n    table = Cpt(EpicsSignal, '}Val:Table-Sel', name='table')"
  },
  {
    "class_name": "EPU2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/10-machine.py",
    "source": "class EPU2(Device):\n    gap = Cpt(GapMotor2, '-Ax:Gap}')\n    phase = Cpt(PhaseMotor2, '-Ax:Phase}')"
  },
  {
    "class_name": "FeedbackLoop",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/10-optics.py",
    "source": "class FeedbackLoop(Device):\n    # this is added to allow for bluesky control of an M1b feedback loop\n    # implemented at the IOC layer\n    enable = Cpt(EpicsSignal, 'Sts:FB-Sel', name='enable')\n    setpoint = Cpt(EpicsSignal, 'PID-SP', name='setpoint')\n    requested_value = Cpt(EpicsSignalRO, 'PID.VAL', name='requested_value')\n    actual_value = Cpt(EpicsSignalRO, 'PID.CVAL', name='actual_value')\n    output_value = Cpt(EpicsSignalRO, 'PID.OVAL', name='output_value')\n    error = Cpt(EpicsSignalRO, 'PID.Err', name='error')\n    high_limit = Cpt(EpicsSignal, 'PID.DRVH', name='high_limit')\n    low_limit = Cpt(EpicsSignal, 'PID.DRVL', name='low_limit')\n    delta_t = Cpt(EpicsSignalRO, 'PID.DT', name='delta_t')\n    min_delta_t = Cpt(EpicsSignal, 'PID.MDT', name='min_delta_t')\n    scan_mode = Cpt(EpicsSignal, 'PID.SCAN', name='scan_mode')\n    deadband = Cpt(EpicsSignal, 'Val:Sbl-SP', name='deadband')"
  },
  {
    "class_name": "Mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/10-optics.py",
    "source": "class Mirror(Device):\n    z = Cpt(MirrorAxis, '-Ax:Z}')\n    y = Cpt(MirrorAxis, '-Ax:Y}')\n    x = Cpt(MirrorAxis, '-Ax:X}')\n    pit = Cpt(MirrorAxis, '-Ax:Pit}')\n    yaw = Cpt(MirrorAxis, '-Ax:Yaw}')\n    rol = Cpt(MirrorAxis, '-Ax:Rol}')"
  },
  {
    "class_name": "MotorMirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/10-optics.py",
    "source": "class MotorMirror(Device):\n    \"a mirror with EpicsMotors, used for M3A\"\n    x = Cpt(EpicsMotor, '-Ax:XAvg}Mtr')\n    pit = Cpt(EpicsMotor, '-Ax:P}Mtr')\n    bdr = Cpt(EpicsMotor, '-Ax:Bdr}Mtr')"
  },
  {
    "class_name": "MonoFly",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/10-optics.py",
    "source": "class MonoFly(Device):\n    start_sig = Cpt(EpicsSignal, '}Enrgy:Start-SP')\n    stop_sig = Cpt(EpicsSignal, '}Enrgy:Stop-SP')\n    velocity = Cpt(EpicsSignal, '}Enrgy:FlyVelo-SP')\n\n    fly_start = Cpt(EpicsSignal, '}Cmd:FlyStart-Cmd.PROC')\n    fly_stop = Cpt(EpicsSignal, '}Cmd:Stop-Cmd.PROC')\n    scan_status = Cpt(EpicsSignalRO, '}Sts:Scan-Sts', string=True)"
  },
  {
    "class_name": "PGM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/10-optics.py",
    "source": "class PGM(Device):\n    energy = Cpt(PGMEnergy, '')\n    pit = Cpt(EpicsMotor, '-Ax:MirP}Mtr')\n    x = Cpt(EpicsMotor, '-Ax:MirX}Mtr')\n    grt_pit = Cpt(EpicsMotor, '-Ax:GrtP}Mtr')\n    grt_x = Cpt(EpicsMotor, '-Ax:GrtX}Mtr')\n    fly = Cpt(MonoFly, '')\n    move_status = Cpt(EpicsSignalRO, '}Sts:Move-Sts', string=True)\n\n    def reset_fbl(self, energy, epu_lookup_table=None, epu_input_offset=None,\n                  fbl_setpoint=None):\n        '''This function performs the process used to reset the feedback loop.\n\n        The aim of this function is to reset the m1b feedback loop (fbl) for\n        the requested photon energy. It performs the steps:\n        1. Disables the feedback loop if it is enabled.\n        2. Changes the EPU lookup table and/or epu input_offset if requested.\n        3. Sets the requested PGM energy (which also sets a new EPU gap).\n        4. Sets a new fbl position setpoint if requested.\n        5. Enables the feedback loop.\n        6. Waits 5s for the feedback loop to reposition the m1b mirror.\n        7. Returns the feedback loop enable status to its initial value.\n\n        Parameters\n        ----------\n        energy : float\n            The energy value to use when resetting the feedback loop\n        epu_lookup_table : str, optional\n            The epu lookup table to use with this energy, default value is the\n            currently used table.\n        epu_input_offset : float, optional\n            The offset value to use against the selected epu_table, default is\n            the current value.\n        fbl_setpoint : int, optional\n            The position to which the beam should be located (in pixels) for the\n            fbl, default is the current value.\n        '''\n\n        initial_fbl_status = m1b1.fbl.enable.read()['m1b1_fbl_enable']['value']\n\n        yield from mv(m1b1.fbl.enable, 0)  # turn off the fbl\n        if epu_lookup_table:\n            yield from mv(epu1.table, epu_lookup_table)\n            # need to add mv to new epu lookup table here when it exists\n        if epu_input_offset:\n            yield from mv(epu1.flt.input_offset, epu_input_offset)\n\n        yield from mv(pgm.energy, energy)  # move to the requested energy\n\n        if fbl_setpoint:\n            yield from mv(m1b1.fbl.setpoint, fbl_setpoint)  # set the new setpoint value\n        yield from mv(m1b1.fbl.enable, 0)  # turn on the fbl\n        yield from bps.sleep(5)  # wait 5s for the feedback loop to reposition the beam\n        yield from mv(m1b1.fbl.enable, initial_fbl_status)"
  },
  {
    "class_name": "SlitsGapCenter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/10-optics.py",
    "source": "class SlitsGapCenter(Device):\n    xg = Cpt(EpicsMotor, '-Ax:XGap}Mtr')\n    xc = Cpt(EpicsMotor, '-Ax:XCtr}Mtr')\n    yg = Cpt(EpicsMotor, '-Ax:YGap}Mtr')\n    yc = Cpt(EpicsMotor, '-Ax:YCtr}Mtr')"
  },
  {
    "class_name": "DodgyEpicsSignal",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/ios-profile-collection/startup/20-detectors.py",
    "source": "class DodgyEpicsSignal(EpicsSignal):\n\n    #def read(self):\n    #    return {self.name: {'value':self.get(), 'timestamp': self.timestamp}}\n\n    def get(self, *, as_string=None, connection_timeout=1.0, **kwargs):\n        '''Get the readback value through an explicit call to EPICS\n        Parameters\n        ----------\n        count : int, optional\n            Explicitly limit count for array data\n        as_string : bool, optional\n            Get a string representation of the value, defaults to as_string\n            from this signal, optional\n        as_numpy : bool\n            Use numpy array as the return type for array data.\n        timeout : float, optional\n            maximum time to wait for value to be received.\n            (default = 0.5 + log10(count) seconds)\n        use_monitor : bool, optional\n            to use value from latest monitor callback or to make an\n            explicit CA call for the value. (default: True)\n        connection_timeout : float, optional\n            If not already connected, allow up to `connection_timeout` seconds\n            for the connection to complete.\n        '''\n        # NOTE: in the future this should be improved to grab self._readback\n        #       instead, when all of the kwargs match up\n        if as_string is None:\n            as_string = self._string\n\n        with self._metadata_lock:\n            if not self._read_pv.connected:\n                if not self._read_pv.wait_for_connection(connection_timeout):\n                    raise TimeoutError('Failed to connect to %s' %\n                                       self._read_pv.pvname)\n            ret = None\n            while ret is None:\n                ret = self._read_pv.get(as_string=as_string, **kwargs)\n                if ret is None:\n                    print('Failed to get value, retrying to read {self}')\n\n        if ret is None:\n            ret = np.nan\n\n        if as_string:\n            return waveform_to_string(ret)\n\n        return ret"
  },
  {
    "class_name": "DodgyEpicsScaler",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ios-profile-collection/startup/20-detectors.py",
    "source": "class DodgyEpicsScaler(Device):\n    '''SynApps Scaler Record interface'''\n\n    # tigger + trigger mode\n    count = C(DodgyEpicsSignal, '.CNT', trigger_value=1)\n    count_mode = C(DodgyEpicsSignal, '.CONT', string=True)\n\n    # delay from triggering to starting counting\n    delay = C(DodgyEpicsSignal, '.DLY')\n    auto_count_delay = C(DodgyEpicsSignal, '.DLY1')\n\n    # the data\n    channels = DDC(_scaler_fields(DodgyEpicsSignal, 'chan', '.S', range(1, 33)))\n    names = DDC(_scaler_fields(DodgyEpicsSignal, 'name', '.NM', range(1, 33)))\n\n    time = C(DodgyEpicsSignal, '.T')\n    freq = C(DodgyEpicsSignal, '.FREQ')\n\n    preset_time = C(DodgyEpicsSignal, '.TP')\n    auto_count_time = C(DodgyEpicsSignal, '.TP1')\n\n    presets = DDC(_scaler_fields(DodgyEpicsSignal, 'preset', '.PR', range(1, 33)))\n    gates = DDC(_scaler_fields(DodgyEpicsSignal, 'gate', '.G', range(1, 33)))\n\n    update_rate = C(DodgyEpicsSignal, '.RATE')\n    auto_count_update_rate = C(DodgyEpicsSignal, '.RAT1')\n\n    egu = C(DodgyEpicsSignal, '.EGU')\n\n    def __init__(self, prefix, *, read_attrs=None, configuration_attrs=None,\n                 name=None, parent=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['channels', 'time']\n\n        if configuration_attrs is None:\n            configuration_attrs = ['preset_time', 'presets', 'gates',\n                                   'names', 'freq', 'auto_count_time',\n                                   'count_mode', 'delay',\n                                   'auto_count_delay', 'egu']\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         name=name, parent=parent, **kwargs)\n\n        self.stage_sigs.update([('count_mode', 0)])\n        \n        for channel in ['channels.chan2','channels.chan3','channels.chan4']:\n            getattr(self, channel).kind = 'hinted'"
  },
  {
    "class_name": "Agilent_34970A",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/41-endstation-serial-dev.py",
    "source": "class Agilent_34970A(Device):\n    # Note: Command terminator is a newline character \\n.\n    # Note: On serial cable, data transmit/receive pins (pins 2 and 3 on Dsub-9 connector) must be reversed.\n    # Settings as of 07/25/2017: Baud rate = 19200 bits/s, Stop bits = 1, Parity = None, Flow control = None\n    # Moxa port 9: socket = 10.11.130.53:4009\n\n    def __init__(\n        self,\n        prefix=\"\",\n        *args,\n        read_attrs=None,\n        configuration_attrs=None,\n        name=\"Agilent_34970A\",\n        parent=None,\n        **kwargs,\n    ):\n        super().__init__(\n            prefix=prefix,\n            *args,\n            read_attrs=read_attrs,\n            configuration_attrs=configuration_attrs,\n            name=name,\n            parent=parent,\n            **kwargs,\n        )\n\n        # self.port_number = 9\n        # self.server_port = 4000 + self.port_number\n        self.connect_socket()\n        self.HP34901_channel = 100  # 20 channel multiplexer module card in slot 1\n        self.HP34907_channel = 300  # DIO/DAC card in slot 3\n\n    # Essential socket interaction\n    ########################################\n\n    def connect_socket(self):\n        # self.server_address= '10.11.130.51'\n        # self.server_address= '10.11.130.53'     # Moxa inside Endstation hutch\n        self.server_address = \"10.68.82.73\"  # NEW IP, 20201112\n        # self.server_IP = '10.11.129.2'\n        self.port_number = 9\n        self.server_port = 4000 + self.port_number\n\n        import socket\n\n        # self.sock = socket.socket()\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(self.server_address)\n        self.sock.connect((self.server_address, self.server_port))\n\n        self.sock.settimeout(0.5)\n\n    def disconnect_socket(self):\n        self.sock.close()\n\n    def send_socket(self, msg):\n        # self.sock.send(chr(13).encode('ascii', 'ignore')) # Carriage return\n        self.sock.send(msg.encode(\"ascii\", \"ignore\"))\n        # self.sock.send(msg.encode('utf-8'))\n\n    def send_get_reply(self, msg, verbosity=3):\n        # self.send_socket('\\r')\n        self.send_socket(msg)\n\n        time.sleep(0.5)\n\n        return self.read_socket(verbosity=verbosity)\n\n    def read_socket(self, timeout_s=3, verbosity=3):\n        start_time = time.time()\n        terminator = chr(0x18)\n\n        # Look for the response\n        amount_received = 0\n        amount_cutoff = 5000\n\n        txt = \"\"\n        msg_received = \"\"\n\n        while terminator not in txt and time.time() - start_time < timeout_s and amount_received < amount_cutoff:\n            try:\n                data = self.sock.recv(1)\n            except:\n                break\n\n            amount_received += len(data)\n            txt = data.decode(\"ascii\")\n\n            msg_received += txt\n\n        msg_received = msg_received.replace(terminator, \"\")\n\n        if time.time() - start_time > timeout_s:\n            if verbosity >= 1:\n                print(\"Read timeout after {:.1f} s.\".format(time.time() - start_time))\n            return \"\"\n\n        else:\n            if verbosity >= 2:\n                print(msg_received)\n            return msg_received\n\n    # Commands for Agilent 34970A unit\n    ########################################\n\n    # Reset Agilent 34970A unit to factory default settings.\n    def reset_Agilent34970A(self, verbosity=3):\n        self.send_socket(\"*RST\\n\")\n\n    # Commands for HP34901 20-channel muliplexer module card\n    ########################################\n\n    # Reset HP34901 to factory default settings.\n    def reset_HP34901(self, verbosity=3):\n        self.send_socket(\"SYSTEM:CPON {chan}\\n\".format(chan=self.HP34901_channel))\n\n    # Read DC voltage on specified channel.\n    def readDCV(self, channel, verbosity=1):\n        if channel < 1 or channel > 20:\n            print(\"Invalid multiplexer channel number; must be 1-20.\\n\")\n            return 0\n\n        read_channel = int(self.HP34901_channel + channel)\n        self.send_socket(\"INPUT:IMP:AUTO ON, (@{chan})\\n\".format(chan=read_channel))\n        self.send_socket(\"SENSE:ZERO:AUTO ON, (@{chan})\\n\".format(chan=read_channel))\n        self.send_socket(\"MEAS:VOLT:DC? AUTO,MAX, (@{chan})\\n\".format(chan=read_channel))\n        dcv = float(self.read_socket(verbosity=1))\n\n        if verbosity > 1:\n            print(\"Channel {chan} is {volts} VDC.\\n\".format(chan=channel, volts=dcv))\n\n        return dcv\n\n    # Commands for HP34907 DIO/DAC card\n    ########################################\n\n    # Output specified voltage on specified DAC channel\n    def setDAC(self, channel, voltage, verbosity=1):\n        if channel < 1 or channel > 2:\n            print(\"Invalid DAC channel number; must be 1 or 2.\\n\")\n            return 0\n\n        if voltage < -12.0 or voltage > 12.0:\n            print(\"Invalid DAC voltage value; must be within +/-12 volts.\\n\")\n            return 0\n\n        dac_channel = int(self.HP34907_channel + channel + 3)\n        self.send_socket(\"SOURCE:VOLTAGE {volts}, (@{chan})\\n\".format(volts=voltage, chan=dac_channel))\n        # self.send_socket('SOURCE:VOLTAGE {volts}, (@{chan})\\r'.format(volts=voltage, chan=dac_channel))\n\n        if verbosity > 1:\n            print(\"DAC output channel {chan} set to {volts} VDC.\\n\".format(chan=channel, volts=voltage))\n\n        return 1\n\n    # Query voltage setting on specified DAC channel\n    def readDAC(self, channel, verbosity=1):\n        if channel < 1 or channel > 2:\n            print(\"Invalid DAC channel number; must be 1 or 2.\\n\")\n            return 0\n\n        dac_channel = int(self.HP34907_channel + channel + 3)\n        self.send_socket(\"SOURCE:VOLTAGE? (@{chan})\\n\".format(chan=dac_channel))\n        voltage = float(self.read_socket(verbosity=1))\n\n        if verbosity > 1:\n            print(\"DAC output channel {chan} set to {volts} VDC.\\n\".format(chan=channel, volts=voltage))\n\n        return voltage\n\n    # Write digital byte to specified DIO channel\n    def writeByteDIO(self, channel, value, verbosity=1):\n        if channel < 1 or channel > 2:\n            print(\"Invalid DIO channel number; must be 1 or 2.\\n\")\n            return 0\n\n        dio_channel = int(self.HP34907_channel + channel)\n        diovalue = (value ^ 0xF) & 0xF\n        # self.send_socket('SOURCE:DIGITAL:DATA:BYTE {byte}, (@{chan})\\n'.format(byte=diovalue, chan=dio_channel))\n        self.send_socket(\"SOURCE:DIGITAL:DATA:BYTE {byte}, (@{chan})\\n\".format(byte=value, chan=dio_channel))\n\n        if verbosity > 1:\n            print(\"DIO output channel {chan} set to {val}.\\n\".format(chan=channel, val=value))\n\n        return 1\n\n    # Read digital byte on specified DIO channel\n    def readByteDIO(self, channel, verbosity=1):\n        if channel < 1 or channel > 2:\n            print(\"Invalid DIO channel number; must be 1 or 2.\\n\")\n            return 0\n\n        dio_channel = int(self.HP34907_channel + channel)\n        self.send_socket(\"SOURCE:DIGITAL:DATA:BYTE? (@{chan})\\n\".format(chan=dio_channel))\n        value = int(self.read_socket(verbosity=1))\n        diovalue = (value ^ 0xF) & 0xF\n\n        if verbosity > 1:\n            print(\"DIO output channel {chan} set to {val}.\\n\".format(chan=channel, val=value))\n\n        return value"
  },
  {
    "class_name": "Keithley_2000",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/41-endstation-serial-dev.py",
    "source": "class Keithley_2000(Device):\n    # Note: Command terminator is a carriage-return character \\r.\n    # Settings as of 07/25/2017: Baud rate = 19200 bits/s, Stop bits = 1, Parity = None, Flow control = None\n    # Moxa port 10: socket = 10.11.130.53:4010\n\n    def __init__(\n        self,\n        prefix=\"\",\n        *args,\n        read_attrs=None,\n        configuration_attrs=None,\n        name=\"Keithley_2000\",\n        parent=None,\n        **kwargs,\n    ):\n        super().__init__(\n            prefix=prefix,\n            *args,\n            read_attrs=read_attrs,\n            configuration_attrs=configuration_attrs,\n            name=name,\n            parent=parent,\n            **kwargs,\n        )\n\n        # self.port_number = 10\n        # self.server_port = 4000 + self.port_number\n        self.connect_socket()\n\n    # Essential socket interaction\n    ########################################\n\n    def connect_socket(self):\n        # self.server_address= '10.11.130.51'\n        # self.server_address= '10.11.130.53'     # Moxa inside Endstation hutch\n        self.server_address = \"10.68.82.73\"  # NEW IP, 20201112\n        # self.server_IP = '10.11.129.2'\n        self.port_number = 10\n        self.server_port = 4000 + self.port_number\n\n        import socket\n\n        # self.sock = socket.socket()\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(self.server_address)\n        self.sock.connect((self.server_address, self.server_port))\n\n        self.sock.settimeout(0.5)\n\n    def disconnect_socket(self):\n        self.sock.close()\n\n    def send_socket(self, msg):\n        # self.sock.send(chr(13).encode('ascii', 'ignore')) # Carriage return\n        self.sock.send(msg.encode(\"ascii\", \"ignore\"))\n        # self.sock.send(msg.encode('utf-8'))\n\n    def send_get_reply(self, msg, verbosity=3):\n        # self.send_socket('\\r')\n        self.send_socket(msg)\n\n        time.sleep(0.5)\n\n        return self.read_socket(verbosity=verbosity)\n\n    def read_socket(self, timeout_s=3, verbosity=3):\n        start_time = time.time()\n        terminator = chr(0x18)\n\n        # Look for the response\n        amount_received = 0\n        amount_cutoff = 5000\n\n        txt = \"\"\n        msg_received = \"\"\n\n        while terminator not in txt and time.time() - start_time < timeout_s and amount_received < amount_cutoff:\n            try:\n                data = self.sock.recv(1)\n            except:\n                break\n\n            amount_received += len(data)\n            txt = data.decode(\"ascii\")\n\n            msg_received += txt\n\n        msg_received = msg_received.replace(terminator, \"\")\n\n        if time.time() - start_time > timeout_s:\n            if verbosity >= 1:\n                print(\"Read timeout after {:.1f} s.\".format(time.time() - start_time))\n            return \"\"\n\n        else:\n            if verbosity >= 2:\n                print(msg_received)\n            return msg_received\n\n    # Select the channel for reading\n    def selectChannel(self, channel, verbosity=1):\n        if channel < 1 or channel > 10:\n            print(\"Invalid channel number; must be between 1 and 10.\\n\")\n            return 0\n\n        self.send_socket(\":ROUT:CLOS (@{chan})\\r\".format(chan=channel))\n\n        if verbosity > 1:\n            print(\"Keithley 2000 channel set to {chan}.\\n\".format(chan=channel))\n\n        return 1\n\n    # Read resistance on the selected channel\n    def readOhm(self, channel, verbosity=1):\n        self.selectChannel(channel, verbosity=1)\n        time.sleep(0.2)\n        self.send_socket(\":SENS:FUNC 'RES'\\r\")\n        time.sleep(0.1)\n        self.send_socket(\":SENS:DATA?\\r\")\n        time.sleep(0.1)\n        ohm = float(self.read_socket(verbosity=1))\n\n        if verbosity > 1:\n            print(\"The resistance on channel {chan} is {res} Ohm.\\n\".format(chan=channel, res=ohm))\n\n        return ohm\n\n    # Read DC voltage on the selected channel\n    def readDCV(self, channel, verbosity=1):\n        self.selectChannel(channel, verbosity=1)\n        time.sleep(0.2)\n        self.send_socket(\":SENS:FUNC 'VOLT:DC'\\r\")\n        time.sleep(0.1)\n        self.send_socket(\":SENS:DATA?\\r\")\n        time.sleep(0.1)\n        dcv = float(self.read_socket(verbosity=1))\n\n        if verbosity > 1:\n            print(\"The DC voltage on channel {chan} is {volts} VDC.\\n\".format(chan=channel, volts=dcv))\n\n        return dcv\n\n    # Read 30 kOhm thermistor on the selected channel and return T[degC]\n    def readThermister30kohm(self, channel, verbosity=1):\n        ohm = self.readOhm(channel, verbosity=1)\n\n        coeff_a = 0.000932681\n        coeff_b = 0.000221455\n        coeff_c = 0.000000126\n\n        Temp = coeff_a\n        Temp += coeff_b * numpy.log(ohm)\n        Temp += coeff_c * (numpy.log(ohm)) ** 3\n        Temp = 1.0 / Temp - 273.15\n\n        if verbosity > 1:\n            print(\n                \"The temperature (30k-ohm thermistor) on channel {chan} is {degC} degC.\\n\".format(\n                    chan=channel, degC=Temp\n                )\n            )\n\n        return Temp\n\n    # Read 100 kOhm thermistor on the selected channel and return T[degC]\n    def readThermister100kohm(self, channel, verbosity=1):\n        ohm = self.readOhm(channel, verbosity=1)\n\n        coeff_a = 0.000827094\n        coeff_b = 0.000204256\n        coeff_c = 1.15042e-07\n\n        Temp = coeff_a\n        Temp += coeff_b * numpy.log(ohm)\n        Temp += coeff_c * (numpy.log(ohm)) ** 3\n        Temp = 1.0 / Temp - 273.15\n\n        if verbosity > 1:\n            print(\n                \"The temperature (100k-ohm thermistor) on channel {chan} is {degC} degC.\\n\".format(\n                    chan=channel, degC=Temp\n                )\n            )\n\n        return Temp\n\n    # Read Pt100 RTD on the selected channel and return T[degC]\n    def readPt100(self, channel, verbosity=1):\n        ohm = self.readOhm(channel, verbosity=1)\n\n        # Conversion formula from:\n        # http://www.mosaic-industries.com/embedded-systems/microcontroller-projects/temperature-measurement/platinum-rtd-sensors/resistance-calibration-table\n        c0 = -245.19\n        c1 = 2.5293\n        c2 = -0.066046\n        c3 = 4.0422e-3\n        c4 = -2.0697e-6\n        c5 = -0.025422\n        c6 = 1.6883e-3\n        c7 = -1.3601e-6\n\n        Temp = ohm * (c1 + ohm * (c2 + ohm * (c3 + c4 * ohm)))\n        Temp /= 1.0 + ohm * (c5 + ohm * (c6 + c7 * ohm))\n        Temp += c0\n\n        if verbosity > 1:\n            print(\n                \"The temperature (Pt100 RTD) on channel {chan} is {degC} degC.\\n\".format(chan=channel, degC=Temp)\n            )\n\n        return Temp"
  },
  {
    "class_name": "Minichiller",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/41-endstation-serial-dev.py",
    "source": "class Minichiller(Device):\n    # Note: Command terminator is a carriage-return character \\r.\n    # Settings as of 10/09/2017: Baud rate = 9600 bits/s, Stop bits = 1, Parity = None, Flow control = None\n    # Moxa port 11: socket = 10.11.130.53:4011\n\n    def __init__(\n        self,\n        prefix=\"\",\n        *args,\n        read_attrs=None,\n        configuration_attrs=None,\n        name=\"Minichiller\",\n        parent=None,\n        **kwargs,\n    ):\n        super().__init__(\n            prefix=prefix,\n            *args,\n            read_attrs=read_attrs,\n            configuration_attrs=configuration_attrs,\n            name=name,\n            parent=parent,\n            **kwargs,\n        )\n\n        # self.port_number = 11\n        # self.server_port = 4000 + self.port_number\n        self.connect_socket()\n\n    # Essential socket interaction\n    ########################################\n\n    def connect_socket(self):\n        # self.server_address= '10.11.130.51'\n        # self.server_address= '10.11.130.53'     # Moxa inside Endstation hutch\n        self.server_address = \"10.68.82.73\"  # NEW IP, 20201112\n        # self.server_IP = '10.11.129.2'\n        self.port_number = 11\n        self.server_port = 4000 + self.port_number\n\n        import socket\n\n        # self.sock = socket.socket()\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(self.server_address)\n        self.sock.connect((self.server_address, self.server_port))\n\n        self.sock.settimeout(0.5)\n\n    def disconnect_socket(self):\n        self.sock.close()\n\n    def send_socket(self, msg):\n        # self.sock.send(chr(13).encode('ascii', 'ignore')) # Carriage return\n        self.sock.send(msg.encode(\"ascii\", \"ignore\"))\n        # self.sock.send(msg.encode('utf-8'))\n\n    def send_get_reply(self, msg, verbosity=3):\n        # self.send_socket('\\r')\n        self.send_socket(msg)\n\n        time.sleep(0.5)\n\n        return self.read_socket(verbosity=verbosity)\n\n    def read_socket(self, timeout_s=3, verbosity=3):\n        start_time = time.time()\n        terminator = chr(0x18)\n\n        # Look for the response\n        amount_received = 0\n        amount_cutoff = 5000\n\n        txt = \"\"\n        msg_received = \"\"\n\n        while terminator not in txt and time.time() - start_time < timeout_s and amount_received < amount_cutoff:\n            try:\n                data = self.sock.recv(1)\n            except:\n                break\n\n            amount_received += len(data)\n            txt = data.decode(\"ascii\")\n\n            msg_received += txt\n\n        msg_received = msg_received.replace(terminator, \"\")\n\n        if time.time() - start_time > timeout_s:\n            if verbosity >= 1:\n                print(\"Read timeout after {:.1f} s.\".format(time.time() - start_time))\n            return \"\"\n\n        else:\n            if verbosity >= 2:\n                print(msg_received)\n            return msg_received\n\n    # Output specified voltage on specified DAC channel\n    def setTemp(self, degC, verbosity=1):\n        if degC < 0:\n            sign = \"-\"\n        else:\n            sign = \"+\"\n\n        if abs(degC) >= 10.0 and degC < 100.0:\n            sign += \"0\"\n        if abs(degC) >= 0.0 and degC < 10.0:\n            sign += \"00\"\n        if abs(degC) >= 0.1 and degC < 1.0:\n            sign += \"000\"\n        if abs(degC) >= 0.01 and degC < 0.10:\n            sign += \"0000\"\n\n        temperature = abs(int(degC * 100))\n\n        self.send_socket(\"SP@{s}{temp}\\r\\n\".format(s=sign, temp=temperature))\n\n        if verbosity > 1:\n            self.readTemp(verbosity=verbosity)\n\n        return 1\n\n    # Query temperature in degC\n    def readTemp(self, verbosity=1):\n        self.send_socket(\"SP?\\r\\n\")\n        degC_raw = self.read_socket(verbosity=1)\n        degC = int(degC_raw[2:]) / 100.0\n\n        if verbosity > 1:\n            print(\"Temperature setpoint is set to {tt} degC.\\n\".format(tt=degC))\n\n        return degC"
  },
  {
    "class_name": "SyringePump",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/41-endstation-serial-dev.py",
    "source": "class SyringePump(Device):\n    # Note: Command terminator is a carriage-return character \\r.\n    # Settings as of 12/09/2017: Baud rate = 9600 bits/s, Stop bits = 1, Parity = None, Flow control = None\n    # Moxa port 11: socket = 10.11.130.53:4011\n\n    def __init__(\n        self,\n        prefix=\"\",\n        *args,\n        read_attrs=None,\n        configuration_attrs=None,\n        name=\"Minichiller\",\n        parent=None,\n        **kwargs,\n    ):\n        super().__init__(\n            prefix=prefix,\n            *args,\n            read_attrs=read_attrs,\n            configuration_attrs=configuration_attrs,\n            name=name,\n            parent=parent,\n            **kwargs,\n        )\n\n        # self.port_number = 11\n        # self.server_port = 4000 + self.port_number\n        self.connect_socket()\n\n    # Essential socket interaction\n    ########################################\n\n    def connect_socket(self):\n        # self.server_address= '10.11.130.51'\n        # self.server_address= '10.11.130.53'     # Moxa inside Endstation hutch\n        self.server_address = \"10.68.82.73\"  # NEW IP, 20201112\n        # self.server_IP = '10.11.129.2'\n        self.port_number = 11\n        self.server_port = 4000 + self.port_number\n\n        import socket\n\n        # self.sock = socket.socket()\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        print(self.server_address)\n        self.sock.connect((self.server_address, self.server_port))\n\n        self.sock.settimeout(0.5)\n\n    def disconnect_socket(self):\n        self.sock.close()\n\n    def send_socket(self, msg):\n        # self.sock.send(chr(13).encode('ascii', 'ignore')) # Carriage return\n        self.sock.send(msg.encode(\"ascii\", \"ignore\"))\n        # self.sock.send(msg.encode('utf-8'))\n\n    def send_get_reply(self, msg, verbosity=3):\n        # self.send_socket('\\r')\n        self.send_socket(msg)\n\n        time.sleep(0.5)\n\n        return self.read_socket(verbosity=verbosity)\n\n    def read_socket(self, timeout_s=3, verbosity=3):\n        start_time = time.time()\n        terminator = chr(0x18)\n\n        # Look for the response\n        amount_received = 0\n        amount_cutoff = 5000\n\n        txt = \"\"\n        msg_received = \"\"\n\n        while terminator not in txt and time.time() - start_time < timeout_s and amount_received < amount_cutoff:\n            try:\n                data = self.sock.recv(1)\n            except:\n                break\n\n            amount_received += len(data)\n            txt = data.decode(\"ascii\")\n\n            msg_received += txt\n\n        msg_received = msg_received.replace(terminator, \"\")\n\n        if time.time() - start_time > timeout_s:\n            if verbosity >= 1:\n                print(\"Read timeout after {:.1f} s.\".format(time.time() - start_time))\n            return \"\"\n\n        else:\n            if verbosity >= 2:\n                print(msg_received)\n            return msg_received\n\n    # TODO:command input, including setting of speed and direction, inject , purge....\n    # Output specified voltage on specified DAC channel\n    def setTemp(self, degC, verbosity=1):\n        if degC < 0:\n            sign = \"-\"\n        else:\n            sign = \"+\"\n\n        if abs(degC) >= 10.0 and degC < 100.0:\n            sign += \"0\"\n        if abs(degC) >= 0.0 and degC < 10.0:\n            sign += \"00\"\n        if abs(degC) >= 0.1 and degC < 1.0:\n            sign += \"000\"\n        if abs(degC) >= 0.01 and degC < 0.10:\n            sign += \"0000\"\n\n        temperature = abs(int(degC * 100))\n\n        self.send_socket(\"SP@{s}{temp}\\r\\n\".format(s=sign, temp=temperature))\n\n        if verbosity > 1:\n            self.readTemp(verbosity=verbosity)\n\n        return 1\n\n    # Query temperature in degC\n    def readTemp(self, verbosity=1):\n        self.send_socket(\"SP?\\r\\n\")\n        degC_raw = self.read_socket(verbosity=1)\n        degC = int(degC_raw[2:]) / 100.0\n\n        if verbosity > 1:\n            print(\"Temperature setpoint is set to {tt} degC.\\n\".format(tt=degC))\n\n        return degC"
  },
  {
    "class_name": "OceanOpticsSpectrometer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/52-oceanoptics.py",
    "source": "class OceanOpticsSpectrometer(Device):\n\n    # Define all the EPICS signals and read-only signals for the spectrometer\n\n    buff_capacity = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:BUFF_CAPACITY')\n\n    buff_capacity_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:BUFF_CAPACITY_RBV')\n\n    buff_element_count_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:BUFF_ELEMENT_COUNT_RBV')\n\n    buff_max_capacity_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:BUFF_MAX_CAPACITY_RBV')\n\n    buff_min_capacity_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:BUFF_MIN_CAPACITY_RBV')\n\n    collect_mode = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:COLLECT_MODE')\n\n    collect_mode_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:COLLECT_MODE_RBV')\n\n    collect_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:COLLECT_RBV')\n\n    connected_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:CONNECTED_RBV')\n\n    correction = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:CORRECTION')\n\n    correction_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:CORRECTION_RBV')\n\n    curr_tec_temp_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:CURR_TEC_TEMP_RBV')\n\n    dark_available_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:DARK_AVAILABLE_RBV')\n\n    edc = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:EDC')\n\n    edc_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:EDC_RBV')\n\n    features_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:FEATURES_RBV')\n\n    integration_time = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:INTEGRATION_TIME')\n\n    integration_time_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:INTEGRATION_TIME_RBV')\n\n    int_max_time_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:INT_MAX_TIME_RBV')\n\n    int_min_time_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:INT_MIN_TIME_RBV')\n\n    light_source = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:LIGHT_SOURCE')\n\n    light_source_count_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:LIGHT_SOURCE_COUNT_RBV')\n\n    light_source_intensity = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:LIGHT_SOURCE_INTENSITY')\n\n    light_source_intensity_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:LIGHT_SOURCE_INTENSITY_RBV')\n\n    light_source_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:LIGHT_SOURCE_RBV')\n\n    model = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:MODEL')\n\n    nlc = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:NLC')\n\n    nlc_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:NLC_RBV')\n\n    num_spectra = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:NUM_SPECTRA')\n\n    num_spectra_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:NUM_SPECTRA_RBV')\n\n    output = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:OUTPUT')\n\n    ref_available_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:REF_AVAILABLE_RBV')\n\n    serial = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:SERIAL')\n\n    shutter = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:SHUTTER')\n\n    shutter_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:SHUTTER_RBV')\n\n    spectra_collected_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:SPECTRA_COLLECTED_RBV')\n\n    spectrum_type = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:SPECTRUM_TYPE')\n\n    spectrum_type_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:SPECTRUM_TYPE_RBV')\n\n    status = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:STATUS')\n\n    status_msg = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:STATUS_MSG')\n\n    strobe = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:STROBE')\n\n    strobe_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:STROBE_RBV')\n\n    subtract_format = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:SUBTRACT_FORMAT')\n\n    subtract_format_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:SUBTRACT_FORMAT_RBV')\n\n    tec = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:TEC')\n\n    tec_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:TEC_RBV')\n\n    tec_temp = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:TEC_TEMP')\n\n    tec_temp_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:TEC_TEMP_RBV')\n\n    trigger_mode = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:TRIGGER_MODE')\n\n    trigger_mode_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:TRIGGER_MODE_RBV')\n\n    x_axis = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:X_AXIS')\n\n    x_axis_format = Cpt(EpicsSignal, 'XF:11BM-ES{OceanOptics:Spec-1}:X_AXIS_FORMAT')\n\n    x_axis_format_rbv = Cpt(EpicsSignalRO, 'XF:11BM-ES{OceanOptics:Spec-1}:X_AXIS_FORMAT_RBV')\n\n\n    # Function to get the value of BUFF_CAPACITY\n\n    def get_buff_capacity(self):\n\n        return self.buff_capacity.get()\n\n\n    # Function to set the value of BUFF_CAPACITY\n\n    def set_buff_capacity(self, value):\n\n        self.buff_capacity.put(value)\n\n\n    # Function to get the readback value of BUFF_CAPACITY\n\n    def get_buff_capacity_rbv(self):\n\n        return self.buff_capacity_rbv.get()\n\n\n    # Function to get the readback value of BUFF_ELEMENT_COUNT\n\n    def get_buff_element_count_rbv(self):\n\n        return self.buff_element_count_rbv.get()\n\n\n    # Function to get the readback value of BUFF_MAX_CAPACITY\n\n    def get_buff_max_capacity_rbv(self):\n\n        return self.buff_max_capacity_rbv.get()\n\n\n    # Function to get the readback value of BUFF_MIN_CAPACITY\n\n    def get_buff_min_capacity_rbv(self):\n\n        return self.buff_min_capacity_rbv.get()\n\n\n    # Function to get the value of COLLECT_MODE\n\n    def get_collect_mode(self):\n\n        return self.collect_mode.get()\n\n\n    # Function to set the value of COLLECT_MODE\n\n    def set_collect_mode(self, value):\n\n        return self.set_collect_mode.set(value)"
  },
  {
    "class_name": "MotorCenterAndGap",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/10-motors.py",
    "source": "class MotorCenterAndGap(Device):\n    \"Center and gap using Epics Motor records\"\n    xc = Cpt(EpicsMotor, \"-Ax:XC}Mtr\")\n    yc = Cpt(EpicsMotor, \"-Ax:YC}Mtr\")\n    xg = Cpt(EpicsMotor, \"-Ax:XG}Mtr\")\n    yg = Cpt(EpicsMotor, \"-Ax:YG}Mtr\")"
  },
  {
    "class_name": "Blades",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/10-motors.py",
    "source": "class Blades(Device):\n    \"Actual T/B/O/I and virtual center/gap using Epics Motor records\"\n    tp = Cpt(EpicsMotor, \"-Ax:T}Mtr\")\n    bt = Cpt(EpicsMotor, \"-Ax:B}Mtr\")\n    ob = Cpt(EpicsMotor, \"-Ax:O}Mtr\")\n    ib = Cpt(EpicsMotor, \"-Ax:I}Mtr\")\n    xc = Cpt(EpicsMotor, \"-Ax:XCtr}Mtr\")\n    yc = Cpt(EpicsMotor, \"-Ax:YCtr}Mtr\")\n    xg = Cpt(EpicsMotor, \"-Ax:XGap}Mtr\")\n    yg = Cpt(EpicsMotor, \"-Ax:YGap}Mtr\")"
  },
  {
    "class_name": "Filter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/10-motors.py",
    "source": "class Filter(Device):\n    \"Attenuator filters\"\n    sts = Cpt(EpicsSignal, \"Pos-Sts\")\n    in_cmd = Cpt(EpicsSignal, \"In-Cmd\")\n    out_cmd = Cpt(EpicsSignal, \"Out-Cmd\")"
  },
  {
    "class_name": "LinkamThermal",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/51-linkam-stages.py",
    "source": "class LinkamThermal(Device):\n    # Set-and-read signals\n    cmd = Cpt(EpicsSignal, \"STARTHEAT\")\n    temperature_setpoint = Cpt(EpicsSignal, \"SETPOINT:SET\")\n    temperature_rate_setpoint = Cpt(EpicsSignal, \"RAMPRATE:SET\")\n\n    # Read-Only signals\n    status_power = Cpt(EpicsSignalRO, \"STARTHEAT\")\n    status_code = Cpt(EpicsSignalRO, \"STATUS\")\n    # status_code = Cpt(EpicsSignal, 'STATUS')\n    # done = Cpt(AtSetpoint, parent_attr = 'status_code')\n    temperature_current = Cpt(EpicsSignalRO, \"TEMP\")\n    temperature_rate_current = Cpt(EpicsSignalRO, \"RAMPRATE\")\n\n    # not commonly used\n    init = Cpt(EpicsSignal, \"INIT\")\n    model_array = Cpt(EpicsSignal, \"MODEL\")\n    serial_array = Cpt(EpicsSignal, \"SERIAL\")\n    stage_model_array = Cpt(EpicsSignal, \"STAGE:MODEL\")\n    stage_serial_array = Cpt(EpicsSignal, \"STAGE:SERIAL\")\n    firm_ver = Cpt(EpicsSignal, \"FIRM:VER\")\n    hard_ver = Cpt(EpicsSignal, \"HARD:VER\")\n    ctrllr_err = Cpt(EpicsSignal, \"CTRLLR:ERR\")\n    config = Cpt(EpicsSignal, \"CONFIG\")\n    stage_config = Cpt(EpicsSignal, \"STAGE:CONFIG\")\n    disable = Cpt(EpicsSignal, \"DISABLE\")\n    dsc = Cpt(EpicsSignal, \"DSC\")\n    # RR_set = Cpt(EpicsSignal, 'RAMPRATE:SET')\n    # RR = Cpt(EpicsSignal, 'RAMPRATE')\n    ramptime = Cpt(EpicsSignal, \"RAMPTIME\")\n    # startheat = Cpt(EpicsSignal, 'STARTHEAT')\n    holdtime_set = Cpt(EpicsSignal, \"HOLDTIME:SET\")\n    holdtime = Cpt(EpicsSignal, \"HOLDTIME\")\n    power = Cpt(EpicsSignalRO, \"POWER\")\n    lnp_speed = Cpt(EpicsSignal, \"LNP_SPEED\")\n    lnp_mode_set = Cpt(EpicsSignal, \"LNP_MODE:SET\")\n    lnp_speed_set = Cpt(EpicsSignal, \"LNP_SPEED:SET\")\n\n    def on(self):\n        while self.cmd.get() != 1:\n            time.sleep(0.2)\n            self.cmd.put(1)\n        return self.cmd.get()\n\n    def _on(self):\n        yield from bps.mv(self.cmd, 1)\n\n    def off(self):\n        while self.cmd.get() != 0:\n            time.sleep(0.2)\n            self.cmd.put(0)\n        return self.cmd.get()\n\n    def _off(self):\n        yield from bps.mv(self.cmd, 0)\n\n    def setTemperature(self, temperature):\n        while self.temperature_setpoint.get() != temperature:\n            time.sleep(0.2)\n            self.temperature_setpoint.put(temperature)\n        return self.temperature_setpoint.get()\n\n    def setTemperatureRate(self, temperature_rate):\n        while self.temperature_rate_setpoint.get() != temperature_rate:\n            time.sleep(0.2)\n            self.temperature_rate_setpoint.put(temperature_rate)\n        return self.temperature_rate_setpoint.get()\n\n    def temperature(self):\n        return self.temperature_current.get()\n\n    def temperatureRate(self):\n        return self.temperature_rate_current.get()\n\n    @property\n    def serial(self):\n        return self.arr2word(self.serial_array.get())\n\n    @property\n    def model(self):\n        return self.arr2word(self.model_array.get())\n\n    @property\n    def stage_model(self):\n        return self.arr2word(self.stage_model_array.get())\n\n    @property\n    def stage_serial(self):\n        return self.arr2word(self.stage_serial_array.get())\n\n    @property\n    def firmware_version(self):\n        return self.arr2word(self.firm_ver.get())\n\n    @property\n    def hardware_version(self):\n        return self.arr2word(self.hard_ver.get())\n\n    def status(self):\n        text = f\"\\nCurrent temperature = {self.temperature():.1f}, setpoint = {self.temperature_setpoint.get():.1f}\\n\\n\"\n        code = int(self.status_code.get())\n\n        if code & 1:  # Error\n            text += \"Error        : yes\" + \"\\n\"\n        else:\n            text += \"Error        : no\\n\"\n        if code & 2:  # at setpoint\n            text += \"At setpoint  : yes\" + \"\\n\"\n        else:\n            text += \"At setpoint  : no\\n\"\n        if code & 4:  # heater\n            text += \"Heater       : on\" + \"\\n\"\n        else:\n            text += \"Heater       : off\\n\"\n        if code & 8:  # pump\n            text += \"Pump         : on\" + \"\\n\"\n        else:\n            text += \"Pump         : off\\n\"\n        if code & 16:  # pump auto\n            text += \"Pump Auto    : yes\" + \"\\n\"\n        else:\n            text += \"Pump Auto    : no\\n\"\n\n        print(text)"
  },
  {
    "class_name": "ioLogik",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/43-endstation-ioLogik.py",
    "source": "class ioLogik(Device):\n    def __init__(\n        self, prefix=\"\", *args, read_attrs=None, configuration_attrs=None, name=\"ioLogik\", parent=None, **kwargs\n    ):\n        super().__init__(\n            prefix=prefix,\n            *args,\n            read_attrs=read_attrs,\n            configuration_attrs=configuration_attrs,\n            name=name,\n            parent=parent,\n            **kwargs,\n        )\n\n    def read(self, port):\n        if port is not None and port in AO + AO2 + AI + RTD + TC + Relay + DI:\n            return caget(port.sts)\n        else:\n            print(\"The port is not valid\")\n\n    def set(self, port, val, verbosity=3):\n        if port is not None and port in AO + AO2:\n            if val > 10 or val < 0:\n                print(\"Out of input range. It must be in range of (0, 10).\")\n                return caput(port.sp, 0)\n            else:\n                caput(port.sp, val)\n                if verbosity >= 3:\n                    time.sleep(0.2)\n                    return print(\"The {} is set as {}.\".format(port.name, self.read(port)))\n        else:\n            print(\"The port is not valid.\")\n\n    def setOn(self, port):\n        if port is not None and port in Relay:\n            caput(port.sp, 1)\n            # re-check the port value\n            if self.read(port) == 1:\n                print(\"{} is turned on.\".format(port.name))\n            else:\n                print(\"{} is turned off.\".format(port.name))\n        else:\n            print(\"The port is not valid\")\n\n    def setOff(self, port):\n        if port is not None and port in Relay:\n            caput(port.sp, 0)\n            time.sleep(0.2)\n            if self.read(port) == 1:\n                print(\"{} is turned on.\".format(port.name))\n            else:\n                print(\"{} is turned off.\".format(port.name))\n        else:\n            print(\"The port is not valid\")\n\n    def readRH(\n        self,\n        AI_chan,\n        temperature=25.0,\n        voltage_supply=5.0,\n        coeff_slope=0.030,\n        coeff_offset=0.787,\n        verbosity=3,\n    ):\n        voltage_out = self.read(AI[AI_chan])\n        corr_voltage_out = voltage_out * (5.0 / voltage_supply)\n        # For sensor #220 used for SVA chamber\n        # coeff_offset = 0.788 #from the certificate\n        # coeff_offset = 0.746 #from the environment of RH=0\n        # coeff_slope = 0.029\n\n        # For sensor used for Linkam tensile stage\n        # coeff_offset = 0.787\n        # coeff_slope = 0.030\n\n        # For sensor 114 used for environmental bar\n        # coeff_offset = 0.787\n        # coeff_slope = 0.030\n\n        # For sensor 43 used in humidity stage\n        # coeff_offset = 0.816887\n        # coeff_slope = 0.028813\n\n        # Sensor 43 is broken. For sensor 42 used in humidity stage\n        coeff_offset = 0.814\n        coeff_slope = 0.029\n\n        sensor_RH = (corr_voltage_out - coeff_offset) / coeff_slope\n\n        true_RH = sensor_RH / (1.0546 - 0.00216 * temperature)  # T in [degC]\n\n        if verbosity >= 3:\n            print(\"Raw sensor RH = {:.3f} pct.\".format(sensor_RH))\n            print(\"T-corrected RH = {:.3f} pct at {:.3f} degC.\".format(true_RH, temperature))\n        return true_RH"
  },
  {
    "class_name": "MassFlowControl",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/43-endstation-ioLogik.py",
    "source": "class MassFlowControl(Device):\n    def __init__(self):\n        self.setDevice()\n        # self.FlowRate_Sts = 'XF:11BMB-ES{FC:1}F-I'\n        # self.FlowRate_SP = 'XF:11BMB-ES{FC:1}F:SP-SP'\n        # self.Mode_Sts = 'XF:11BMB-ES{FC:1}Mode:Opr-Sts'\n        # self.Mode_SP = 'XF:11BMB-ES{FC:1}Mode:Opr-Sel'\n        # self.ScaleFactor_SP = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-SP'\n        # self.ScaleFactor_Sts = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-RB'\n        # self.NominalRange_SP = 'XF:11BMB-ES{FC:1}F:FullRng-SP'\n        # self.NominalRange_Sts = 'XF:11BMB-ES{FC:1}F:FullRng-RB'\n\n    def setDevice(self, device=\"A1\"):\n        if device == \"A1\":\n            device_no = 1\n        elif device == \"A2\":\n            device_no = 2\n        elif device == \"B1\":\n            device_no = 3\n        elif device == \"B2\":\n            device_no = 4\n        else:\n            print(\"The device is NOT valid.\")\n            device_no = 1\n        print(\"Select Device {} in port {}\".format(device_no, device))\n        self.device = device\n\n        self.FlowRate_Sts = \"XF:11BMB-ES{{FC:{}}}F-I\".format(device_no)\n        self.FlowRate_SP = \"XF:11BMB-ES{{FC:{}}}F:SP-SP\".format(device_no)\n        self.Mode_Sts = \"XF:11BMB-ES{{FC:{}}}Mode:Opr-Sts\".format(device_no)\n        self.Mode_SP = \"XF:11BMB-ES{{FC:{}}}Mode:Opr-Sel\".format(device_no)\n        self.ScaleFactor_SP = \"XF:11BMB-ES{{FC:{}}}Val:ScaleFactor-SP\".format(device_no)\n        self.ScaleFactor_Sts = \"XF:11BMB-ES{{FC:{}}}Val:ScaleFactor-RB\".format(device_no)\n        self.NominalRange_SP = \"XF:11BMB-ES{{FC:{}}}F:FullRng-SP\".format(device_no)\n        self.NominalRange_Sts = \"XF:11BMB-ES{{FC:{}}}F:FullRng-RB\".format(device_no)\n\n        self._FlowRate_Sts = Cpt(EpicsSignal, \"{{FC:{}}}F-I\".format(device_no))\n        self._FlowRate_SP = Cpt(EpicsSignal, \"{{FC:{}}}F:SP-SP\".format(device_no))\n        self._Mode_Sts = Cpt(EpicsSignal, \"{{FC:{}}}Mode:Opr-Sts\".format(device_no))\n        self._Mode_SP = Cpt(EpicsSignal, \"{{FC:{}}}Mode:Opr-Sel\".format(device_no))\n        self._ScaleFactor_SP = Cpt(EpicsSignal, \"{{FC:{}}}Val:ScaleFactor-SP\".format(device_no))\n        self._ScaleFactor_Sts = Cpt(EpicsSignal, \"{{FC:{}}}Val:ScaleFactor-RB\".format(device_no))\n        self._NominalRange_SP = Cpt(EpicsSignal, \"{{FC:{}}}F:FullRng-SP\".format(device_no))\n        self._NominalRange_Sts = Cpt(EpicsSignal, \"{{FC:{}}}F:FullRng-RB\".format(device_no))\n\n\n        # self.FlowRate_Sts = 'XF:11BMB-ES{{FC:{}}}F-I'.format(device_no)\n\n        return device_no\n\n    def setFlow(self, rate, device=None, tolerence=1, verbosity=3):\n        # set the setpoint of flow\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n\n        if rate < self.deviceRange(verbosity=0) * 0.02:\n            print(\"The rate is too low. (<2pct of the range)\")\n            return\n\n        caput(self.FlowRate_SP, rate)\n        if verbosity >= 3:\n            print(\"The flow rate has been set to {}\".format(rate))\n            print(\"The current flow rate is {}\".format(caget(self.FlowRate_Sts)))\n        return caget(self.FlowRate_Sts)\n\n    def flow(self, device=None, verbosity=3):\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n        if verbosity >= 3:\n            print(\"The current flow rate is {}\".format(caget(self.FlowRate_Sts)))\n        return caget(self.FlowRate_Sts)\n\n    def setMode(self, mode, device=None, verbosity=3):\n        # mode can be 0: OPEN, 1: Close, 2: SetPoint\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n\n        if mode not in range(0, 3):\n            return print(\"The input has to be 0: OPEN, 1: Close, 2: SetPoint\")\n        else:\n            caput(self.Mode_SP, mode)\n            while self.mode(device=device) != mode:\n                time.sleep(0.2)\n                caput(self.Mode_SP, mode)\n            if verbosity >= 3:\n                self.mode(device=device)\n            return caget(self.Mode_Sts)\n\n    def mode(self, device=None, verbosity=3):\n        # OP mode: 0: OPEN, 1: Close, 2: SetPoint\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n        if verbosity >= 3:\n            self.readMode(device=device)\n        return caget(self.Mode_Sts)\n\n    def readMode(self, device=None, verbosity=3):\n        # OP mode: 0: OPEN, 1: Close, 2: SetPoint\n        if device == None:\n            device = self.device\n        self.setDevice(device=device)\n        if caget(self.Mode_Sts) == 0:\n            return print(\"The current mode is {}\".format(\"ON\"))\n        if caget(self.Mode_Sts) == 1:\n            return print(\"The current mode is {}\".format(\"OFF\"))\n        if caget(self.Mode_Sts) == 2:\n            return print(\"The current mode is {}\".format(\"SETPOINT\"))\n\n    def scaleFactor(self, device=None, verbosity=3):\n        # The scale factor depends on the gas.\n        # N2 and air are default as 1. Helium is 0.18.\n        # More details are listed in the manual.\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n        if verbosity >= 3:\n            print(\"The scale factor is {}\".format(caget(self.ScaleFactor_Sts)))\n        return caget(self.ScaleFactor_Sts)\n\n    def setScaleFactor(self, val, device=None, verbosity=3):\n        # Three modes: 0: OPEN, 1: Close, 2: SetPoint\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n\n        caput(self.ScaleFactor_SP, val)\n        while abs(self.scaleFactor() - val) > 0.02:\n            time.sleep(1)\n            caput(self.ScaleFactor_SP, val)\n        if verbosity >= 3:\n            self.scaleFactor()\n        return caget(self.ScaleFactor_Sts)\n\n    def deviceRange(self, device=None, verbosity=3):\n        # Set the device by seting the Nominal Range.\n        # Model 201: 20SCCM.\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n        if verbosity >= 3:\n            print(\"The range of this MFC device is up to {} SCCM.\".format(caget(self.NominalRange_Sts)))\n        return caget(self.NominalRange_Sts)\n\n    def setDeviceRange(self, val, device=None, verbosity=3):\n        # Set the device by seting the Nominal Range.\n        # Model 201: 20SCCM.\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n\n        caput(self.NominalRange_SP, val)\n        while abs(self.deviceRange() - val) > 1:\n            time.sleep(1)\n            caput(self.NominalRange_SP, val)\n        if verbosity >= 3:\n            self.deviceRange()\n        return caget(self.NominalRange_Sts)"
  },
  {
    "class_name": "MassFlowControl_YF",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/43-endstation-ioLogik.py",
    "source": "class MassFlowControl_YF(Device):\n    # def __init__(self):\n    #     self.setDevice()\n        # self.FlowRate_Sts = 'XF:11BMB-ES{FC:1}F-I'\n        # self.FlowRate_SP = 'XF:11BMB-ES{FC:1}F:SP-SP'\n        # self.Mode_Sts = 'XF:11BMB-ES{FC:1}Mode:Opr-Sts'\n        # self.Mode_SP = 'XF:11BMB-ES{FC:1}Mode:Opr-Sel'\n        # self.ScaleFactor_SP = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-SP'\n        # self.ScaleFactor_Sts = 'XF:11BMB-ES{FC:1}Val:ScaleFactor-RB'\n        # self.NominalRange_SP = 'XF:11BMB-ES{FC:1}F:FullRng-SP'\n        # self.NominalRange_Sts = 'XF:11BMB-ES{FC:1}F:FullRng-RB'\n\n    def setDevice(self, device=\"A1\"):\n        if device == \"A1\":\n            device_no = 1\n        elif device == \"A2\":\n            device_no = 2\n        elif device == \"B1\":\n            device_no = 3\n        elif device == \"B2\":\n            device_no = 4\n        else:\n            print(\"The device is NOT valid.\")\n            device_no = 1\n        print(\"Select Device {} in port {}\".format(device_no, device))\n        self.device = device\n\n        self._FlowRate_Sts = Cpt(EpicsSignal, \"{{FC:{}}}F-I\".format(device_no))\n        self._FlowRate_SP = Cpt(EpicsSignal, \"{{FC:{}}}F:SP-SP\".format(device_no))\n        self._Mode_Sts = Cpt(EpicsSignal, \"{{FC:{}}}Mode:Opr-Sts\".format(device_no))\n        self._Mode_SP = Cpt(EpicsSignal, \"{{FC:{}}}Mode:Opr-Sel\".format(device_no))\n        self._ScaleFactor_SP = Cpt(EpicsSignal, \"{{FC:{}}}Val:ScaleFactor-SP\".format(device_no))\n        self._ScaleFactor_Sts = Cpt(EpicsSignal, \"{{FC:{}}}Val:ScaleFactor-RB\".format(device_no))\n        self._NominalRange_SP = Cpt(EpicsSignal, \"{{FC:{}}}F:FullRng-SP\".format(device_no))\n        self._NominalRange_Sts = Cpt(EpicsSignal, \"{{FC:{}}}F:FullRng-RB\".format(device_no))\n\n\n        # self.FlowRate_Sts = 'XF:11BMB-ES{{FC:{}}}F-I'.format(device_no)\n\n        return device_no\n\n    def _setFlow(self, rate, device=None, tolerence=1, verbosity=3):\n        # set the setpoint of flow\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n\n        if rate < self.deviceRange(verbosity=0) * 0.02:\n            print(\"The rate is too low. (<2pct of the range)\")\n            return\n\n        yield from bps.mv(self._FlowRate_SP, rate)\n\n        if verbosity >= 3:\n            print(\"The flow rate has been set to {}\".format(rate))\n            print(\"The current flow rate is {}\".format(self._FlowRate_Sts.get()))\n        return self._FlowRate_Sts.get()\n\n    def _flow(self, device=None, verbosity=3):\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n        if verbosity >= 3:\n            print(\"The current flow rate is {}\".format(self._FlowRate_Sts.get()))\n        return self._FlowRate_Sts.get()\n    \n    def flow():\n        RE(self._flow())\n\n    def setMode(self, mode, device=None, verbosity=3):\n        # mode can be 0: OPEN, 1: Close, 2: SetPoint\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n\n        if mode not in range(0, 3):\n            return print(\"The input has to be 0: OPEN, 1: Close, 2: SetPoint\")\n        else:\n            yield from bps.mv(self._Mode_SP, mode)\n            # while self.mode(device=device) != mode:\n            #     time.sleep(0.2)\n            #     caput(self.Mode_SP, mode)\n            if verbosity >= 3:\n                self.mode(device=device)\n            return self._Mode_Sts.get()\n    def mode(self, device=None, verbosity=3):\n        # OP mode: 0: OPEN, 1: Close, 2: SetPoint\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n        if verbosity >= 3:\n            self.readMode(device=device)\n            return self._Mode_Sts.get()\n\n    def readMode(self, device=None, verbosity=3):\n        # OP mode: 0: OPEN, 1: Close, 2: SetPoint\n        if device == None:\n            device = self.device\n        self.setDevice(device=device)\n        if self._Mode_Sts.get() == 0:\n            return print(\"The current mode is {}\".format(\"ON\"))\n        if self._Mode_Sts.get() == 1:\n            return print(\"The current mode is {}\".format(\"OFF\"))\n        if self._Mode_Sts.get() == 2:\n            return print(\"The current mode is {}\".format(\"SETPOINT\"))\n\n    def scaleFactor(self, device=None, verbosity=3):\n        # The scale factor depends on the gas.\n        # N2 and air are default as 1. Helium is 0.18.\n        # More details are listed in the manual.\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n        if verbosity >= 3:\n            print(\"The scale factor is {}\".format(self._ScaleFactor_Sts.get()))\n        return self._ScaleFactor_Sts.get()\n\n    def setScaleFactor(self, val, device=None, verbosity=3):\n        # Three modes: 0: OPEN, 1: Close, 2: SetPoint\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n\n        yield from bps.mv(self._ScaleFactor_SP, val)\n        # while abs(self.scaleFactor() - val) > 0.02:\n        #     time.sleep(1)\n        #     caput(self.ScaleFactor_SP, val)\n        if verbosity >= 3:\n            self.scaleFactor()\n        return self._ScaleFactor_Sts.get()\n\n    def deviceRange(self, device=None, verbosity=3):\n        # Set the device by seting the Nominal Range.\n        # Model 201: 20SCCM.\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n        if verbosity >= 3:\n            print(\"The range of this MFC device is up to {} SCCM.\".format(self._NominalRange_Sts.get()))\n        return self._NominalRange_Sts.get()\n\n    def setDeviceRange(self, val, device=None, verbosity=3):\n        # Set the device by seting the Nominal Range.\n        # Model 201: 20SCCM.\n        if device == None:\n            device = self.device\n\n        self.setDevice(device=device)\n\n        yield from bps.mv(self._NominalRange_SP, val)\n        # while abs(self.deviceRange() - val) > 1:\n        #     time.sleep(1)\n        #     caput(self.NominalRange_SP, val)\n        if verbosity >= 3:\n            self.deviceRange()\n        return self._NominalRange_Sts.get()"
  },
  {
    "class_name": "SorrensonPowerSupply",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/43-endstation-ioLogik.py",
    "source": "class SorrensonPowerSupply(Device):\n    \"\"\"An ophyd wrapper for Sorrenson XG40 power supply\n    At CMS, communication to XG40 is through Moxa\n    where port 13 is connected to the RS232\n    port on the Sorrenson.\n\n    \"\"\"\n\n    cmd = Cpt(EpicsSignal, \"Enbl:OutMain-Cmd\")\n    status = Cpt(EpicsSignal, \"Enbl:OutMain-Sts\")\n\n    voltage = Cpt(EpicsSignalRO, \"E-I\")\n    current = Cpt(EpicsSignalRO, \"I-I\")\n\n    voltage_setpoint = Cpt(EpicsSignal, \"E:OutMain-SP\")\n    current_setpoint = Cpt(EpicsSignal, \"I-Lim\")\n\n    # XF:11BMB-ES{PS:1}Sts:Opr-Sts.BC\n    # XF:11BMB-ES{PS:1}Sts:Opr-Sts.BD\n\n    def on(self):\n        self.cmd.put(1)\n\n    def off(self):\n        self.cmd.put(0)\n\n    def _on(self):\n        return (yield from mv(self.cmd, 1))\n\n    def _off(self):\n        return (yield from mv(self.cmd, 0))\n\n    def put(self, PV, value):\n        return PV.put(value)\n\n    def _put(self, PV, value):\n        return (yield from mv(PV.put, value))\n\n    def read(self, PV):\n        return PV.get()\n\n    def state(self, verbosity=3):\n        if verbosity >= 3:\n            print(\"SPW is {}\".format(self.cms.get()))\n        return self.cmd.get()\n\n    def status(self, verbosity=3):\n        \"\"\"return current power status, V and I\"\"\"\n        if verbosity >= 3:\n            if self.state(verbosity=0) == True:\n                print(\"Current status = ON\")\n            else:\n                print(\"Current status = OFF\")\n            print(\n                \"Current V = {:.1f}, setpoint V = {:.1f}.\".format(self.voltage.get(), self.voltage_setpoint.get())\n            )\n            print(\"Current I = {:.1f}, limit I = {:.1f}.\".format(self.current.get(), self.current_setpoint.get()))\n        return self.state(verbosity=0), self.voltage.get(), self.current.get()\n\n    def setVoltageLinear(self, Vstart, Vend, period, wait_time=0.1, verbosity=3):\n        start_time = time.time()\n\n        while time.time() - start_time < period + 0.01:\n            self.put(\n                self.voltage_setpoint,\n                Vstart + (Vend - Vstart) * (time.time() - start_time) / period,\n            )\n            print(time.time() - start_time)\n            time.sleep(wait_time)\n\n    def getVoltage(self):\n        return self.read(self.voltage)\n\n    def setVoltage(self, voltage, verbosity=3):\n        self.put(self.voltage_setpoint, voltage)\n        start_time = time.time()\n        while abs(self.voltage.get() - voltage) > 0.01 and time.time() - start_time < 1:\n            time.sleep(0.1)\n        return self.voltage.get()\n\n    def setCurrent(self, current, verbosity=3):\n        self.put(self.current_setpoint, current)\n        start_time = time.time()\n        while abs(self.current.get() - current) > 0.01 and time.time() - start_time < 1:\n            time.sleep(0.1)\n        return self.current.get()"
  },
  {
    "class_name": "Chiller",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/43-endstation-ioLogik.py",
    "source": "class Chiller(Device):\n    # On/Off:   XF:11BMB-ES{Chiller}TempCtrl\n    # Setpoint: XF:11BMB-ES{Chiller}T-SP\n    # T       : XF:11BMB-ES{Chiller}BathT_RBV\n\n    \"\"\"An ophyd wrapper for Sorrenson XG40 power supply\n    At CMS, communication to XG40 is through Moxa\n    where port 13 is connected to the RS232\n    port on the Sorrenson.\n\n    \"\"\"\n\n    cmd = Cpt(EpicsSignal, \"TempCtrl\")\n    ChillerSetpoint = Cpt(EpicsSignal, \"T-SP\")\n\n    ChillerT = Cpt(EpicsSignalRO, \"BathT_RBV\")\n\n    def on(self):\n        self.cmd.put(1)\n\n    def off(self):\n        self.cmd.put(0)\n\n    def _on(self):\n        return (yield from mv(self.cmd, 1))\n\n    def _off(self):\n        return (yield from mv(self.cmd, 0))\n\n    def setTemperature(self, value, verbosity=3):\n        if verbosity >= 3:\n            print(\"The temperature is set to {}.\".format(value))\n        return self.ChillerSetpoint.put(value)\n\n    def temperature(self, verbosity=3):\n        if verbosity >= 3:\n            print(\"The current temperature is to {}.\".format(self.ChillerT.get()))\n        return self.ChillerT.get()\n\n    def temperature_setpoint(self, verbosity=3):\n        if verbosity >= 3:\n            print(\"The set point of temperature is to {}.\".format(self.ChillerSetpoint.get()))\n        return self.ChillerSetpoint.get()"
  },
  {
    "class_name": "Potentiostats",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/43-endstation-ioLogik.py",
    "source": "class Potentiostats(Device):\n    \"\"\"An ophyd wrapper for Biologic Potentiostats\n    At CMS, there is only readout and trigger \n    The control is via the PC directly.\n\n    Channels for \n        trigger: x2,  in and out\n        voltage: x2,  AI\n        current: x2,  AI\n\n    \"\"\"\n\n    trigger_in = EpicsSignal(\"XF:11BM-ES{Ecat:DO1_3}\")\n    trigger_out = EpicsSignal(\"XF:11BM-ES{Ecat:DO1_4}\")\n    # cmd = Cpt(EpicsSignal, \"TempCtrl\")\n    # ChillerSetpoint = Cpt(EpicsSignal, \"T-SP\")\n\n    # ChillerT = Cpt(EpicsSignalRO, \"BathT_RBV\")\n\n    def triggerOut(self, verbosity=3):\n        if verbosity>=3:\n            print('Trigger out.')\n        return self.trigger_out.set(1)\n\n    def triggerIn(self, verbosity=3): #may be best for beamline control\n        #wait for trigger coming in\n        if verbosity>=3:\n            print('Trigger in.')\n        return self.trigger_in.set(1)\n\n    def read(self, channel):\n\n        return AI[channel].signal.get()\n\n    def read_voltage(self, channel=1):\n        vol = self.read(channel)\n        if vol>10:\n            return vol - 20 \n        else:\n            return vol\n\n    def read_current(self, channel=2):\n        vol = self.read(channel)\n        if vol>10:\n            return vol - 20\n        else:\n            return vol"
  },
  {
    "class_name": "archiver",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/55-archiver.py",
    "source": "class archiver(Device):\n    # setup for CMS archiver\n    def __init__(self):\n        self.bpl_url = \"http://epics-services-cms.nsls2.bnl.local:11165/mgmt/ui/metrics\"\n        self.bpl_url = self.bpl_url.removeprefix('http://')\n        self.arvconf = ArchiverConfig(self.bpl_url)\n        self.cf_update = \"/cf-update/\"\n        self.pvfinder = PVFinder(self.cf_update)\n        self.ar_url = \"http://epics-services-cms.nsls2.bnl.local:11168\"\n        self.ar_url = self.ar_url.removeprefix('http://')\n        # self.ar_url = 'http://epics-services-cms:11168'\n        self.ar_tz = \"US/Eastern\"\n        self.config = {\"url\": self.ar_url, \"timezone\": self.ar_tz}\n        self.arvReader = ArchiverReader(self.config)\n\n        self.stage = None\n        self.PVs_default = []\n        self.PVs_name_default = []\n        self.PV_dict_default = dict()\n\n    def setStage(self, stage=\"LinkamTensile\"):\n        if stage == \"LinkamTensile\":\n            self.PVs_default = [\n                \"XF:11BM-ES:{LINKAM}:TEMP\",\n                \"XF:11BM-ES:{LINKAM}:TST_MOTOR_POS\",\n                \"XF:11BM-ES:{LINKAM}:TST_FORCE\",\n                \"XF:11BM-ES:{LINKAM}:TST_STRESS\",\n            ]\n            self.PVs_name_default = [\"TEMPERATURE\", \"DISTANCE\", \"FORCE\", \"STRESS\"]\n\n    def get(self, PV):\n        pass\n\n    def getDict(self, PVs=None, PVs_name=None, verbosity=3):\n        if PVs == None and PVs_name == None:\n            PVs = self.PVs_default\n            PVs_name = self.PVs_name_default\n\n        PV_dict = dict()\n        for pv, pv_name in zip(PVs, PVs_name):\n            PV_dict.update({pv_name: {\"PV\": pv}})\n\n        if verbosity >= 3:\n            print(PV_dict)\n        self.PV_dict_default = PV_dict\n        return PV_dict\n        # return\n\n    def readPVs(self):\n        print(self.PV_dict_default)\n\n    def saveArchiver(self, scan_id=None, folder=None, PVs=None, PVs_name=None, plot=True):\n        # create the PVs for saving\n\n        PV_dict = self.getDict(PVs=PVs, PVs_name=PVs_name)\n        # find the uid\n        # idenfity the start and end points of the uid\n        #\n\n        uid_list = [[h.start[\"uid\"] for h in db(scan_id=scan_id, experimental_directory=folder)][0]]\n\n        pre = 0\n        post = 0\n\n        h0 = db[uid_list[0]]\n        md = h0.start\n        t0 = h0.start[\"time\"]\n\n        h1 = db[uid_list[-1]]\n        t1 = h1.stop[\"time\"]\n\n        since = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(t0 - pre))\n        until = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(t1 + post))\n\n        # create pandas for data storage\n        PV_df = pds.DataFrame()\n\n        for p in list(PV_dict.keys()):\n            pv = PV_dict[p][\"PV\"]\n            df = self.arvReader.get(pv, since, until)\n\n            ep_time = []\n            pv_data = []\n            for i in range(np.shape(df.time)[0]):\n                ep_time.append(datetime.timestamp(df.time[i]))\n                pv_data.append(df.data[i])\n\n            PV_df[\"a_time\"] = ep_time\n            PV_df[p] = pv_data\n\n            # time_zero=ep_time[0]\n            # ep_time=np.array(ep_time);pv_data=np.array(pv_data)\n\n            # if p == 'tot':\n            #     pv_data=pv_data-np.average(pv_data)\n            #     lab='I$_{tot}$ - <I$_{tot}$>'\n            # else:\n            #     lab='%s-position [$\\mu$m]'%p\n\n            if plot:\n                x = ep_time - t0\n                y = pv_data\n                xf, yf = butterworth_filter(x, y, order=3, span=0.005)\n\n                plt.plot(xf, yf, \"-\", label=lab)\n                plt.grid(True)\n                plt.ylabel(\"BPM position / current\")\n                plt.xlabel(\"t$_1$ [s]\")  # plt.xlabel('epoch [s]')\n\n        if plot:\n            plt.title(\"uid: %s  sample: %s\" % (md[\"uid\"][:8], md[\"sample\"]), fontsize=14)\n            plt.ylim(-2, 1)\n            plt.legend(loc=\"upper left\", bbox_to_anchor=(1.2, 0.98))\n\n        # publish\n        # PV_df.to_csv(output_name, )\n        return PV_df"
  },
  {
    "class_name": "EpicsSignalROWait",
    "bases": [
      "EpicsSignalRO"
    ],
    "file": "profile-collections/cms-profile-collection/startup/25-scalers.py",
    "source": "class EpicsSignalROWait(ophyd.EpicsSignalRO):\n    \"\"\"Customized version of EpicsSignal that has a 'wait_time' in the 'read()'\n    function. This can be used for signals that need some time to settle before\n    a value is read.\"\"\"\n\n    def __init__(self, *args, wait_time=None, **kwargs):\n        if wait_time is not None:\n            self._wait_time = wait_time\n        else:\n            self._wait_time = 0\n\n        super().__init__(*args, **kwargs)\n\n    def read(self, *args, **kwargs):\n        # print('waiting {} s'.format(self._wait_time))\n        sleep(self._wait_time)\n        return super().read(*args, **kwargs)"
  },
  {
    "class_name": "EpicsSignalROIntegrate",
    "bases": [
      "EpicsSignalRO"
    ],
    "file": "profile-collections/cms-profile-collection/startup/25-scalers.py",
    "source": "class EpicsSignalROIntegrate(ophyd.EpicsSignalRO):\n    \"\"\"Customized version of EpicsSignal that has manually integrates (averages\n    a few values). This can be used for signals that are otherwise too erratic.\"\"\"\n\n    def __init__(self, *args, wait_time=None, integrate_num=1, integrate_delay=0.01, **kwargs):\n        if wait_time is not None:\n            self._wait_time = wait_time\n        else:\n            self._wait_time = 0\n\n        self._integrate_num = integrate_num\n        self._integrate_delay = integrate_delay\n\n        super().__init__(*args, **kwargs)\n\n    def read(self, *args, **kwargs):\n        # print('waiting {} s'.format(self._wait_time))\n        sleep(self._wait_time)\n\n        value = 0.0\n        num = 0.0\n        for i in range(self._integrate_num):\n            value_current = super().read(*args, **kwargs)[self.name][\"value\"]\n            # print(value_current)\n            value += value_current\n            num += 1.0\n            sleep(self._integrate_delay)\n\n        value /= num\n\n        ret = super().read(*args, **kwargs)\n        ret[self.name][\"value\"] = value\n\n        return ret"
  },
  {
    "class_name": "TriState",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/cms-profile-collection/startup/50-bluesky-devices.py",
    "source": "class TriState(Device):\n    full = Cpt(TwoButtonShutterNC, \"V:1}\")\n    soft = Cpt(TwoButtonShutterNC, \"V:1_Soft}\")\n\n    def set(self, value):\n        if value == \"Open\":\n            return self.full.set(\"Open\")  # & self.soft.set('Open')\n        elif value == \"Soft\":\n            return self.soft.set(\"Open\") & self.full.set(\"Close\")\n        elif value == \"Close\":\n            return self.full.set(\"Close\") & self.soft.set(\"Close\")\n        else:\n            raise ValueError(\"value must be in {'Open', 'Close', 'Soft'}\")"
  },
  {
    "class_name": "BeamStop",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/12-motors.py",
    "source": "class BeamStop(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr')\n    y = Cpt(EpicsMotor, 'Y}Mtr')"
  },
  {
    "class_name": "OCMTable",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/12-motors.py",
    "source": "class OCMTable(Device):\n    ocm_y_upstream = Cpt(EpicsMotor, 'YU}Mtr')\n    ocm_y_downstream = Cpt(EpicsMotor, 'YD}Mtr')\n    ocm_x_table = Cpt(EpicsMotor, 'X}Mtr')"
  },
  {
    "class_name": "ECS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/12-motors.py",
    "source": "class ECS(Device):\n    laser_y = Cpt(EpicsMotor, 'Lsr:1-Ax:Y}Mtr')\n    reflective_foil_x = Cpt(EpicsMotor, 'Foil:1-Ax:X}Mtr')\n    filter_wheel_1_phi = Cpt(EpicsMotor, 'Fltr:Whl1-Ax:Phi}Mtr')\n    filter_wheel_2_phi = Cpt(EpicsMotor, 'Fltr:Whl2-Ax:Phi}Mtr')"
  },
  {
    "class_name": "FilterBank",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/12-motors.py",
    "source": "class FilterBank(Device):\n    flt1 = Cpt(EpicsSignal, '1}Cmd:Opn-Cmd', string=True)\n    flt2 = Cpt(EpicsSignal, '2}Cmd:Opn-Cmd', string=True)\n    flt3 = Cpt(EpicsSignal, '3}Cmd:Opn-Cmd', string=True)\n    flt4 = Cpt(EpicsSignal, '4}Cmd:Opn-Cmd', string=True)"
  },
  {
    "class_name": "FilterBankTwoButtonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/12-motors.py",
    "source": "class FilterBankTwoButtonShutter(Device):\n    flt1 = Cpt(TwoButtonShutter, '1}')\n    flt2 = Cpt(TwoButtonShutter, '2}')\n    flt3 = Cpt(TwoButtonShutter, '3}')\n    flt4 = Cpt(TwoButtonShutter, '4}')"
  },
  {
    "class_name": "PDFShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/80-areadetector2.py",
    "source": "class PDFShutter(Device):\n    cmd = C(EpicsSignal, 'Cmd-Cmd')\n    close_sts = C(EpicsSignalRO, 'Sw:Cls1-Sts')\n    open_sts = C(EpicsSignalRO, 'Sw:Opn1-Sts')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._st = None\n        self._target = None\n        self.close_sts.subscribe(self._watcher_close,\n                                 self.close_sts.SUB_VALUE)\n\n        self.open_sts.subscribe(self._watcher_open,\n                                self.open_sts.SUB_VALUE)\n\n    def set(self, value, *, wait=False, **kwargs):\n        if value not in ('Open', 'Close'):\n            raise ValueError(\n                \"must be 'Open' or 'Close', not {!r}\".format(value))\n        if wait:\n            raise RuntimeError()\n        if self._st is not None:\n            raise RuntimeError()\n        self._target = value\n        self._st = st = DeviceStatus(self, timeout=None)\n        self.cmd.put(value)\n\n        return st\n\n    def _watcher_open(self, *, old_value=None, value=None, **kwargs):\n        print(\"in open watcher\", old_value, value)\n        if self._target != 'Open':\n            return\n        if self._st is None:\n            return\n\n        if new_value:\n            self._st._finished()\n            self._target = None\n            self._st = None\n        print(\"in open watcher\")\n\n    def _watcher_close(self, *, old_value=None, value=None, **kwargs):\n        print(\"in close watcher\", old_value, value)\n        if self._target != 'Close':\n            return\n\n        if self._st is None:\n            return\n\n        if new_value:\n            self._st._finished()\n            self._target = None\n            self._st = None\n\n        pass"
  },
  {
    "class_name": "CameraSnapshot",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/.99-webcam_device.py",
    "source": "class CameraSnapshot(Device):\n    image = Component(ExternalFileReference, value=\"\", kind=\"normal\", shape=[])\n    beamline_id = ''\n    annotation_string = ''\n    \n    \n    def __init__(self, *args, root, bl, url, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._root = root\n        self._acquiring_lock = threading.Lock()\n        self._counter = None  # set to an itertools.count object when staged\n        self._asset_docs_cache = []\n        self._beamline = bl\n        self._SPEC = \"BEAMLINE_WEBCAM\"\n        self._url = url\n\n    def current_folder(self):\n        #folder = os.path.join('/nsls2', 'data', self._beamline, 'assets', *today.split('-'))\n        folder = os.path.join('/nsls2', 'data', 'pdf', 'legacy','processed','xpdacq_data','user_data','webcam', *today().split('-'))\n\n        if not os.path.isdir(folder):\n            os.makedirs(folder)\n        return folder\n            \n    def stage(self):\n        #self._rel_path_template = f\"path/to/files/{uuid.uuid4()}_%d.ext\"\n        self._rel_path_template = f\"{uuid.uuid4()}_%d.jpg\"\n        self._root = self.current_folder()\n        resource, self._datum_factory = resource_factory(\n            self._SPEC, self._root, self._rel_path_template, {}, \"posix\")\n        self._asset_docs_cache.append(('resource', resource))\n        self._counter = itertools.count()\n        # Set the filepath\n        return super().stage()\n\n    def collect_asset_docs(self):\n        yield from self._asset_docs_cache\n        self._asset_docs_cache.clear()\n\n    def unstage(self):\n        self._counter = None\n        self._asset_docs_cache.clear()\n        return super().unstage()\n\n    def _capture(self, status, i):\n        \"This runs on a background thread.\"\n        try:\n            if not self._acquiring_lock.acquire(timeout=0):\n                raise RuntimeError(\"Cannot trigger, currently triggering!\")\n            filename = os.path.join(self._root, self._rel_path_template % i)\n            # Kick off requests, or subprocess, or whatever with the result\n            # that a file is saved at `filename`.\n\n            if self._SPEC == \"BEAMLINE_WEBCAM\":\n                CAM_PROXIES = {\"http\": None, \"https\": None,}\n                r=requests.get(self._url, proxies=CAM_PROXIES)\n                im = Image.open(BytesIO(r.content))\n                im.save(filename, 'JPEG')\n                #print(f'w: {im.width}    h: {im.height}')\n                self.image.shape = (im.height, im.width, 3)\n\n                annotation = f'{self.beamline_id}      {self.annotation_string}       {now()}'\n                annotate_image(filename, annotation)\n\n            datum = self._datum_factory({\"index\": i})\n            self._asset_docs_cache.append(('datum', datum))\n            self.image.set(datum[\"datum_id\"]).wait()\n        except Exception as exc:\n            status.set_exception(exc)\n        else:\n            status.set_finished()\n        finally:\n            self._acquiring_lock.release()\n\n    def trigger(self):\n        status = DeviceStatus(self)\n        i = next(self._counter)\n        thread = threading.Thread(target=self._capture, args=(status, i))\n        thread.start()\n        return status"
  },
  {
    "class_name": "SampleEnvironment",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/25-sample-env.py",
    "source": "class SampleEnvironment(Device):\n    esc_sample_theta = Cpt(EpicsMotor, 'ECS-Ax:Th1}Mtr')\n    esc_sample_2_theta = Cpt(EpicsMotor, 'ECS-Ax:2Th1}Mtr')\n    analyzer_theta = Cpt(EpicsMotor, 'ECS-Ax:Th2}Mtr')\n    analyzer_2_theta = Cpt(EpicsMotor, 'ECS-Ax:2Th2}Mtr')\n    y = Cpt(EpicsMotor, 'Spn:Caplr-Ax:Y}Mtr')\n    z = Cpt(EpicsMotor, 'Spn:Caplr-Ax:Z}Mtr')\n    ry_yaw = Cpt(EpicsMotor, 'Spn:Caplr-Ax:Ry}Mtr')\n    rz_roll = Cpt(EpicsMotor, 'Spn:Caplr-Ax:Rz}Mtr')"
  },
  {
    "class_name": "Analyzer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/25-sample-env.py",
    "source": "class Analyzer(Device):\n    y = Cpt(EpicsMotor, 'Y}Mtr')\n    z = Cpt(EpicsMotor, 'Z}Mtr')\n    ry_yaw = Cpt(EpicsMotor, 'Ry}Mtr')\n    rz_roll = Cpt(EpicsMotor, 'Rz}Mtr')"
  },
  {
    "class_name": "Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/15-optics.py",
    "source": "class Slits(Device):\n    top = Cpt(EpicsMotor, 'T}Mtr')\n    bottom = Cpt(EpicsMotor, 'B}Mtr')\n    inboard = Cpt(EpicsMotor, 'I}Mtr')\n    outboard = Cpt(EpicsMotor, 'O}Mtr')\n    ''' TODO : Add later\n    xc = Cpt(EpicsMotor, 'XCtr}Mtr')\n    xg = Cpt(EpicsMotor, 'XGap}Mtr')\n    yc = Cpt(EpicsMotor, 'YCtr}Mtr')\n    yg = Cpt(EpicsMotor, 'YGap}Mtr')\n    '''"
  },
  {
    "class_name": "SideBounceMono",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/15-optics.py",
    "source": "class SideBounceMono(Device):\n    x_wedgemount = Cpt(EpicsMotor, \"X}Mtr\")\n    y_wedgemount = Cpt(EpicsMotor, \"Y}Mtr\")\n    yaw = Cpt(EpicsMotor, \"Yaw}Mtr\")\n    pitch = Cpt(EpicsMotor, \"Pitch}Mtr\")\n    roll = Cpt(EpicsMotor, \"Roll}Mtr\")\n    #bend = Cpt(EpicsMotor, \"Bend}Mtr\")\n    #twist = Cpt(EpicsMotor, \"Twist}Mtr\")\n    # Added below and commented above by MA 10/21/2024\n    bend_inboard_U = Cpt(EpicsMotor, \"IU}Mtr\")\n    bend_inboard_L = Cpt(EpicsMotor, \"IL}Mtr\")\n    bend_outboard_U = Cpt(EpicsMotor, \"OU}Mtr\")\n    bend_outboard_L = Cpt(EpicsMotor, \"OL}Mtr\")"
  },
  {
    "class_name": "PDFFastShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/15-optics.py",
    "source": "class PDFFastShutter(Device):\n    cmd = Cpt(EpicsSignal, 'Cmd', kind='omitted')\n    status = Cpt(EpicsSignal, 'Sts', kind='omitted')\n    settle_time = Cpt(Signal, kind='config', value=.1)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.st = None\n        # TODO: ask CJ to change it downstream to only accept the 'Open' or 'Close' strings (no numbers please!).\n        self.setmap = {'Open': 0, 'Close': 1,\n                       1: 0, 0: 1}  # MR: this is an inversed logic on the xpdacq side\n        self.readmap = {0: 'Open', 1: 'Close'}\n\n    def set(self, val):\n        # NOTE: temporary workaround until the fast shutter works.\n        #\n        def check_if_done(value, old_value, **kwargs):\n            if ((val in ['Open', 1] and value == 0) or\n                (val in ['Close', 0] and value == 1)):\n                if self.st is not None:\n                    self.st._finished()\n                    self.st = None\n                return True\n            return False\n        self.cmd.set(self.setmap[val])\n        status = SubscriptionStatus(self.status, check_if_done,settle_time=self.settle_time.get())\n        return status\n\n        #ttime.sleep(1.0)  # wait to set the value since the status PV does not capture the actual status\n        #return NullStatus()\n\n    def get(self):\n        return self.readmap[self.cmd.get()]\n\n    def read(self):\n        d = super().read()\n        d[self.name] = {'value': self.get(), 'timestamp': time.time()}\n        return d"
  },
  {
    "class_name": "Mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/15-optics.py",
    "source": "class Mirror(Device):\n    y_upstream = Cpt(EpicsMotor, 'YU}Mtr')\n    y_downstream_inboard = Cpt(EpicsMotor, 'YDI}Mtr')\n    y_downstream_outboard = Cpt(EpicsMotor, 'YDO}Mtr')\n    bend_upstream = Cpt(EpicsMotor, 'BndU}Mtr')\n    bend_encoder = Cpt(EpicsSignalRO, 'BndU}Pos:Enc-I')\n    bend_downstream = Cpt(EpicsMotor, 'BndD}Mtr')\n    twist_encoder = Cpt(EpicsSignalRO, 'BndD}Pos:Enc-I')"
  },
  {
    "class_name": "OpticsTableADC",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/15-optics.py",
    "source": "class OpticsTableADC(Device):\n    upstream_jack_inboard = Cpt(EpicsMotor, 'YUI}Mtr')\n    upstream_jack_outboard = Cpt(EpicsMotor, 'YUO}Mtr')\n    downstream_jack_outboard = Cpt(EpicsMotor, 'YD}Mtr')\n    X_upstream = Cpt(EpicsMotor, 'XU}Mtr')\n    X_downstream = Cpt(EpicsMotor, 'XD}Mtr')\n    Z = Cpt(EpicsMotor, 'Z}Mtr')"
  },
  {
    "class_name": "SpinnerGoniohead",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/15-optics.py",
    "source": "class SpinnerGoniohead(Device):\n    X = Cpt(EpicsMotor, 'X}Mtr')\n    Y = Cpt(EpicsMotor, 'Y}Mtr')\n    Z = Cpt(EpicsMotor, 'Z}Mtr')\n    Ry = Cpt(EpicsMotor, 'Ry}Mtr')"
  },
  {
    "class_name": "OCMTable",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/15-optics.py",
    "source": "class OCMTable(Device):\n    upstream_jack = Cpt(EpicsMotor, 'YU}Mtr')\n    downstream_jack = Cpt(EpicsMotor, 'YD}Mtr')\n    X = Cpt(EpicsMotor, 'X}Mtr')"
  },
  {
    "class_name": "CryoStream",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/11-temperature-controller.py",
    "source": "class CryoStream(Device):\n    # readback\n    T = Cpt(EpicsSignalRO, 'T-I')\n    # setpoint\n    setpoint = Cpt(EpicsSignal, read_pv=\"T-RB\",\n                   write_pv=\"T-SP\",\n                   add_prefix=('suffix', 'read_pv', 'write_pv'))\n    # heater power level\n    heater = Cpt(EpicsSignal, ':HTR1')\n\n    # configuration\n    dead_band = Cpt(EpicsSignal, 'T:AtSP-SP', string=True)\n    heater_range = Cpt(EpicsSignal, ':HTR1:Range', string=True)\n    # don't know what this is?\n    #scan = Cpt(EpicsSignal, ':read.SCAN', string=True)\n    mode = Cpt(EpicsSignal, ':OUT1:Mode', string=True)\n    cntrl = Cpt(EpicsSignal, ':OUT1:Cntrl', string=True)\n    # trigger signal\n    trig = Cpt(EpicsSignal, ':read.PROC')\n\n    #def trigger(self):\n        #self.trig.put(1, wait=True)\n        #return DeviceStatus(self, done=True, success=True)\n\n    def __init__(self, *args, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['T', 'setpoint']\n        #if configuration_attrs is None:\n            #configuration_attrs = ['heater_range', 'dead_band',\n                                   #'mode', 'cntrl']\n        super().__init__(*args, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         **kwargs)\n        self._target = None\n        self._sts = None\n\n    def _sts_mon(self, value, **kwargs):\n        if (self._target is None or\n                 np.abs(self._target - value) < float(self.dead_band.get())):\n            self.T.clear_sub(self._sts_mon)\n            #self.scan.put('Passive', wait=True)\n            if self._sts is not None:\n                self._sts._finished()\n                self._sts = None\n            self._target = None\n\n    def set(self, val):\n        self._target = val\n        self.setpoint.put(val)#, wait=True)\n        sts = self._sts = DeviceStatus(self)\n        #self.scan.put('.2 second')\n        self.T.subscribe(self._sts_mon)\n\n        return sts\n\n    def stop(self, *, success=False):\n        self.setpoint.put(self.T.get())\n        if self._sts is not None:\n            self._sts._finished(success=success)\n        self._sts = None\n        self._target = None"
  },
  {
    "class_name": "CryoStat1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/11-temperature-controller.py",
    "source": "class CryoStat1(Device):\n    # readback\n    T = Cpt(EpicsSignalRO, ':IN1')\n    # setpoint\n    setpoint = Cpt(EpicsSignal, read_pv=\":OUT1:SP_RBV\",\n                   write_pv=\":OUT1:SP\",\n                   add_prefix=('suffix', 'read_pv', 'write_pv'))\n    # heater power level\n    heater = Cpt(EpicsSignal, ':HTR1')\n\n    # configuration\n    dead_band = Cpt(AttributeSignal, attr='_dead_band')\n    heater_range = Cpt(EpicsSignal, ':HTR1:Range', string=True)\n    scan = Cpt(EpicsSignal, ':read.SCAN', string=True)\n    mode = Cpt(EpicsSignal, ':OUT1:Mode', string=True)\n    cntrl = Cpt(EpicsSignal, ':OUT1:Cntrl', string=True)\n    # trigger signal\n    trig = Cpt(EpicsSignal, ':read.PROC')\n\n    def trigger(self):\n        self.trig.put(1, wait=True)\n        return DeviceStatus(self, done=True, success=True)\n\n    def __init__(self, *args, dead_band, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['T', 'setpoint']\n        if configuration_attrs is None:\n            configuration_attrs = ['heater_range', 'dead_band',\n                                   'mode', 'cntrl']\n        super().__init__(*args, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         **kwargs)\n        self._target = None\n        self._dead_band = dead_band\n        self._sts = None\n\n    def _sts_mon(self, value, **kwargs):\n        if (self._target is None or\n                 np.abs(self._target - value) < self._dead_band):\n            self.T.clear_sub(self._sts_mon)\n            self.scan.put('Passive', wait=True)\n            if self._sts is not None:\n                self._sts._finished()\n                self._sts = None\n            self._target = None\n\n    def set(self, val):\n        self._target = val\n        self.setpoint.put(val, wait=True)\n        sts = self._sts = DeviceStatus(self)\n        self.scan.put('.2 second')\n        self.T.subscribe(self._sts_mon)\n\n        return sts\n\n    def stop(self, *, success=False):\n        self.setpoint.put(self.T.get())\n        if self._sts is not None:\n            self._sts._finished(success=success)\n        self._sts = None\n        self._target = None\n        self.scan.put('Passive', wait=True)"
  },
  {
    "class_name": "CryoStat2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/11-temperature-controller.py",
    "source": "class CryoStat2(Device):\n    # readback\n    T = Cpt(EpicsSignalRO, ':IN2')\n    # setpoint\n    setpoint = Cpt(EpicsSignal, read_pv=\":OUT2:SP_RBV\",\n                   write_pv=\":OUT2:SP\",\n                   add_prefix=('suffix', 'read_pv', 'write_pv'))\n    # heater power level\n    heater = Cpt(EpicsSignal, ':HTR2')\n\n    # configuration\n    dead_band = Cpt(AttributeSignal, attr='_dead_band')\n    heater_range = Cpt(EpicsSignal, ':HTR2:Range', string=True)\n    scan = Cpt(EpicsSignal, ':read.SCAN', string=True)\n    mode = Cpt(EpicsSignal, ':OUT2:Mode', string=True)\n    cntrl = Cpt(EpicsSignal, ':OUT2:Cntrl', string=True)\n    # trigger signal\n    trig = Cpt(EpicsSignal, ':read.PROC')\n\n    def trigger(self):\n        self.trig.put(1, wait=True)\n        return DeviceStatus(self, done=True, success=True)\n\n    def __init__(self, *args, dead_band, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['T', 'setpoint']\n        if configuration_attrs is None:\n            configuration_attrs = ['heater_range', 'dead_band',\n                                   'mode', 'cntrl']\n        super().__init__(*args, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         **kwargs)\n        self._target = None\n        self._dead_band = dead_band\n        self._sts = None\n\n    def _sts_mon(self, value, **kwargs):\n        if (self._target is None or\n                 np.abs(self._target - value) < self._dead_band):\n            self.T.clear_sub(self._sts_mon)\n            self.scan.put('Passive', wait=True)\n            if self._sts is not None:\n                self._sts._finished()\n                self._sts = None\n            self._target = None\n\n    def set(self, val):\n        self._target = val\n        self.setpoint.put(val, wait=True)\n        sts = self._sts = DeviceStatus(self)\n        self.scan.put('.2 second')\n        self.T.subscribe(self._sts_mon)\n\n        return sts\n\n    def stop(self, *, success=False):\n        self.setpoint.put(self.T.get())\n        if self._sts is not None:\n            self._sts._finished(success=success)\n        self._sts = None\n        self._target = None\n        self.scan.put('Passive', wait=True)"
  },
  {
    "class_name": "Lakeshore336Channel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/11-temperature-controller.py",
    "source": "class Lakeshore336Channel(Device):\n    T = Cpt(EpicsSignalRO, 'T-I')\n    V = Cpt(EpicsSignalRO, 'Val:Sens-I')\n    status = Cpt(EpicsSignalRO, 'T-Sts')"
  },
  {
    "class_name": "Lakeshore336",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/11-temperature-controller.py",
    "source": "class Lakeshore336(Device):\n    temp = DDC(_temp_fields(['A','B','C','D']))\n    out1 = Cpt(Lakeshore336Setpoint, '-Out:1}')\n    out2 = Cpt(Lakeshore336Setpoint, '-Out:2}')\n    out3 = Cpt(Lakeshore336Setpoint, '-Out:3}')\n    out4 = Cpt(Lakeshore336Setpoint, '-Out:4}')"
  },
  {
    "class_name": "RGA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/pdf-profile-collection/startup/13-gas_handling.py",
    "source": "class RGA(Device):\n\n    mass1 = Cpt(EpicsSignal, 'Mass:MID1-SP')\n    partial_pressure1 = Cpt(EpicsSignalRO, 'P:MID1-I')\n    mass2 = Cpt(EpicsSignal, 'Mass:MID2-SP')\n    partial_pressure2 = Cpt(EpicsSignalRO, 'P:MID2-I')\n    mass3 = Cpt(EpicsSignal, 'Mass:MID3-SP')\n    partial_pressure3 = Cpt(EpicsSignalRO, 'P:MID3-I')\n    mass4 = Cpt(EpicsSignal, 'Mass:MID4-SP')\n    partial_pressure4 = Cpt(EpicsSignalRO, 'P:MID4-I')\n    mass5 = Cpt(EpicsSignal, 'Mass:MID5-SP')\n    partial_pressure5 = Cpt(EpicsSignalRO, 'P:MID5-I')\n    mass6 = Cpt(EpicsSignal, 'Mass:MID6-SP')\n    partial_pressure6 = Cpt(EpicsSignalRO, 'P:MID6-I')\n    mass7 = Cpt(EpicsSignal, 'Mass:MID7-SP')\n    partial_pressure7 = Cpt(EpicsSignalRO, 'P:MID7-I')\n    mass8 = Cpt(EpicsSignal, 'Mass:MID8-SP')\n    partial_pressure8 = Cpt(EpicsSignalRO, 'P:MID8-I')\n    mass9 = Cpt(EpicsSignal, 'Mass:MID9-SP')\n    partial_pressure9 = Cpt(EpicsSignalRO, 'P:MID9-I')"
  },
  {
    "class_name": "CRL",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-machine.py",
    "source": "class CRL(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr', labels=('crl',))\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr', labels=('crl',))\n    th =Cpt(EpicsMotor, '-Ax:P}Mtr', labels=('crl',))"
  },
  {
    "class_name": "Slit2D",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-machine.py",
    "source": "class Slit2D(Device):\n    \"Center and gap with virtual motors\"\n    xc = Cpt(Slit2DCenter, '12-Ax:X}')\n    yc = Cpt(Slit2DCenter, '12-Ax:Y}')\n    xg = Cpt(Slit2DGap, '12-Ax:X}')\n    yg = Cpt(Slit2DGap, '12-Ax:Y}')"
  },
  {
    "class_name": "Slit2DBlades",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-machine.py",
    "source": "class Slit2DBlades(Device):\n    top = Cpt(EpicsMotor, '1-Ax:T}Mtr', labels=('fes',))\n    bottom = Cpt(EpicsMotor, '2-Ax:B}Mtr', labels=('fes',))\n    outboard = Cpt(EpicsMotor, '1-Ax:O}Mtr', labels=('fes',))\n    inboard = Cpt(EpicsMotor, '2-Ax:I}Mtr', labels=('fes',))"
  },
  {
    "class_name": "SROFB",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-machine.py",
    "source": "class SROFB(Device):\n    uofb_pv = Cpt(EpicsSignal, '}ConfigMode-I')\n    id_bump_pv = Cpt(EpicsSignal, 'C10-ID}Enabled-I')\n    nudge_pv = Cpt(EpicsSignal, 'C10-ID}Nudge-Enabled')\n    nudge_increment = Cpt(EpicsSignal, 'C10-ID}angle-increment-SP')\n    horz_plane_nudge = Cpt(EpicsSignal, 'C10-ID}Nudge:X')\n    vert_plane_nudge = Cpt(EpicsSignal, 'C10-ID}Nudge:Y')\n    nudge_status = Cpt(EpicsSignal, 'C10-ID}Nudge-StatusMsg')\n    xa_rbv = Cpt(EpicsSignal, 'BUMP:C10-IXS}angle:X-SP')\n    xy_rbv = Cpt(EpicsSignal, 'BUMP:C10-IXS}angle:Y-SP')"
  },
  {
    "class_name": "Blades",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class Blades(Device):\n    top = Cpt(EpicsMotor, '-Ax:T}Mtr')\n    bottom = Cpt(EpicsMotor, '-Ax:B}Mtr')\n    outboard = Cpt(EpicsMotor, '-Ax:O}Mtr')\n    inboard = Cpt(EpicsMotor, '-Ax:I}Mtr')"
  },
  {
    "class_name": "DCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class DCM(Device):\n    y =  Cpt(EpicsMotor, '-Ax:Y}Mtr', labels=('dcm',))\n    th = Cpt(EpicsMotor, '-Ax:P}Mtr', labels=('dcm',))\n    z2 = Cpt(EpicsMotor, '-Ax:Z2}Mtr', labels=('dcm',))\n    p1 = Cpt(EpicsMotor, '-Ax:P1}Mtr', labels=('dcm',))\n    r2 = Cpt(EpicsMotor, '-Ax:R2}Mtr', labels=('dcm',))\n    pf = Cpt(EpicsMotor, '-Ax:PF}Mtr', labels=('dcm',))"
  },
  {
    "class_name": "HRM2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class HRM2(Device):\n    ux =  Cpt(EpicsMotor, '-Ax:UX}Mtr', labels=('hrm2',))\n    uy =  Cpt(EpicsMotor, '-Ax:UY}Mtr', labels=('hrm2',))\n    uth = Cpt(EpicsMotor, '-Ax:UTc}Mtr', labels=('hrm2',))\n    uch = Cpt(EpicsMotor, '-Ax:UC}Mtr', labels=('hrm2',))\n    uif = Cpt(EpicsMotor, '-Ax:UTI}Mtr', labels=('hrm2',))\n    uof = Cpt(EpicsMotor, '-Ax:UTO}Mtr', labels=('hrm2',))\n    dx =  Cpt(EpicsMotor, '-Ax:DX}Mtr', labels=('hrm2',))\n    dy =  Cpt(EpicsMotor, '-Ax:DY}Mtr', labels=('hrm2',))\n    dth = Cpt(EpicsMotor, '-Ax:DTc}Mtr', labels=('hrm2',))\n    dch = Cpt(EpicsMotor, '-Ax:DC}Mtr', labels=('hrm2',))\n    dif = Cpt(EpicsMotor, '-Ax:DTI}Mtr', labels=('hrm2',))\n    dof = Cpt(EpicsMotor, '-Ax:DTO}Mtr', labels=('hrm2',))\n    d1 =  Cpt(EpicsMotor, '-Pico:m1}Mtr', labels=('hrm2',))\n    d2 =  Cpt(EpicsMotor, '-Pico:m2}Mtr', labels=('hrm2',))\n    d3 =  Cpt(EpicsMotor, '-Pico:m3}Mtr', labels=('hrm2',))\n    d4 =  Cpt(EpicsMotor, '-Pico:m4}Mtr', labels=('hrm2',))\n    d5 =  Cpt(EpicsMotor, '-Pico:m5}Mtr', labels=('hrm2',))\n    bs =  Cpt(EpicsMotor, '-Pico:m6}Mtr', labels=('hrm2',))"
  },
  {
    "class_name": "VFM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class VFM(Device):\n    ux = Cpt(EpicsMotor, '-Ax:UX}Mtr', labels=('vfm',))\n    uy = Cpt(EpicsMotor, '-Ax:UY}Mtr', labels=('vfm',))\n    dx = Cpt(EpicsMotor, '-Ax:DX}Mtr', labels=('vfm',))\n    dy = Cpt(EpicsMotor, '-Ax:DY}Mtr', labels=('vfm',))\n    ub = Cpt(EpicsMotor, '-Ax:UB}Mtr', labels=('vfm',))\n    db = Cpt(EpicsMotor, '-Ax:DB}Mtr', labels=('vfm',))"
  },
  {
    "class_name": "HFM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class HFM(Device):\n    ux = Cpt(EpicsMotor, '-Ax:UX}Mtr', labels=('hfm',))\n    uy = Cpt(EpicsMotor, '-Ax:UY}Mtr', labels=('hfm',))\n    dx = Cpt(EpicsMotor, '-Ax:DX}Mtr', labels=('hfm',))\n    dy = Cpt(EpicsMotor, '-Ax:DY}Mtr', labels=('hfm',))\n    ub = Cpt(EpicsMotor, '-Ax:UB}Mtr', labels=('hfm',))\n    db = Cpt(EpicsMotor, '-Ax:DB}Mtr', labels=('hfm',))"
  },
  {
    "class_name": "XYMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class XYMotor(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr', labels=('xymotor',))\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr', labels=('xymotor',))"
  },
  {
    "class_name": "SSA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class SSA(Device):\n    top = Cpt(EpicsMotor, '-Ax:T}Mtr', labels=('ssa',))\n    bottom = Cpt(EpicsMotor, '-Ax:B}Mtr', labels=('ssa',))"
  },
  {
    "class_name": "Table",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class Table(Device):\n    x = Cpt(EpicsMotor, '-Ax:X4}Mtr', labels=('table',))\n    y = Cpt(EpicsMotor, '-Ax:Y4}Mtr', labels=('table',))\n    th =Cpt(EpicsMotor, '-Ax:X4a1}Mtr', labels=('table',))"
  },
  {
    "class_name": "Pinhole",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class Pinhole(Device):\n    ux = Cpt(EpicsMotor, '-Ax:UX}Mtr', labels=('pinhole',))\n    uy = Cpt(EpicsMotor, '-Ax:UY}Mtr', labels=('pinhole',))\n    dx = Cpt(EpicsMotor, '-Ax:DX}Mtr', labels=('pinhole',))\n    dy = Cpt(EpicsMotor, '-Ax:DY}Mtr', labels=('pinhole',))"
  },
  {
    "class_name": "MCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/10-optics.py",
    "source": "class MCM(Device):\n    x = Cpt(MCMBase, '', ch_name='-Ax:X}Mtr', labels=('mcm',))\n    y = Cpt(MCMBase, '', ch_name='-Ax:Y}Mtr', labels=('mcm',))\n    z = Cpt(MCMBase, '', ch_name='-Ax:Z}Mtr', labels=('mcm',))\n    theta = Cpt(MCMBase, '', ch_name='-Ax:Rx}Mtr', labels=('mcm',))\n    phi = Cpt(MCMBase, '', ch_name='-Ax:Ry}Mtr', labels=('mcm',))\n    chi = Cpt(MCMBase, '', ch_name='-Ax:Rz}Mtr', labels=('mcm',))"
  },
  {
    "class_name": "Analyzer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/90-endstation.py",
    "source": "class Analyzer(Device):\n    uy = Cpt(EpicsMotor, '-OP{Analy:1-Ax:UY}Mtr', labels=('analyzer',))\n    dy = Cpt(EpicsMotor, '-OP{Analy:1-Ax:DY}Mtr', labels=('analyzer',))\n    ay = Cpt(EpicsMotor, '-OP{Analy:1-Ax:A}Mtr', labels=('analyzer',))\n    by = Cpt(EpicsMotor, '-OP{Analy:1-Ax:B}Mtr', labels=('analyzer',))\n\n    cfth = Cpt(EpicsMotor, '-ES{Ez4:1-Ax:1}Mtr', labels=('analyzer',))\n    cchi = Cpt(EpicsMotor, '-ES{Ez4:1-Ax:2}Mtr', labels=('analyzer',))\n    wfth = Cpt(EpicsMotor, '-ES{Ez4:1-Ax:3}Mtr', labels=('analyzer',))\n    wchi = Cpt(EpicsMotor, '-ES{Ez4:1-Ax:4}Mtr', labels=('analyzer',))"
  },
  {
    "class_name": "Spectrometer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/90-endstation.py",
    "source": "class Spectrometer(Device):\n    tth = Cpt(EpicsMotor, '-OP{Spec:1-Ax:2Th}Mtr', labels=('spectrometer',))\n    th = Cpt(EpicsMotor, '-OP{Spec:1-Ax:Th}Mtr', labels=('spectrometer',))\n    chi = Cpt(EpicsMotor, '-OP{Spec:1-Ax:ChiA}Mtr', labels=('spectrometer',))\n    phi = Cpt(EpicsMotor, '-OP{Spec:1-Ax:PhiA}Mtr', labels=('spectrometer',))"
  },
  {
    "class_name": "AnalyzerDXtals",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/90-endstation.py",
    "source": "class AnalyzerDXtals(Device):\n    d1the = Cpt(EpicsMotor, '2-Ax:1}Mtr', labels=('analyzerdxtals',))\n    d1phi = Cpt(EpicsMotor, '2-Ax:2}Mtr', labels=('analyzerdxtals',))\n    d2the = Cpt(EpicsMotor, '2-Ax:3}Mtr', labels=('analyzerdxtals',))\n    d2phi = Cpt(EpicsMotor, '2-Ax:4}Mtr', labels=('analyzerdxtals',))\n    d3the = Cpt(EpicsMotor, '3-Ax:1}Mtr', labels=('analyzerdxtals',))\n    d3phi = Cpt(EpicsMotor, '3-Ax:2}Mtr', labels=('analyzerdxtals',))\n    d4the = Cpt(EpicsMotor, '3-Ax:3}Mtr', labels=('analyzerdxtals',))\n    d4phi = Cpt(EpicsMotor, '3-Ax:4}Mtr', labels=('analyzerdxtals',))\n    d5the = Cpt(EpicsMotor, '4-Ax:1}Mtr', labels=('analyzerdxtals',))\n    d5phi = Cpt(EpicsMotor, '4-Ax:2}Mtr', labels=('analyzerdxtals',))\n    d6the = Cpt(EpicsMotor, '4-Ax:3}Mtr', labels=('analyzerdxtals',))\n    d6phi = Cpt(EpicsMotor, '4-Ax:4}Mtr', labels=('analyzerdxtals',))\n    anpd = Cpt(EpicsMotor,  '5-Ax:1}Mtr', labels=('analyzerdxtals',))"
  },
  {
    "class_name": "AnalyzerSlits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/90-endstation.py",
    "source": "class AnalyzerSlits(Device):\n    top = Cpt(EpicsMotor,  '5-Ax:2}Mtr', labels=('analyzerslits',))\n    bottom = Cpt(EpicsMotor,  '5-Ax:3}Mtr', labels=('analyzerslits',))\n    outboard = Cpt(EpicsMotor,  '7-Ax:3}Mtr', labels=('analyzerslits',))\n    inboard = Cpt(EpicsMotor,  '7-Ax:4}Mtr', labels=('analyzerslits',))"
  },
  {
    "class_name": "MCMSlits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/90-endstation.py",
    "source": "class MCMSlits(Device):\n #   top = Cpt(EpicsMotor, '6-Ax:3}Mtr', labels=('mcmslits',))\n #   bottom = Cpt(EpicsMotor, '6-Ax:4}Mtr', labels=('mcmslits',))\n    inboard = Cpt(EpicsMotor,  '-Ax:Xi}Mtr', labels=('mcmslits',))\n    outboard = Cpt(EpicsMotor,  '-Ax:Xo}Mtr', labels=('mcmslits',))"
  },
  {
    "class_name": "SampleStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/90-endstation.py",
    "source": "class SampleStage(Device):\n    ty = Cpt(EpicsMotor, '{Spec:1-Ax:Y}Mtr', labels=('samplestage',))\n    tx = Cpt(EpicsMotor, '{Spec:1-Ax:X}Mtr', labels=('samplestage',))\n    tz = Cpt(EpicsMotor, '{Spec:1-Ax:Z}Mtr', labels=('samplestage',))\n    sy = Cpt(EpicsMotor, '{Env:1-Ax:Y}Mtr', labels=('samplestage',))\n    sx = Cpt(EpicsMotor, '{Env:1-Ax:X}Mtr', labels=('samplestage',))\n    sz = Cpt(EpicsMotor, '{Env:1-Ax:Z}Mtr', labels=('samplestage',))"
  },
  {
    "class_name": "URATemperature",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/ixs-profile-collection/startup/97-temperature.py",
    "source": "class URATemperature(Device):\n    d1temp = Cpt(EpicsSignal, '01}PID.VAL', labels=(\"DxtalTemp\", ))\n    d2temp = Cpt(EpicsSignal, '02}PID.VAL', labels=(\"DxtalTemp\", ))\n    d3temp = Cpt(EpicsSignal, '03}PID.VAL', labels=(\"DxtalTemp\", ))\n    d4temp = Cpt(EpicsSignal, '04}PID.VAL', labels=(\"DxtalTemp\", ))\n    d5temp = Cpt(EpicsSignal, '05}PID.VAL', labels=(\"DxtalTemp\", ))\n    d6temp = Cpt(EpicsSignal, '06}PID.VAL', labels=(\"DxtalTemp\", ))"
  },
  {
    "class_name": "output_lakeshore",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/27-envcontrol.py",
    "source": "class output_lakeshore(Device):\n\n    status = Cpt(EpicsSignal, \"Val:Range-Sel\")\n    P = Cpt(EpicsSignal, \"Gain:P-SP\")\n    I = Cpt(EpicsSignal, \"Gain:I-SP\")\n    D = Cpt(EpicsSignal, \"Gain:I-SP\")\n    temp_set_point = Cpt(EpicsSignal, \"T-SP\")\n\n    def turn_on(self, range):\n        if range in [1, 2, 3]:\n            yield from bps.mv(self.status, range)\n        else:\n            print('The output range need be 1, 2, or 3!')\n\n    def turn_off(self):\n        yield from bps.mv(self.status, 0)\n\n    def set_temp(self, temp):\n        yield from bps.mv(self.temp_set_point, temp)\n\n    def set_temp_celsius(self, temp):\n        yield from self.set_temp(temp+273.15)\n\n\n    ramp_sp = Cpt(EpicsSignal, \"Val:Ramp-SP\")\n    ramp_status = Cpt(EpicsSignal, \"Enbl:Ramp-Sel\")\n\n    def set_ramp(self, ramp):\n        yield from bps.mv(self.ramp_sp, ramp)\n\n    def ramp_on(self):\n        yield from bps.mv(self.ramp_status, 1)\n    def ramp_off(self):\n        yield from bps.mv(self.ramp_status, 0)"
  },
  {
    "class_name": "new_LakeShore",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/27-envcontrol.py",
    "source": "class new_LakeShore(Device):\n    \"\"\"\n    Lakeshore is the device reading the temperature from the heating stage for SAXS and GISAXS.\n    This class define the PVs to read and write to control lakeshore\n    :param Device: ophyd device\n    \"\"\"\n\n    input_A = Cpt(EpicsSignal, \"{Env:01-Chan:A}T-I\")\n    input_A_celsius = Cpt(EpicsSignal, \"{Env:01-Chan:A}T:C-I\")\n\n    input_B = Cpt(EpicsSignal, \"{Env:01-Chan:B}T-I\")\n    input_C = Cpt(EpicsSignal, \"{Env:01-Chan:C}T-I\")\n    input_D = Cpt(EpicsSignal, \"{Env:01-Chan:D}T-I\")\n\n    output1 = output_lakeshore(\"XF:12ID1-ES{Env:01-Out:1}\", name=\"ls_outpu1\")\n    output2 = output_lakeshore(\"XF:12ID1-ES{Env:01-Out:2}\", name=\"ls_outpu2\")\n    output3 = output_lakeshore(\"XF:12ID1-ES{Env:01-Out:3}\", name=\"ls_outpu3\")\n    output4 = output_lakeshore(\"XF:12ID1-ES{Env:01-Out:4}\", name=\"ls_outpu4\")"
  },
  {
    "class_name": "DetectorOffsets",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/30-geometry.py",
    "source": "class DetectorOffsets(Device):\n    det_mode= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:DetMode\",\n        add_prefix=(),\n        kind=\"config\",\n        )\n    det_1= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:L_11\",\n        add_prefix=(),\n        kind=\"config\"\n        )\n    det_2= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:L_12\",\n        add_prefix=(),\n        kind=\"config\"\n        )\n    det_3= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:L_13\",\n        add_prefix=(),\n        kind=\"config\"\n        )\n    det_4= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:L_14\",\n        add_prefix=(),\n        kind=\"config\"\n        )\n    det_5= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:L_15\",\n        add_prefix=(),\n        kind=\"config\"\n        )"
  },
  {
    "class_name": "PhiOffsets",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/30-geometry.py",
    "source": "class PhiOffsets(Device):\n    phi_mode= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:PhiMode\",\n        add_prefix=(),\n        kind=\"config\",\n        )\n    phix_1= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:L_16\",\n        add_prefix=(),\n        kind=\"config\"\n        )\n    phix_2= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:L_17\",\n        add_prefix=(),\n        kind=\"config\"\n        )\n    phi_1= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:L_18\",\n        add_prefix=(),\n        kind=\"config\"\n        )\n    chi_1= Cpt(\n        EpicsSignal,\n        \"XF:12ID1:L_19\",\n        add_prefix=(),\n        kind=\"config\"\n        )\n    \n\n    phix_0 = 0\n    phi_2 = 0\n    phi_0 = 0\n    chi_2 = 0\n    chi_0 = 0"
  },
  {
    "class_name": "DCMInternals",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/11-energy.py",
    "source": "class DCMInternals(Device):\n    height = Cpt(EpicsMotor, 'XF:12ID:m66')\n    pitch = Cpt(EpicsMotor, 'XF:12ID:m67')\n    roll = Cpt(EpicsMotor, 'XF:12ID:m68')\n    theta = Cpt(EpicsMotor, 'XF:12ID:m65')"
  },
  {
    "class_name": "SlitsWithGapAndCenter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class SlitsWithGapAndCenter(Device):\n    vg = Cpt(EpicsMotor, \"Vg}Mtr\")\n    vc = Cpt(EpicsMotor, \"Vc}Mtr\")\n    hg = Cpt(EpicsMotor, \"Hg}Mtr\")\n    hc = Cpt(EpicsMotor, \"Hc}Mtr\")"
  },
  {
    "class_name": "SlitsWithTopBottomInbOutb",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class SlitsWithTopBottomInbOutb(Device):\n    top = Cpt(EpicsMotor, \"T}Mtr\")\n    bottom = Cpt(EpicsMotor, \"B}Mtr\")\n    inb = Cpt(EpicsMotor, \"I}Mtr\")\n    outb = Cpt(EpicsMotor, \"O}Mtr\")\n    absorber1 = Cpt(EpicsMotor, \"X}Mtr\")"
  },
  {
    "class_name": "Smaract1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class Smaract1(Device):\n   absorber1 = Cpt(EpicsMotor, \"X}Mtr\")"
  },
  {
    "class_name": "Smaract2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class Smaract2(Device):\n   position1 = Cpt(EpicsMotor, \"Y}Mtr\")"
  },
  {
    "class_name": "Smaract3",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class Smaract3(Device):\n    y = Cpt(EpicsMotor, \"BS}Mtr\")"
  },
  {
    "class_name": "BSTOP",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class BSTOP(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")"
  },
  {
    "class_name": "SLTH",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class SLTH(Device):\n    h = Cpt(EpicsMotor, 'Hpos}Mtr')\n    hg = Cpt(EpicsMotor, 'Hgap}Mtr')"
  },
  {
    "class_name": "SLTV",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class SLTV(Device):\n    v = Cpt(EpicsMotor, 'Vpos}Mtr')\n    vg = Cpt(EpicsMotor, 'Vgap}Mtr')"
  },
  {
    "class_name": "SOLLER",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class SOLLER(Device):\n    tran = Cpt(EpicsMotor, 'lex16}Mtr')\n    rot = Cpt(EpicsMotor, 'lex17}Mtr')"
  },
  {
    "class_name": "SampleSlit",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/25-slits.py",
    "source": "class SampleSlit(Device):\n    x2 = Cpt(EpicsMotor, 'X2}Mtr')"
  },
  {
    "class_name": "Table1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/20-motors.py",
    "source": "class Table1(Device):\n    z = Cpt(EpicsMotor, \"TblZ}Mtr\")\n    x = Cpt(EpicsMotor, \"TblX}Mtr\")\n    y = Cpt(EpicsMotor, \"TblY}Mtr\")"
  },
  {
    "class_name": "Tilt",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/20-motors.py",
    "source": "class Tilt(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")"
  },
  {
    "class_name": "DET_SAXS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/20-motors.py",
    "source": "class DET_SAXS(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")"
  },
  {
    "class_name": "FLIGHT_PATH_SAXS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/20-motors.py",
    "source": "class FLIGHT_PATH_SAXS(Device):\n    y1 = Cpt(EpicsMotor, \"Y1}Mtr\")\n    y2 = Cpt(EpicsMotor, \"Y2}Mtr\")"
  },
  {
    "class_name": "ROT",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/20-motors.py",
    "source": "class ROT(Device):\n    rot = Cpt(EpicsMotor, \"Th}Mtr\")"
  },
  {
    "class_name": "Ring",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/09-machine.py",
    "source": "class Ring(Device):\n    current = Cpt(EpicsSignalRO, 'SR:C03-BI{DCCT:1}I:Real-I')\n    lifetime = Cpt(EpicsSignalRO, 'SR:OPS-BI{DCCT:1}Lifetime-I')\n    energy = Cpt(EpicsSignalRO, 'SR{}Energy_SRBend')\n    ops = Cpt(EpicsSignal, 'SR-OPS{}Mode-Sts', string=True)\n    filltarget = Cpt(EpicsSignalRO, 'SR-HLA{}FillPattern:DesireImA')"
  },
  {
    "class_name": "EpicsSignalOverridePrecRO",
    "bases": [
      "EpicsSignalRO"
    ],
    "file": "profile-collections/opls-profile-collection/startup/09-machine.py",
    "source": "class EpicsSignalOverridePrecRO(EpicsSignalRO):\n    def __init__(self, *args, precision=4, **kwargs):\n        self._precision = precision\n        super().__init__(*args, **kwargs)\n\n    @property\n    def precision(self):\n        return self._precision"
  },
  {
    "class_name": "EpicsSignalOverridePrec",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/opls-profile-collection/startup/09-machine.py",
    "source": "class EpicsSignalOverridePrec(EpicsSignal):\n    def __init__(self, *args, precision=4, **kwargs):\n        self._precision = precision\n        super().__init__(*args, **kwargs)\n\n    @property\n    def precision(self):\n        return self._precision"
  },
  {
    "class_name": "TwoButtonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/08-shutter.py",
    "source": "class TwoButtonShutter(Device):\n    # TODO this needs to be fixed in EPICS as these names make no sense\n    # the vlaue comingout of the PV do not match what is shown in CSS\n    open_cmd = Cpt(EpicsSignal, 'Cmd:Opn-Cmd', string=True)\n    open_val = 'Open'\n\n    close_cmd = Cpt(EpicsSignal, 'Cmd:Cls-Cmd', string=True)\n    close_val = 'Not Open'\n\n    status = Cpt(EpicsSignalRO, 'Pos-Sts', string=True)\n    fail_to_close = Cpt(EpicsSignalRO, 'Sts:FailCls-Sts', string=True)\n    fail_to_open = Cpt(EpicsSignalRO, 'Sts:FailOpn-Sts', string=True)\n    # user facing commands\n    open_str = 'Insert'\n    close_str = 'Retract'\n\n    # !!these commands are correct with open_str = 'Insert'  close_str = 'Retract'for FOILS ONLY, to trigger gatevalevs this has to be swapped!!!\n    # to check with Bluesky guys!!!\n\n    def set(self, val):\n        if self._set_st is not None:\n            raise RuntimeError('trying to set while a set is in progress')\n\n        cmd_map = {self.open_str: self.open_cmd,\n                   self.close_str: self.close_cmd}\n        target_map = {self.open_str: self.open_val,\n                      self.close_str: self.close_val}\n\n        cmd_sig = cmd_map[val]\n        target_val = target_map[val]\n\n        st = self._set_st = DeviceStatus(self)\n        enums = self.status.enum_strs\n\n        def shutter_cb(value, timestamp, **kwargs):\n            value = enums[int(value)]\n            if value == target_val:\n                self._set_st._finished()\n                self._set_st = None\n                self.status.clear_sub(shutter_cb)\n\n        cmd_enums = cmd_sig.enum_strs\n        count = 0\n\n        def cmd_retry_cb(value, timestamp, **kwargs):\n            nonlocal count\n            value = cmd_enums[int(value)]\n            # ts = datetime.datetime.fromtimestamp(timestamp).strftime(_time_fmtstr)\n            # print('sh', ts, val, st)\n            count += 1\n            if count > 5:\n                cmd_sig.clear_sub(cmd_retry_cb)\n                st._finished(success=False)\n            if value == 'None':\n                if not st.done:\n                    yield from bps.sleep(.5)\n                    cmd_sig.set(1)\n                    ts = datetime.datetime.fromtimestamp(timestamp).strftime(_time_fmtstr)\n                    print('** ({}) Had to reactuate shutter while {}ing'.format(ts, val))\n                else:\n                    cmd_sig.clear_sub(cmd_retry_cb)\n\n        cmd_sig.subscribe(cmd_retry_cb, run=False)\n        cmd_sig.set(1)\n        self.status.subscribe(shutter_cb)\n        return st\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._set_st = None\n        self.read_attrs = ['status']"
  },
  {
    "class_name": "KibronTrough",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/84-kibron.py",
    "source": "class KibronTrough(Device):\n    '''\n    To get target parameters from the kibron trough\n    '''\n\n    pressure = Cpt(Signal, kind = 'hinted')\n    area = Cpt(Signal, kind = 'hinted')\n    speed = Cpt(Signal, kind = 'normal')\n    temperature1 = Cpt(Signal, kind = 'normal')\n    temperature2 = Cpt(Signal, kind = 'normal')\n    deviceStatus = Cpt(Signal, kind = 'normal')\n\n\n    def __init__(self, device, sock, name = 'Kibron', read_attrs=None, *args, **kwargs):\n        \n        if read_attrs is None:\n            read_attrs = ['pressure', 'area', 'speed', 'temperature1', 'temperature2']\n        \n        super().__init__(name = name, read_attrs=read_attrs, *args, **kwargs)\n        self.name = name\n        self.sock = sock\n        self.device = device\n        self.data = self.getData()\n        self.update()\n        # self.area.put(self.getArea())\n        # self.pressure.put(self.getPressure())\n        # self.speed.put(self.getSpeed())\n        # self.temperature1.put(self.getTemperature1())\n        # self.temperature2.put(self.getTemperature2())\n        # self.deviceStatus.put(self.getDeviceStatus())\n\n    def getData(self):\n        try:\n            self.device.call('ClearBuffers')\n            vals = self.device.call(\"GetData\")\n            # Expecting the result to be of the form\n            #   '<status-code> <value-1> <value-2> ... <value-n>\n            # vals is list comprising staus code followed by list of values\n            count = vals[0]\n            if count >= 0:\n                return vals\n            else:\n                print('Data polling error!')\n        except:\n            pass\n\n    def update(self):\n        latest_data = self.getData()\n        self.area.put(latest_data[mtx.uTArea])\n        self.pressure.put(latest_data[mtx.uTPressure])\n        self.speed.put(latest_data[mtx.uTSpeed])\n        self.temperature1.put(latest_data[mtx.uTTemperature1])\n        self.temperature2.put(latest_data[mtx.uTTemperature2])\n        self.deviceStatus.put(latest_data[mtx.uTDeviceStatus])\n\n    def getArea(self):\n        self.area.put(self.getData()[mtx.uTArea])\n        return self.area.get()\n\n    def getPressure(self):\n        self.pressure.put(self.getData()[mtx.uTPressure])\n        return self.pressure.get()\n\n    def getSpeed(self):\n        self.speed.put(self.getData()[mtx.uTSpeed])\n        return self.speed.get()\n\n    def getDeviceStatus(self):\n        self.deviceStatus.put(self.getData()[mtx.uTDeviceStatus])\n        return self.deviceStatus.get()\n\n    def getTemperature1(self):\n        self.temperature1.put(self.getData()[mtx.uTTemperature1])\n        return self.temperature1.get()\n\n    def getTemperature2(self):\n        self.temperature2.put(self.getData()[mtx.uTTemperature2])\n        return self.temperature2.get()\n\n    def close(self):\n        self.sock.close()\n\n\n    def runPressureManual(self, target_pressure, max_area = 6000, target_speed = None):\n        '''TO BE DONE'''\n\n        if target_speed == None:\n            max_speed = self.device.call(\"GetMaxBarrierSpeed\")\n            target_speed = max_speed/4\n\n\n        try:\n            print(\"Compressing barriers, gathering measurement data ...\")\n\n            self.device.call(\"StopMeasure\")\n            self.device.call('ClearBuffers')\n\n            # Tell the trough to produce measurement samples at 1 second intervals\n            self.device.call(\"SetStoreInterval\", 1.0)\n\n            self.device.call(\"SetBarrierSpeed\", target_speed)\n\n            self.device.call(\"NewMeasureMode\", mtx.MeManual)\n\n            # Set time_offset in the measurement file when starting measurement\n \n            self.device.call(\"StartMeasure\")\n\n            self.device.call(\"StepCompress\")\n\n            # Wait until area is three-quarters maximum\n            print(f'Target pressure is {target_pressure}')\n            _pressure = self.getPressure()\n            print(f'Current pressure is {_pressure}')\n\n            while _pressure-target_pressure < 0:\n                time.sleep(1)\n                _data = list(self.getData())\n                _area = _data[mtx.uTArea]\n                if _area < max_area * 0.15:\n                    print('Area is less than 15%.')\n                    break\n                _pressure = _data[mtx.uTPressure]\n                print('Pressure is: %.2f mN/m' %_pressure)\n\n            self.device.call(\"StepStop\")\n\n            self.device.call(\"StopMeasure\")\n\n            print(\"... Done\")\n\n\n        except:\n            pass\n\n\n    def runConstantPressure(self, target_pressure, max_area = 62464, target_speed = None):\n        '''Use the constant pressure mode'''\n\n        if target_speed == None:\n            max_speed = self.device.call(\"GetMaxBarrierSpeed\")\n            target_speed = max_speed/7 # 10mm/min\n\n\n        try:\n            print(\"Compressing barriers, gathering measurement data ...\")\n\n            # Tell the trough to produce measurement samples at 1 second intervals\n            self.device.call(\"SetStoreInterval\", 1.0)\n            self.device.call(\"SetBarrierSpeed\", target_speed)\n            self.device.call(\"StopMeasure\")\n            self.device.call(\"NewMeasureMode\", mtx.MeConstantPressure)\n\n            self.device.call(\"SetTargetPressure\", target_pressure)\n\n            # Set time_offset in the measurement file when starting measurement\n\n            self.device.call(\"StartMeasure\")\n\n            # self.device.call(\"StepCompress\")\n\n            # Wait until area is three-quarters maximum\n            print(f'Target pressure is {target_pressure}')\n            _pressure = self.getPressure()\n            print(f'Current pressure is {_pressure}')\n\n            while abs(_pressure-target_pressure) >= 0.1:\n                time.sleep(1)\n                _data = list(self.getData())\n                _area = _data[mtx.uTArea]\n                if _area < max_area * 0.1:\n                    print('Area is less than 10%.')\n                    self.device.call(\"StopMeasure\")\n                    print(\"The compression has to stop!\")\n                    return 0\n                    # break\n                _pressure = _data[mtx.uTPressure]\n                print('Pressure is: %.2f mN/m' %_pressure)\n\n            # self.device.call(\"StepStop\")\n\n            # self.device.call(\"StopMeasure\")\n\n            print(\"Reach the target pressure!\")\n            return 1\n\n\n        except:\n            pass"
  },
  {
    "class_name": "XBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/12-xbpm.py",
    "source": "class XBPM(Device):\n    ch1 = Cpt(EpicsSignal, 'Current1:MeanValue_RBV')\n    ch2 = Cpt(EpicsSignal, 'Current2:MeanValue_RBV')\n    ch3 = Cpt(EpicsSignal, 'Current3:MeanValue_RBV')\n    ch4 = Cpt(EpicsSignal, 'Current4:MeanValue_RBV')\n    sumX = Cpt(EpicsSignal, 'SumX:MeanValue_RBV')\n    sumY = Cpt(EpicsSignal, 'SumY:MeanValue_RBV')\n    posX = Cpt(EpicsSignal, 'PosX:MeanValue_RBV')\n    posY = Cpt(EpicsSignal, 'PosY:MeanValue_RBV')"
  },
  {
    "class_name": "Xspress3FileStoreFlyable",
    "bases": [
      "Xspress3FileStore"
    ],
    "file": "profile-collections/opls-profile-collection/startup/47-xpress3.py",
    "source": "class Xspress3FileStoreFlyable(Xspress3FileStore):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    @property\n    def filestore_res(self):\n        raise Exception(\"don't want to be here\")\n        return self._filestore_res\n\n    @property\n    def filestore_spec(self):\n        if self.parent._mode is ScanMode.fly:\n            return 'XPS3_FLY'\n        return 'XSP3'\n\n    def generate_datum(self, key, timestamp, datum_kwargs):\n        if self.parent._mode is ScanMode.step:\n            return super().generate_datum(key, timestamp, datum_kwargs)\n        elif self.parent._mode is ScanMode.fly:\n            # we are doing something _very_ dirty here to skip a level\n            # of the inheritance\n            # this is brittle is if the MRO changes we may not hit all\n            # the level we expect to\n            return FileStorePluginBase.generate_datum(\n                self, key, timestamp, datum_kwargs\n            )\n\n    def warmup(self):\n        \"\"\"\n        A convenience method for 'priming' the plugin.\n        The plugin has to 'see' one acquisition before it is ready to capture.\n        This sets the array size, etc.\n        NOTE : this comes from:\n            https://github.com/NSLS-II/ophyd/blob/master/ophyd/areadetector/plugins.py\n        We had to replace \"cam\" with \"settings\" here.\n        Also modified the stage sigs.\n        \"\"\"\n        print(\"Warming up the hdf5 plugin...\", end=\"\")\n        set_and_wait(self.enable, 1)\n        sigs = OrderedDict(\n            [\n                (self.parent.settings.array_callbacks, 1),\n                (self.parent.settings.image_mode, \"Single\"),\n                (self.parent.settings.trigger_mode, \"Internal\"),\n                # In case the acquisition time is set very long\n                (self.parent.settings.acquire_time, 1),\n                # (self.parent.settings.acquire_period, 1),\n                (self.parent.settings.acquire, 1),\n            ]\n        )\n\n        original_vals = {sig: sig.get() for sig in sigs}\n\n        for sig, val in sigs.items():\n            ttime.sleep(0.1)  # abundance of caution\n            set_and_wait(sig, val)\n\n #       ttime.sleep(2)  # wait for acquisition\n\n        for sig, val in reversed(list(original_vals.items())):\n            ttime.sleep(0.1)\n            set_and_wait(sig, val)\n        print(\"done\")\n\n    def describe(self):\n        desc = super().describe()\n\n        if self.parent._mode is ScanMode.fly:\n            spec = {\n                \"external\": \"FileStore:\",\n                \"dtype\": \"array\",\n                # TODO do not hard code\n                \"shape\": (self.parent.settings.num_images.get(), 3, 4096),\n                \"source\": self.prefix,\n            }\n            return {self.parent._f_key: spec}\n        else:\n            return super().describe()"
  },
  {
    "class_name": "OPLSXspress3Detector",
    "bases": [
      "XspressTriggerFlyable",
      "Xspress3Detector"
    ],
    "file": "profile-collections/opls-profile-collection/startup/47-xpress3.py",
    "source": "class OPLSXspress3Detector(XspressTriggerFlyable, Xspress3Detector):\n    # TODO: garth, the ioc is missing some PVs?\n    #   det_settings.erase_array_counters\n    #       (XF:05IDD-ES{Xsp:1}:ERASE_ArrayCounters)\n    #   det_settings.erase_attr_reset (XF:05IDD-ES{Xsp:1}:ERASE_AttrReset)\n    #   det_settings.erase_proc_reset_filter\n    #       (XF:05IDD-ES{Xsp:1}:ERASE_PROC_ResetFilter)\n    #   det_settings.update_attr (XF:05IDD-ES{Xsp:1}:UPDATE_AttrUpdate)\n    #   det_settings.update (XF:05IDD-ES{Xsp:1}:UPDATE)\n    roi_data = Cpt(PluginBase, \"ROIDATA:\")\n\n    # Channels: Uncomment these to enable more\n    channel1 = Cpt(Xspress3Channel, \"C1_\", channel_num=1, read_attrs=[\"rois\"])\n    # channel2 = Cpt(Xspress3Channel, 'C2_', channel_num=2, read_attrs=['rois'])\n    # channel3 = Cpt(Xspress3Channel, 'C3_', channel_num=3, read_attrs=['rois'])\n    acquisition_time = Cpt(EpicsSignal, \"AcquireTime\")\n    capture_mode = Cpt(EpicsSignal, \"HDF5:Capture\")\n\n\n    erase = Cpt(EpicsSignal, \"ERASE\")\n    array_counter = Cpt(EpicsSignal, \"ArrayCounter_RBV\")\n    create_dir = Cpt(EpicsSignal, \"HDF5:FileCreateDir\")\n\n\n    # TODO: Change file locations for OPLS\n    hdf5 = Cpt(\n        Xspress3FileStoreFlyable,\n        \"HDF5:\",\n    # #    read_path_template=\"/nsls2/xf12id1/data/xpress3\",\n    #     read_path_template=\"/nsls2/xf12id1/data/xpress3/%Y/%m/%d/\",\n    # #    write_path_template=\"/nsls2/xf12id1/data/xpress3\",\n    #     write_path_template=\"/nsls2/xf12id1/data/xpress3/%Y/%m/%d/\",\n\n\n        read_path_template=\"/nsls2/data/smi/legacy/xf12id1/data/xpress3/%Y/%m/%d/\",\n        write_path_template=\"/nsls2/data/smi/legacy/xf12id1/data/xpress3/%Y/%m/%d/\",\n\n        # root=\"/\",\n        root='/nsls2/data/smi/legacy/xf12id1/data',\n    #    root=\"/home/xspress3/data\",\n    )\n\n    # this is used as a latch to put the xspress3 into 'bulk' mode\n    # for fly scanning.  Do this is a signal (rather than as a local variable\n    # or as a method so we can modify this as part of a plan\n    fly_next = Cpt(Signal, value=False)\n\n    def __init__(\n        self,\n        prefix,\n        *,\n        f_key=\"fluor\",\n        configuration_attrs=None,\n        read_attrs=None,\n        **kwargs,\n    ):\n        self._f_key = f_key\n        if configuration_attrs is None:\n            configuration_attrs = [\n                \"external_trig\",\n                \"total_points\",\n                \"spectra_per_point\",\n                \"settings\",\n                \"rewindable\",\n            ]\n        if read_attrs is None:\n            read_attrs = [\"channel1\", \"hdf5\"]\n        super().__init__(\n            prefix,\n            configuration_attrs=configuration_attrs,\n            read_attrs=read_attrs,\n            **kwargs,\n        )\n        # this is possiblely one too many places to store this\n        # in the parent class it looks at if the extrenal_trig signal is high\n        self._mode = ScanMode.step\n\n        # self.create_dir.put(-3)\n\n    def stop(self, *, success=False):\n        ret = super().stop()\n        # todo move this into the stop method of the settings object?\n        self.settings.acquire.put(0)\n        self.hdf5.stop(success=success)\n        return ret\n\n    def stage(self):\n        # do the latching\n        if self.fly_next.get():\n            self.fly_next.put(False)\n            self._mode = ScanMode.fly\n        return super().stage()\n\n    def unstage(self):\n        try:\n            ret = super().unstage()\n        finally:\n            self._mode = ScanMode.step\n        return ret"
  },
  {
    "class_name": "XBPM4",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/40-quadem.py",
    "source": "class XBPM4(Device):\n    \"\"\"\n    XBPM are diamond windows that generate current when the beam come through. It is used to know the position\n    of the beam at the bpm postion as well as the amount of incoming photons. 3 bpms are available at SMI: bpm1\n    is position upstream, bpm2 after the focusing mirrons and bpm3 downstream\n    :param Device: ophyd device\n    \"\"\"\n    ch1 = Cpt(EpicsSignal, 'Current1:MeanValue_RBV')\n    ch2 = Cpt(EpicsSignal, 'Current2:MeanValue_RBV')\n    ch3 = Cpt(EpicsSignal, 'Current3:MeanValue_RBV')\n    ch4 = Cpt(EpicsSignal, 'Current4:MeanValue_RBV')\n    sumX = Cpt(EpicsSignal, 'SumX:MeanValue_RBV')\n    sumY = Cpt(EpicsSignal, 'SumY:MeanValue_RBV')\n    posX = Cpt(EpicsSignal, 'PosX:MeanValue_RBV')\n    posY = Cpt(EpicsSignal, 'PosY:MeanValue_RBV')"
  },
  {
    "class_name": "CRL1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/14-crl.py",
    "source": "class CRL1(Device):\n    x = Cpt(EpicsMotor, \"X1}Mtr\")\n    y = Cpt(EpicsMotor, \"Y1}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")"
  },
  {
    "class_name": "CRL2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/opls-profile-collection/startup/14-crl.py",
    "source": "class CRL2(Device):\n    x = Cpt(EpicsMotor, \"X2}Mtr\")\n    y = Cpt(EpicsMotor, \"Y2}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")"
  },
  {
    "class_name": "Lakeshore336Channel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/17-temperature_controllers.py",
    "source": "class Lakeshore336Channel(Device):\n    T = Cpt(EpicsSignalRO, \"T-I\")\n    V = Cpt(EpicsSignalRO, \"Val:Sens-I\")\n    status = Cpt(EpicsSignalRO, \"T-Sts\")"
  },
  {
    "class_name": "Lakeshore336",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/17-temperature_controllers.py",
    "source": "class Lakeshore336(Device):\n    temp = DDC(_temp_fields([\"A\", \"B\", \"C\", \"D\"]))\n    out1 = Cpt(Lakeshore336Setpoint, \"-Out:1}\")\n    out2 = Cpt(Lakeshore336Setpoint, \"-Out:2}\")\n    out3 = Cpt(Lakeshore336Setpoint, \"-Out:3}\")\n    out4 = Cpt(Lakeshore336Setpoint, \"-Out:4}\")\n    ChanA = Cpt(Lakeshore336Channel, \"-Chan:A}\")\n    ChanB = Cpt(Lakeshore336Channel, \"-Chan:B}\")\n    ChanC = Cpt(Lakeshore336Channel, \"-Chan:C}\")\n    ChanD = Cpt(Lakeshore336Channel, \"-Chan:D}\")"
  },
  {
    "class_name": "TwoButtonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class TwoButtonShutter(Device):\n    # vendored from nslsii.devices to extend timeouts/retries\n    RETRY_PERIOD = 1  # seconds\n    MAX_ATTEMPTS = 10\n    # TODO: this needs to be fixed in EPICS as these names make no sense\n    # the value coming out of the PV does not match what is shown in CSS\n    open_cmd = Cpt(EpicsSignal, \"Cmd:Opn-Cmd\", string=True)\n    open_val = \"Open\"\n\n    close_cmd = Cpt(EpicsSignal, \"Cmd:Cls-Cmd\", string=True)\n    close_val = \"Not Open\"\n\n    status = Cpt(EpicsSignalRO, \"Pos-Sts\", string=True)\n    fail_to_close = Cpt(EpicsSignalRO, \"Sts:FailCls-Sts\", string=True)\n    fail_to_open = Cpt(EpicsSignalRO, \"Sts:FailOpn-Sts\", string=True)\n    enabled_status = Cpt(EpicsSignalRO, \"Enbl-Sts\", string=True)\n\n    # user facing commands\n    open_str = \"Open\"\n    close_str = \"Close\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._set_st = None\n\n    def set(self, val):\n        if self._set_st is not None:\n            raise RuntimeError(\n                f\"trying to set {self.name}\" \" while a set is in progress\"\n            )\n\n        cmd_map = {self.open_str: self.open_cmd, self.close_str: self.close_cmd}\n        target_map = {self.open_str: self.open_val, self.close_str: self.close_val}\n\n        cmd_sig = cmd_map[val]\n        target_val = target_map[val]\n\n        st = DeviceStatus(self)\n        if self.status.get() == target_val:\n            st._finished()\n            return st\n\n        self._set_st = st\n        print(self.name, val, id(st))\n        enums = self.status.enum_strs\n\n        def shutter_cb(value, timestamp, **kwargs):\n            value = enums[int(value)]\n            if value == target_val:\n                self._set_st = None\n                self.status.clear_sub(shutter_cb)\n                st._finished()\n\n        cmd_enums = cmd_sig.enum_strs\n        count = 0\n\n        def cmd_retry_cb(value, timestamp, **kwargs):\n            nonlocal count\n            value = cmd_enums[int(value)]\n            count += 1\n            if count > self.MAX_ATTEMPTS:\n                cmd_sig.clear_sub(cmd_retry_cb)\n                self._set_st = None\n                self.status.clear_sub(shutter_cb)\n                st._finished(success=False)\n            if value == \"None\":\n                if not st.done:\n                    time.sleep(self.RETRY_PERIOD)\n                    cmd_sig.set(1)\n\n                    ts = datetime.datetime.fromtimestamp(timestamp).strftime(\n                        _time_fmtstr\n                    )\n                    if count > 2:\n                        msg = \"** ({}) Had to reactuate shutter while {}ing\"\n                        print(msg.format(ts, val if val != \"Close\" else val[:-1]))\n                else:\n                    cmd_sig.clear_sub(cmd_retry_cb)\n\n        cmd_sig.subscribe(cmd_retry_cb, run=False)\n        self.status.subscribe(shutter_cb)\n        cmd_sig.set(1)\n\n        return st"
  },
  {
    "class_name": "Condenser",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class Condenser(Device):\n    x = Cpt(MyEpicsMotor, \"{CLens:1-Ax:X}Mtr\")\n    y1 = Cpt(MyEpicsMotor, \"{CLens:1-Ax:Y1}Mtr\")\n    y2 = Cpt(MyEpicsMotor, \"{CLens:1-Ax:Y2}Mtr\")\n    z1 = Cpt(MyEpicsMotor, \"{CLens:1-Ax:Z1}Mtr\")\n    z2 = Cpt(MyEpicsMotor, \"{CLens:1-Ax:Z2}Mtr\")\n    p = Cpt(MyEpicsMotor, \"{CLens:1-Ax:P}Mtr\")"
  },
  {
    "class_name": "Zoneplate",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class Zoneplate(Device):\n    x = Cpt(MyEpicsMotor, \"{ZP:1-Ax:X}Mtr\")\n    # y = Cpt(MyEpicsMotor, \"{ZP:1-Ax:Y}Mtr\")\n    y = Cpt(MyEpicsMotor, \"{BLens:1-Ax:Y}Mtr\")\n    z = Cpt(MyBaseMotor, \"{TXM-ZP:1-Ax:Z}Mtr\")"
  },
  {
    "class_name": "Aperture",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class Aperture(Device):\n    x = Cpt(MyEpicsMotor, \"{Aper:1-Ax:X}Mtr\")\n    y = Cpt(MyEpicsMotor, \"{Aper:1-Ax:Y}Mtr\")\n    z = Cpt(MyBaseMotor, \"{TXM-Aper:1-Ax:Z}Mtr\")"
  },
  {
    "class_name": "PhaseRing",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class PhaseRing(Device):\n    x = Cpt(MyEpicsMotor, \"{PR:1-Ax:X}Mtr\")\n    y = Cpt(MyEpicsMotor, \"{PR:1-Ax:Y}Mtr\")\n    z = Cpt(MyBaseMotor, \"{TXM-PH:1-Ax:Z}Mtr\")"
  },
  {
    "class_name": "BetrandLens",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class BetrandLens(Device):\n    x = Cpt(MyEpicsMotor, \"{BLens:1-Ax:X}Mtr\")\n    # y = Cpt(MyEpicsMotor, \"{BLens:1-Ax:Y}Mtr\")\n    y = Cpt(MyEpicsMotor, \"{ZP:1-Ax:Y}Mtr\")"
  },
  {
    "class_name": "TXMSampleStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class TXMSampleStage(Device):\n    sx = Cpt(MyEpicsMotor, \"{Env:1-Ax:Xl}Mtr\")\n    sy = Cpt(MyEpicsMotor, \"{Env:1-Ax:Yl}Mtr\")\n    sz = Cpt(MyEpicsMotor, \"{Env:1-Ax:Zl}Mtr\")\n    # pi_x = Cpt(MyBaseMotor, \"{TXM:1-Ax:X}Mtr\")\n    pi_r = Cpt(MyEpicsMotor, \"{TXM:2-Ax:R}Mtr\")"
  },
  {
    "class_name": "DetSupport",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class DetSupport(Device):\n    x = Cpt(MyEpicsMotor, \"-Ax:X}Mtr\")\n    y = Cpt(MyEpicsMotor, \"-Ax:Y}Mtr\")\n    z = Cpt(MyBaseMotor, \"-Ax:Z}Mtr\")"
  },
  {
    "class_name": "TXM_SSA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class TXM_SSA(Device):\n    v_gap = Cpt(MyBaseMotor, \"-Ax:Vgap}Mtr\")\n    v_ctr = Cpt(MyBaseMotor, \"-Ax:Vctr}Mtr\")\n    h_gap = Cpt(MyBaseMotor, \"-Ax:Hgap}Mtr\")\n    h_ctr = Cpt(MyBaseMotor, \"-Ax:Hctr}Mtr\")"
  },
  {
    "class_name": "Scint",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/11-txm_motor.py",
    "source": "class Scint(Device):\n    x = Cpt(MyEpicsMotor, \"-Ax:X}Mtr\")\n    y = Cpt(MyEpicsMotor, \"-Ax:Y}Mtr\")\n    z = Cpt(MyEpicsMotor, \"-Ax:Z}Mtr\")"
  },
  {
    "class_name": "mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/12-optics_motor.py",
    "source": "class mirror(Device):\n    x = Cpt(MyEpicsMotor, \"-Ax:X}Mtr\")\n    yaw = Cpt(MyEpicsMotor, \"-Ax:Yaw}Mtr\")\n    y = Cpt(MyEpicsMotor, \"-Ax:Y}Mtr\")\n    p = Cpt(MyEpicsMotor, \"-Ax:P}Mtr\")\n    r = Cpt(MyEpicsMotor, \"-Ax:R}Mtr\")\n    xu = Cpt(MyEpicsMotor, \"-Ax:XU}Mtr\")\n    xd = Cpt(MyEpicsMotor, \"-Ax:XD}Mtr\")\n    yu = Cpt(MyEpicsMotor, \"-Ax:YU}Mtr\")\n    ydi = Cpt(MyEpicsMotor, \"-Ax:YDI}Mtr\")\n    ydo = Cpt(MyEpicsMotor, \"-Ax:YDO}Mtr\")"
  },
  {
    "class_name": "DCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/12-optics_motor.py",
    "source": "class DCM(Device):\n    th1 = Cpt(MyEpicsMotor, \"-Ax:Th1}Mtr\")\n    dy2 = Cpt(MyEpicsMotor, \"-Ax:dY2}Mtr\")\n    th2 = Cpt(MyEpicsMotor, \"-Ax:Th2}Mtr\")\n    chi2 = Cpt(MyEpicsMotor, \"-Ax:Chi2}Mtr\")\n    eng = Cpt(MyEpicsMotor, \"-Ax:En}Mtr\")"
  },
  {
    "class_name": "PBSL",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/12-optics_motor.py",
    "source": "class PBSL(Device):\n    x_gap = Cpt(MyEpicsMotor, \"-Ax:XGap}Mtr\")\n    y_gap = Cpt(MyEpicsMotor, \"-Ax:YGap}Mtr\")\n    x_ctr = Cpt(MyEpicsMotor, \"-Ax:XCtr}Mtr\")\n    y_ctr = Cpt(MyEpicsMotor, \"-Ax:YCtr}Mtr\")\n    top = Cpt(MyEpicsMotor, \"-Ax:T}Mtr\")\n    bot = Cpt(MyEpicsMotor, \"-Ax:B}Mtr\")\n    ob = Cpt(MyEpicsMotor, \"-Ax:O}Mtr\")\n    ib = Cpt(MyEpicsMotor, \"-Ax:I}Mtr\")"
  },
  {
    "class_name": "EpicsSignalROLazyier",
    "bases": [
      "EpicsSignalRO"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/05-ion-chamber.py",
    "source": "class EpicsSignalROLazyier(EpicsSignalRO):\n    def get(self, *args, timeout=5, **kwargs):\n        return super().get(*args, timeout=timeout, **kwargs)"
  },
  {
    "class_name": "SR570",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/05-ion-chamber.py",
    "source": "class SR570(Device):\n    # SR570 preamps are controlled via one-way RS232 connection. The IOC can keep track only of the\n    # settings change via EPICS. It does not know the actual settings if the changes are made\n    # manually using buttons on the hardware unit.\n\n    init = Cpt(EpicsSignal, \"init.PROC\")\n    reset = Cpt(EpicsSignal, \"reset.PROC\")\n\n    sensitivity_num = Cpt(EpicsSignal, \"sens_num\", string=True)\n    sensitivity_unit = Cpt(EpicsSignal, \"sens_unit\", string=True)\n\n    offset_on = Cpt(EpicsSignal, \"offset_on\", string=True)\n    offset_sign = Cpt(EpicsSignal, \"offset_sign\", string=True)\n    offset_num = Cpt(EpicsSignal, \"offset_num\", string=True)\n    offset_unit = Cpt(EpicsSignal, \"offset_unit\", string=True)\n    offset_u_put = Cpt(EpicsSignal, \"off_u_put\", )\n    offset_u_tweak = Cpt(EpicsSignal, \"offset_u_tweak\")\n    offset_cal = Cpt(EpicsSignal, \"offset_cal\", string=True)\n\n    bias_put = Cpt(EpicsSignal, \"bias_put\")\n    bias_tweak = Cpt(EpicsSignal, \"bias_tweak\")\n    bias_on = Cpt(EpicsSignal, \"bias_on\", string=True)\n\n    filter_type = Cpt(EpicsSignal, \"filter_type\", string=True)\n    filter_reset = Cpt(EpicsSignal, \"filter_reset.PROC\")\n    filter_low_freq = Cpt(EpicsSignal, \"low_freq\", string=True)\n    filter_high_freq = Cpt(EpicsSignal, \"high_freq\", string=True)\n\n    gain_mode = Cpt(EpicsSignal, \"gain_mode\", string=True)\n    invert_on = Cpt(EpicsSignal, \"invert_on\", string=True)\n    blank_on = Cpt(EpicsSignal, \"blank_on\", string=True)"
  },
  {
    "class_name": "SR570_PREAMPS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/05-ion-chamber.py",
    "source": "class SR570_PREAMPS(Device):\n   unit1 = Cpt(SR570, \"{SR570:1}\")\n   unit2 = Cpt(SR570, \"{SR570:2}\")\n   unit3 = Cpt(SR570, \"{SR570:3}\")\n   unit4 = Cpt(SR570, \"{SR570:4}\")"
  },
  {
    "class_name": "WienerHVCrateChannel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/05-ion-chamber.py",
    "source": "class WienerHVCrateChannel(Device):\n\n    status_dec = Cpt(EpicsSignalRO, \"StatusDec\")  # Bits 0-7\n\n    # Meanings of the status bits:\n    # outputOn (0)                              output channel is on\n    # outputInhibit(1)                          external (hardware-)inhibit of the output channel\n    # outputFailureMinSenseVoltage (2)          Sense voltage is too low\n    # outputFailureMaxSenseVoltage (3)          Sense voltage is too high\n    # outputFailureMaxTerminalVoltage (4)       Terminal voltage is too high\n    # outputFailureMaxCurrent (5)               Current is too high\n    # outputFailureMaxTemperature (6)           Heat sink temperature is too high\n    # outputFailureMaxPower (7)                 Output power is too high\n    \n    switch_on_off = Cpt(EpicsSignal, \"Switch\")\n    V_set = Cpt(EpicsSignal, \"V-Set\")\n    V_sense = Cpt(EpicsSignalRO, \"V-Sense\")\n    I_set_limit = Cpt(EpicsSignal, \"I-SetLimit\")\n    I_sense = Cpt(EpicsSignalRO, \"I-Sense\")\n    temperature = Cpt(EpicsSignalRO, \"Temperature\")\n    V_fall_rate = Cpt(EpicsSignal, \"V-FallRate\")\n    V_rise_rate = Cpt(EpicsSignal, \"V-RiseRate\")"
  },
  {
    "class_name": "WienerHVCrate",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/05-ion-chamber.py",
    "source": "class WienerHVCrate(Device):\n\n    u0 = Cpt(WienerHVCrateChannel, \"HV:u0}\")   \n    u1 = Cpt(WienerHVCrateChannel, \"HV:u1}\")   \n    u2 = Cpt(WienerHVCrateChannel, \"HV:u2}\")   \n    u3 = Cpt(WienerHVCrateChannel, \"HV:u3}\")   \n    u4 = Cpt(WienerHVCrateChannel, \"HV:u4}\")   \n    u5 = Cpt(WienerHVCrateChannel, \"HV:u5}\")   \n    u6 = Cpt(WienerHVCrateChannel, \"HV:u6}\")   \n    u7 = Cpt(WienerHVCrateChannel, \"HV:u7}\")"
  },
  {
    "class_name": "PZT",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/13-pzt.py",
    "source": "class PZT(Device):\n    pos = Cpt(EpicsSignalRO, \"GET_POSITION\", kind=\"hinted\")\n    p_gain = Cpt(EpicsSignal, \"GET_SERVO_PGAIN\", kind=\"config\")\n    i_gain = Cpt(EpicsSignal, \"GET_SERVO_IGAIN\", kind=\"config\")\n    d_gain = Cpt(EpicsSignal, \"GET_SERVO_DGAIN\", kind=\"config\")\n    setpos = Cpt(EpicsSignal, \"SET_POSITION.A\", kind=\"normal\")\n    status = Cpt(EpicsSignal, \"GET_SERVO_STATE\", kind=\"normal\")\n    step_size = Cpt(EpicsSignal, \"TWV\", kind=\"normal\")\n\n    @property\n    def bender(self):\n        #        print(\"stop using PZT.bender\")\n        return \"None\"\n\n    @property\n    def stat(self):\n        return \"Enabled\" if self.status.get() else \"Disabled\""
  },
  {
    "class_name": "ZebraPositionCaptureData",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/18-zebra.py",
    "source": "class ZebraPositionCaptureData(Device):\n\n    \"\"\"\n    Data arrays for the Zebra position capture function and their metadata.\n\n    ## Not all variables are needed at FXI - CD\n    \"\"\"\n\n    # Data arrays\n    div1 = Cpt(EpicsSignal, \"PC_DIV1\")\n    div2 = Cpt(EpicsSignal, \"PC_DIV2\")\n    div3 = Cpt(EpicsSignal, \"PC_DIV3\")\n    div4 = Cpt(EpicsSignal, \"PC_DIV4\")\n    enc1 = Cpt(EpicsSignal, \"PC_ENC1\")\n    enc2 = Cpt(EpicsSignal, \"PC_ENC2\")\n    enc3 = Cpt(EpicsSignal, \"PC_ENC3\")\n    enc4 = Cpt(EpicsSignal, \"PC_ENC4\")\n    filt1 = Cpt(EpicsSignal, \"PC_FILT1\")\n    filt2 = Cpt(EpicsSignal, \"PC_FILT2\")\n    filt3 = Cpt(EpicsSignal, \"PC_FILT3\")\n    filt4 = Cpt(EpicsSignal, \"PC_FILT4\")\n    time = Cpt(EpicsSignal, \"PC_TIME\")\n\n    # Array sizes\n    num_cap = Cpt(EpicsSignal, \"PC_NUM_CAP\")\n    num_down = Cpt(EpicsSignal, \"PC_NUM_DOWN\")\n\n    # BOOLs to denote arrays with data\n    cap_enc1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B0\")\n    cap_enc2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B1\")\n    cap_enc3_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B2\")\n    cap_enc4_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B3\")\n    cap_filt1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B4\")\n    cap_filt2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B5\")\n    cap_div1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B6\")\n    cap_div2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B7\")\n    cap_div3_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B8\")\n    cap_div4_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B9\")\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "ZebraPositionCapture",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/18-zebra.py",
    "source": "class ZebraPositionCapture(Device):\n\n    \"\"\"\n    Signals for the position capture function of the Zebra\n    \"\"\"\n\n    # Configuration settings and status PVs\n    enc = Cpt(EpicsSignalWithRBV, \"PC_ENC\")\n    egu = Cpt(EpicsSignalRO, \"M1:EGU\")\n    dir = Cpt(EpicsSignalWithRBV, \"PC_DIR\")\n    tspre = Cpt(EpicsSignalWithRBV, \"PC_TSPRE\")\n    trig_source = Cpt(EpicsSignalWithRBV, \"PC_ARM_SEL\")\n    arm = Cpt(EpicsSignal, \"PC_ARM\")\n    disarm = Cpt(EpicsSignal, \"PC_DISARM\")\n    armed = Cpt(EpicsSignalRO, \"PC_ARM_OUT\")\n    gate_source = Cpt(EpicsSignalWithRBV, \"PC_GATE_SEL\")\n    gate_start = Cpt(EpicsSignalWithRBV, \"PC_GATE_START\")\n    gate_width = Cpt(EpicsSignalWithRBV, \"PC_GATE_WID\")\n    gate_step = Cpt(EpicsSignalWithRBV, \"PC_GATE_STEP\")\n    gate_num = Cpt(EpicsSignalWithRBV, \"PC_GATE_NGATE\")\n    gate_ext = Cpt(EpicsSignalWithRBV, \"PC_GATE_INP\")\n    gated = Cpt(EpicsSignalRO, \"PC_GATE_OUT\")\n    pulse_source = Cpt(EpicsSignalWithRBV, \"PC_PULSE_SEL\")\n    pulse_start = Cpt(EpicsSignalWithRBV, \"PC_PULSE_START\")\n    pulse_width = Cpt(EpicsSignalWithRBV, \"PC_PULSE_WID\")\n    pulse_step = Cpt(EpicsSignalWithRBV, \"PC_PULSE_STEP\")\n    pulse_max = Cpt(EpicsSignalWithRBV, \"PC_PULSE_MAX\")\n    pulse = Cpt(EpicsSignalRO, \"PC_PULSE_OUT\")\n    enc_pos1_sync = Cpt(EpicsSignal, \"M1:SETPOS.PROC\")\n    enc_pos2_sync = Cpt(EpicsSignal, \"M2:SETPOS.PROC\")\n    enc_pos3_sync = Cpt(EpicsSignal, \"M3:SETPOS.PROC\")\n    enc_pos4_sync = Cpt(EpicsSignal, \"M4:SETPOS.PROC\")\n    enc_res1 = Cpt(EpicsSignal, \"M1:MRES\")\n    enc_res2 = Cpt(EpicsSignal, \"M2:MRES\")\n    enc_res3 = Cpt(EpicsSignal, \"M3:MRES\")\n    enc_res4 = Cpt(EpicsSignal, \"M4:MRES\")\n    data_in_progress = Cpt(EpicsSignalRO, \"ARRAY_ACQ\")\n    block_state_reset = Cpt(EpicsSignal, \"SYS_RESET.PROC\")\n    data = Cpt(ZebraPositionCaptureData, \"\")\n\n    def stage(self):\n        self.arm.put(1)\n        super().stage()\n\n    def unstage(self):\n        self.disarm.put(1)\n        self.block_state_reset.put(1)\n        super().unstage()"
  },
  {
    "class_name": "FXIZebraOR",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/18-zebra.py",
    "source": "class FXIZebraOR(Device):\n    # I really appreciate the different indexing for input source\n    # Thank you for that\n\n    use1 = Cpt(EpicsSignal, \"_ENA:B0\")\n    use2 = Cpt(EpicsSignal, \"_ENA:B1\")\n    use3 = Cpt(EpicsSignal, \"_ENA:B2\")\n    use4 = Cpt(EpicsSignal, \"_ENA:B3\")\n    input_source1 = Cpt(EpicsSignal, \"_INP1\")\n    input_source2 = Cpt(EpicsSignal, \"_INP2\")\n    input_source3 = Cpt(EpicsSignal, \"_INP3\")\n    input_source4 = Cpt(EpicsSignal, \"_INP4\")\n    invert1 = Cpt(EpicsSignal, \"_INV:B0\")\n    invert2 = Cpt(EpicsSignal, \"_INV:B1\")\n    invert3 = Cpt(EpicsSignal, \"_INV:B2\")\n    invert4 = Cpt(EpicsSignal, \"_INV:B3\")\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "ZebraAND",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/18-zebra.py",
    "source": "class ZebraAND(Device):\n    # I really appreciate the different indexing for input source\n    # Thank you for that\n    use1 = Cpt(EpicsSignal, \"_ENA:B0\")\n    use2 = Cpt(EpicsSignal, \"_ENA:B1\")\n    use3 = Cpt(EpicsSignal, \"_ENA:B2\")\n    use4 = Cpt(EpicsSignal, \"_ENA:B3\")\n    input_source1 = Cpt(EpicsSignal, \"_INP1\")\n    input_source2 = Cpt(EpicsSignal, \"_INP2\")\n    input_source3 = Cpt(EpicsSignal, \"_INP3\")\n    input_source4 = Cpt(EpicsSignal, \"_INP4\")\n    invert1 = Cpt(EpicsSignal, \"_INV:B0\")\n    invert2 = Cpt(EpicsSignal, \"_INV:B1\")\n    invert3 = Cpt(EpicsSignal, \"_INV:B2\")\n    invert4 = Cpt(EpicsSignal, \"_INV:B3\")\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "ZebraPulse",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/18-zebra.py",
    "source": "class ZebraPulse(Device):\n    width = Cpt(EpicsSignalWithRBV, \"WID\")\n    input_addr = Cpt(EpicsSignalWithRBV, \"INP\")\n    input_str = Cpt(EpicsSignalRO, \"INP:STR\", string=True)\n    input_status = Cpt(EpicsSignalRO, \"INP:STA\")\n    delay = Cpt(EpicsSignalWithRBV, \"DLY\")\n    delay_sync = Cpt(EpicsSignal, \"DLY:SYNC\")\n    time_units = Cpt(EpicsSignalWithRBV, \"PRE\", string=True)\n    output = Cpt(EpicsSignal, \"OUT\")\n\n    input_edge = FC(EpicsSignal, \"{self._zebra_prefix}POLARITY:{self._edge_addr}\")\n\n    _edge_addrs = {\n        1: \"BC\",\n        2: \"BD\",\n        3: \"BE\",\n        4: \"BF\",\n    }\n\n    def __init__(\n        self,\n        prefix,\n        *,\n        index=None,\n        parent=None,\n        configuration_attrs=None,\n        read_attrs=None,\n        **kwargs,\n    ):\n        if read_attrs is None:\n            read_attrs = [\"input_addr\", \"input_edge\", \"delay\", \"width\", \"time_units\"]\n        if configuration_attrs is None:\n            configuration_attrs = []\n\n        zebra = parent\n        self.index = index\n        self._zebra_prefix = zebra.prefix\n        self._edge_addr = self._edge_addrs[index]\n\n        super().__init__(\n            prefix,\n            configuration_attrs=configuration_attrs,\n            read_attrs=read_attrs,\n            parent=parent,\n            **kwargs,\n        )\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "FXITomoFlyer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fxi-profile-collection/startup/18-zebra.py",
    "source": "class FXITomoFlyer(Device):\n    \"\"\"\n    This is the flyer object for the Zebra.\n    This is the position based flyer.\n    \"\"\"\n\n    root_path = \"/nsls2/data/fxi-new/legacy/\"\n    write_path_template = f\"zebra/%Y/%m/%d/\"\n    read_path_template = f\"zebra/%Y/%m/%d/\"\n    reg_root = f\"zebra/\"\n\n    KNOWN_DETS = {\n        \"Andor\", \"MaranaU\", \"KinetixU\", \"MaranaD\", \"KinetixD\", \"Oryx\"\n    }\n\n    CAM_MODES_IN_FLYER = {\n        \"MARANA-4BV6X\": {\n            \"trigger_mode\": [\"Internal\", \"External\"],\n            \"image_mode\": [\"Continuous\", \"Fixed\"],\n            \"bin_options\": [0, 1, 2, 3, 4],   # => [1x1, 2x2, 3x3, 4x4, 8x8]\n            \"min_exp\": 0.001,\n        },\n        \"SONA-4BV6X\": {\n            \"trigger_mode\": [\"Internal\", \"External\"],\n            \"image_mode\": [\"Continuous\", \"Fixed\"],\n            \"bin_options\": [0, 1, 2, 3, 4],   # => [1x1, 2x2, 3x3, 4x4, 8x8]\n            \"min_exp\": 0.001,\n        },\n        \"KINETIX\": {\n            \"trigger_mode\": [\"Internal\", \"Rising Edge\"],\n            \"image_mode\": [\"Continuous\", \"Multiple\"],\n            \"bin_options\": [0, 1, 2],   # => [1x1, 2x2, 4x4]\n            \"min_exp\": 0.0001,\n        },\n        \"KINETIX22\": {\n            \"trigger_mode\": [\"Internal\", \"Rising Edge\"],\n            \"image_mode\": [\"Continuous\", \"Multiple\"],\n            \"bin_options\": [0, 1, 2],   # => [1x1, 2x2, 4x4]\n            \"min_exp\": 0.0001,\n        },\n    }\n    rot_axis = zps.pi_r\n\n    scn_modes = {\n        0: \"standard\",  # a single scan in a given angle range\n        1: \"snaked: multiple files\",  # back-forth rocking scan with each swing being saved into a file\n        2: \"snaked: single file\",  # back-forth rocking scan being saved into a single file\n    }\n\n    dft_pulse_wid = {\"ms\": 0.002, \"s\": 0.0005, \"10s\": 0.003}  # 0: ms  # 1: s  # 2: 10s\n    min_exp = {\n        \"MARANA-4BV6X\": 0.001, \n        \"SONA-4BV6X\": 0.001, \n        \"KINETIX22\": 0.0001,\n        \"Neo\": 0.001, \n        \"Oryx\": 0.001}\n    pc_trig_dir = {1: 0, -1: 1}  # 1: positive, -1: negative\n    rot_var = 0.006\n    scan_cfg = {}\n    pc_cfg = {}\n    _staging_delay = 0.010\n    tspre = \"s\"  ## ['ms', 's', '10s']\n\n    def __init__(self, dets, zebra, *, reg=db.reg, scn_mode=0, **kwargs):\n        super().__init__(\"\", parent=None, **kwargs)\n        self._state = \"idle\"\n        self._dets = dets\n        self._filestore_resource = None\n        self._encoder = zebra\n        self._document_cache = (\n            []\n        )  # self._document_cache defines resource and datum documents\n        self._stage_sigs = {}\n        self._last_bulk = None  # self._last_bulk defines event document\n\n        self.reg = reg\n        self.scn_mode = self.scn_modes[scn_mode]\n        self.extra_stage_sigs = {}\n        self.shutter_delay = 0.1  # unit: deg; _shutter_delay/rot_vel > unibliz shutter opening time 1.5ms\n        self.use_shutter = True\n\n\n        _timeout = 10\n\n        self._encoder.pc.block_state_reset.set(1).wait(_timeout)\n\n        ############### Zebra Setup ###############\n        ## PC Tab\n        self._encoder.pc.data.cap_enc1_bool.set(1).wait(_timeout)\n        self._encoder.pc.data.cap_enc2_bool.set(0).wait(_timeout)\n        self._encoder.pc.data.cap_enc3_bool.set(0).wait(_timeout)\n        self._encoder.pc.data.cap_enc4_bool.set(0).wait(_timeout)\n        self._encoder.pc.data.cap_filt1_bool.set(0).wait(_timeout)\n        self._encoder.pc.data.cap_filt2_bool.set(0).wait(_timeout)\n        self._encoder.pc.data.cap_div1_bool.set(0).wait(_timeout)\n        self._encoder.pc.data.cap_div2_bool.set(0).wait(_timeout)\n        self._encoder.pc.data.cap_div3_bool.set(0).wait(_timeout)\n        self._encoder.pc.data.cap_div4_bool.set(0).wait(_timeout)\n\n        self._encoder.pc.enc.set(0).wait(_timeout)  # 0: Enc1, 1: Enc2, 2: Enc3, 3: Enc4,\n        self._encoder.pc.dir.set(0).wait(_timeout)  # 0: Positive, 1: Negative\n        self._encoder.pc.tspre.set(1).wait(_timeout)  # 0: ms, 1: s, 2: 10s\n\n        ## AND tab -- can be used for external triggering\n        self._encoder.and1.use1.set(0).wait(_timeout)  # 0: No, 1: Yes\n        self._encoder.and1.use2.set(0).wait(_timeout)\n        self._encoder.and1.use3.set(0).wait(_timeout)\n        self._encoder.and1.use4.set(0).wait(_timeout)\n        self._encoder.and1.input_source1.set(0).wait(_timeout)\n        self._encoder.and1.input_source2.set(0).wait(_timeout)\n        self._encoder.and1.input_source3.set(0).wait(_timeout)\n        self._encoder.and1.input_source4.set(0).wait(_timeout)\n        self._encoder.and1.invert1.set(0).wait(_timeout)  # 0: No, 1: Yes\n        self._encoder.and1.invert2.set(0).wait(_timeout)\n        self._encoder.and1.invert3.set(0).wait(_timeout)\n        self._encoder.and1.invert4.set(0).wait(_timeout)\n\n        ## OR Tab -- can be used for diagnose\n        self._encoder.or1.use1.set(0).wait(_timeout)  # 0: No, 1: Yes\n        self._encoder.or1.use2.set(0).wait(_timeout)\n        self._encoder.or1.use3.set(0).wait(_timeout)\n        self._encoder.or1.use4.set(0).wait(_timeout)\n        self._encoder.or1.input_source1.set(0).wait(_timeout)\n        self._encoder.or1.input_source2.set(0).wait(_timeout)\n        self._encoder.or1.input_source3.set(0).wait(_timeout)\n        self._encoder.or1.input_source4.set(0).wait(_timeout)\n        self._encoder.or1.invert1.set(0).wait(_timeout)  # 0 = No, 1 = Yes\n        self._encoder.or1.invert2.set(0).wait(_timeout)\n        self._encoder.or1.invert3.set(0).wait(_timeout)\n        self._encoder.or1.invert4.set(0).wait(_timeout)\n\n        ## PULSE tab -- set for fast shutter\n        self._encoder.pulse1.input_addr.set(31).wait(_timeout)\n        self._encoder.pulse1.input_edge.set(0).wait(_timeout)  # 0 = rising, 1 = falling\n        self._encoder.pulse1.delay.set(0).wait(_timeout)\n        self._encoder.pulse2.input_addr.set(31).wait(_timeout)\n        self._encoder.pulse2.input_edge.set(1).wait(_timeout)  # 0 = rising, 1 = falling\n        self._encoder.pulse2.delay.set(0).wait(_timeout)\n\n        ## ENC tab\n        self._encoder.pc.enc_pos1_sync.set(1).wait(_timeout)\n        self._encoder.pc.enc_pos2_sync.set(0).wait(_timeout)\n        self._encoder.pc.enc_pos3_sync.set(0).wait(_timeout)\n        self._encoder.pc.enc_pos4_sync.set(0).wait(_timeout)\n\n        ## SYS tab\n        self._encoder.output1.ttl.addr.set(53).wait(_timeout) # PC_PULSE --> TTL1 --> Camera\n        self._encoder.output2.ttl.addr.set(52).wait(_timeout) # PC_PULSE --> TTL2 --> fast shutter\n        self._encoder.output3.ttl.addr.set(0).wait(_timeout)\n        self._encoder.output4.ttl.addr.set(0).wait(_timeout)\n\n    @property\n    def encoder(self):\n        return self._encoder\n\n    @property\n    def detectors(self):\n        return tuple(self._dets)\n\n    @detectors.setter\n    def detectors(self, value):\n        dets = tuple(value)\n        if not all(d.name in self.KNOWN_DETS for d in dets):\n            raise ValueError(\n                f\"One or more of {[d.name for d in dets]}\"\n                f\"is not known to the zebra. \"\n                f\"The known detectors are {self.KNOWN_DETS})\"\n            )\n        self._dets = dets\n\n    @classmethod\n    def _adjust_zebra_gate_start(cls, zebra_gate_start_val):\n        \"\"\" Workaround solution for setting buggy Zebra \"Gate Start\"\n        Note: the workaround solution below does not work due to the register issue and \n              Gate Start RBV issue. it won't be able to take a positive Gate Start value.\n              Otherwise, set() would block actions after setting Gate Start. \n        Issue 1: \"Gate Start\" cannot take a positive number; all values are offset  \n                 by a value ZEBRA_OVERFLOW\n        Issue 2: \"Gate Start\" RBV is reset to another value if the value to be set \n                 is smaller than -491040.4681, e.g. -491040.4682 would be reset to\n                 1473121.4049, which gives np.log2((491040.4682+1473121.4049)/2.286585E-4)=33\n        Workaround: limit ange range to [-491040.4681, 491040.4681].\n        \"\"\"\n        if (-491040.4681 > zebra_gate_start_val) or (zebra_gate_start_val > 491040.4681):\n            raise ValueError(\"Invalid Zebra Start Gate value. It should be in range [-491040.4681, 491040.4681]!\")\n        elif -491040.4681 <= zebra_gate_start_val <= 0:\n            return zebra_gate_start_val\n        else:\n            return (982080.9365000001 + zebra_gate_start_val) \n\n    def preset_zebra(self, pc_cfg={}):\n        print(f\"{pc_cfg=}\")\n        print(f'{self.scn_mode=}')\n        ############### PC Arm\n        yield from abs_set(\n            self._encoder.pc.trig_source, 0, wait=True\n        )  # 0 = Soft, 1 = External\n\n        ############### PULSE -- set unibliz trigger to 'external exposure'\n        if self.use_shutter:\n            yield from abs_set(self._encoder.pulse1.time_units, self.tspre, wait=True)\n            yield from abs_set(\n                self._encoder.pulse1.width, self.dft_pulse_wid[self.tspre], wait=True\n            )\n            yield from abs_set(self._encoder.pulse2.time_units, self.tspre, wait=True)\n            yield from abs_set(\n                self._encoder.pulse2.width, self.dft_pulse_wid[self.tspre], wait=True\n            )\n            yield from abs_set(self._encoder.output2.ttl.addr, 52, wait=True)\n        else:\n            yield from abs_set(self._encoder.output2.ttl.addr, 29, wait=True)\n        if self.scn_mode == \"standard\":\n            ############### PC Tab ###############\n            ## PC Gate\n            yield from abs_set(\n                self._encoder.pc.gate_source, 0, wait=True\n            )  # 0 = Position, 1 = Time, 2 = External\n            yield from abs_set(self._encoder.pc.gate_step, 0, wait=True)\n            yield from abs_set(self._encoder.pc.gate_num, 1, wait=True)\n\n            ## PC Pulse\n            yield from abs_set(\n                self._encoder.pc.pulse_source, 0, wait=True\n            )  # 0 = Position, 1 = Time, 2 = External\n            yield from abs_set(\n                self._encoder.pc.pulse_width, self.dft_pulse_wid[self.tspre], wait=True\n            )\n        elif self.scn_mode == \"snaked: multiple files\":\n            ############### PC Tab ###############\n            ## PC Gate\n            yield from abs_set(\n                self._encoder.pc.gate_source, 0, wait=True\n            )  # 0 = Position, 1 = Time, 2 = External\n            yield from abs_set(self._encoder.pc.gate_step, 0, wait=True)\n            yield from abs_set(self._encoder.pc.gate_num, 1, wait=True)\n\n            ## PC Pulse\n            yield from abs_set(\n                self._encoder.pc.pulse_source, 0, wait=True\n            )  # 0 = Position, 1 = Time, 2 = External\n            set_and_wait(\n                self._encoder.pc.pulse_width, self.dft_pulse_wid[self.tspre], rtol=0.1\n            )\n            # set(0).wait(_timeout)\n        elif self.scn_mode == \"snaked: single file\":\n            ############### PC Tab ###############\n            ## PC Gate\n            yield from abs_set(\n                self._encoder.pc.gate_source, 2, wait=True\n            )  # 0 = Position, 1 = Time, 2 = External\n            yield from abs_set(self._encoder.pc.gate_ext, 29, wait=True)\n            yield from abs_set(self._encoder.pc.gate_num, 0, wait=True)\n\n            ## PC Pulse\n            yield from abs_set(\n                self._encoder.pc.pulse_source, 1, wait=True\n            )  # 0 = Position, 1 = Time, 2 = External\n            set_and_wait(\n                self._encoder.pc.pulse_width, self.dft_pulse_wid[self.tspre], rtol=0.1\n            )\n\n        for key, val in pc_cfg[self.scn_mode].items():\n            set_and_wait(getattr(self._encoder.pc, key), val, rtol=0.1)\n\n    def make_filename(self):\n        \"\"\"Make a filename.\n        Taken/Modified from ophyd.areadetector.filestore_mixins\n        This is a hook so that the read and write paths can either be modified\n        or created on disk prior to configuring the areaDetector plugin.\n        Returns\n        -------\n        filename : str\n            The start of the filename\n        read_path : str\n            Path that ophyd can read from\n        write_path : str\n            Path that the IOC can write to\n        \"\"\"\n        filename = f\"{new_short_uid()}.h5\"\n        formatter = datetime.now().strftime\n        write_path = formatter(f\"{self.root_path}{self.write_path_template}\")\n        read_path = formatter(f\"{self.root_path}{self.read_path_template}\")\n        return filename, read_path, write_path\n\n    def stage(self):\n        self._stage_with_delay()\n        super.stage()\n\n    def _stage_with_delay(self):\n        # Staging taken from https://github.com/bluesky/ophyd/blob/master/ophyd/device.py\n        # Device - BlueskyInterface\n        \"\"\"Stage the device for data collection.\n        This method is expected to put the device into a state where\n        repeated calls to :meth:`~BlueskyInterface.trigger` and\n        :meth:`~BlueskyInterface.read` will 'do the right thing'.\n        Staging not idempotent and should raise\n        :obj:`RedundantStaging` if staged twice without an\n        intermediate :meth:`~BlueskyInterface.unstage`.\n        This method should be as fast as is feasible as it does not return\n        a status object.\n        The return value of this is a list of all of the (sub) devices\n        stage, including it's self.  This is used to ensure devices\n        are not staged twice by the :obj:`~bluesky.run_engine.RunEngine`.\n        This is an optional method, if the device does not need\n        staging behavior it should not implement `stage` (or\n        `unstage`).\n        Returns\n        -------\n        devices : list\n            list including self and all child devices staged\n        \"\"\"\n        if self._staged == Staged.no:\n            pass  # to short-circuit checking individual cases\n        elif self._staged == Staged.yes:\n            raise RedundantStaging(\n                \"Device {!r} is already staged. \" \"Unstage it first.\".format(self)\n            )\n        elif self._staged == Staged.partially:\n            raise RedundantStaging(\n                \"Device {!r} has been partially staged. \"\n                \"Maybe the most recent unstaging \"\n                \"encountered an error before finishing. \"\n                \"Try unstaging again.\".format(self)\n            )\n        self.log.debug(\"Staging %s\", self.name)\n        self._staged = Staged.partially\n\n        # Resolve any stage_sigs keys given as strings: 'a.b' -> self.a.b\n        stage_sigs = OrderedDict()\n        for k, v in self.stage_sigs.items():\n            if isinstance(k, str):\n                # Device.__getattr__ handles nested attr lookup\n                stage_sigs[getattr(self, k)] = v\n            else:\n                stage_sigs[k] = v\n\n        # Read current values, to be restored by unstage()\n        original_vals = {sig: sig.get() for sig in stage_sigs}\n\n        # We will add signals and values from original_vals to\n        # self._original_vals one at a time so that\n        # we can undo our partial work in the event of an error.\n\n        # Apply settings.\n        devices_staged = []\n        try:\n            for sig, val in stage_sigs.items():\n                self.log.debug(\n                    \"Setting %s to %r (original value: %r)\",\n                    self.name,\n                    val,\n                    original_vals[sig],\n                )\n                sig.set(val, timeout=10).wait()\n                ttime.sleep(self._staging_delay)\n                # It worked -- now add it to this list of sigs to unstage.\n                self._original_vals[sig] = original_vals[sig]\n            devices_staged.append(self)\n\n            # Call stage() on child devices.\n            for attr in self._sub_devices:\n                device = getattr(self, attr)\n                if hasattr(device, \"stage\"):\n                    device.stage()\n                    devices_staged.append(device)\n        except Exception:\n            self.log.debug(\n                \"An exception was raised while staging %s or \"\n                \"one of its children. Attempting to restore \"\n                \"original settings before re-raising the \"\n                \"exception.\",\n                self.name,\n            )\n            self.unstage()\n            raise\n        else:\n            self._staged = Staged.yes\n        return devices_staged\n\n    def unstage(self):\n        self._unstage_with_delay()\n\n    def _unstage_with_delay(self):\n        # Staging taken from https://github.com/bluesky/ophyd/blob/master/ophyd/device.py\n        # Device - BlueskyInterface\n        \"\"\"Unstage the device.\n        This method returns the device to the state it was prior to the\n        last `stage` call.\n        This method should be as fast as feasible as it does not\n        return a status object.\n        This method must be idempotent, multiple calls (without a new\n        call to 'stage') have no effect.\n        Returns\n        -------\n        devices : list\n            list including self and all child devices unstaged\n        \"\"\"\n        self.log.debug(\"Unstaging %s\", self.name)\n        self._staged = Staged.partially\n        devices_unstaged = []\n\n        # Call unstage() on child devices.\n        for attr in self._sub_devices[::-1]:\n            device = getattr(self, attr)\n            if hasattr(device, \"unstage\"):\n                device.unstage()\n                devices_unstaged.append(device)\n\n        # Restore original values.\n        for sig, val in reversed(list(self._original_vals.items())):\n            self.log.debug(\"Setting %s back to its original value: %r)\", self.name, val)\n            sig.set(val, timeout=10).wait()\n            ttime.sleep(self._staging_delay)\n            self._original_vals.pop(sig)\n        devices_unstaged.append(self)\n\n        self._staged = Staged.no\n        return devices_unstaged\n\n    def kickoff(self, *, scn_cfg={}):\n        self._encoder.pc.arm.put(0)\n        ttime.sleep(self._staging_delay)\n        self._state = \"kicked off\"\n\n        if scn_cfg[\"ang_s\"] < scn_cfg[\"ang_e\"]:\n            self._encoder.pc.dir.put(0)\n            try:\n                self.rot_axis.user_setpoint.put(scn_cfg[\"ang_s\"] - scn_cfg[\"taxi_dist\"])\n            except Exception as e:\n                print(e)\n                print(\"Cannot move rotary stage to its taxi position.\")\n                return\n        else:\n            self._encoder.pc.dir.put(1)\n            try:\n                self.rot_axis.user_setpoint.put(scn_cfg[\"ang_s\"] + scn_cfg[\"taxi_dist\"])\n            except Exception as e:\n                print(e)\n                print(\"Cannot move rotary stage to its taxi position.\")\n                return\n\n        if scn_cfg[\"scn_mode\"] == \"snaked: multiple files\":\n            self._encoder.pc.gate_start.put(scn_cfg[\"ang_s\"])\n\n        # sync rotary stage encoder\n        self._encoder.pc.enc_pos1_sync.put(1)\n        ttime.sleep(self._staging_delay)\n\n        # Do a block reset on the zebra\n        self._encoder.pc.block_state_reset.put(1)\n        ttime.sleep(self._staging_delay)\n\n        return NullStatus()\n\n    def complete(self):\n        \"\"\"\n        Call this when all needed data has been collected. This has no idea\n        whether that is true, so it will obligingly stop immediately. It is\n        up to the caller to ensure that the motion is actually complete.\n        \"\"\"\n        # Our acquisition complete PV is: XF:05IDD-ES:1{Dev:Zebra1}:ARRAY_ACQ\n        t0 = ttime.monotonic()\n        while self._encoder.pc.data_in_progress.get() == 1:\n            ttime.sleep(self._staging_delay)\n            if (ttime.monotonic() - t0) > 60:\n                print(f\"{self.name} is behaving badly!\")\n                self._encoder.pc.disarm.put(1)\n                ttime.sleep(0.100)\n                if self._encoder.pc.data_in_progress.get() == 1:\n                    raise TimeoutError\n\n        self._state = \"complete\"\n        self._encoder.pc.block_state_reset.put(1)\n\n        for d in self._dets:\n            d.stop()\n\n        # Set filename/path for zebra data\n        f, rp, wp = self.make_filename()\n        self.__filename = f\n        self.__read_filepath = os.path.join(rp, self.__filename)\n        self.__write_filepath = os.path.join(wp, self.__filename)\n\n        self.__filestore_resource, datum_factory_z = resource_factory(\n            \"ZEBRA_HDF51\",\n            root=\"/\",\n            resource_path=self.__read_filepath,\n            resource_kwargs={},\n            path_semantics=\"posix\",\n        )\n\n        time_datum = datum_factory_z({\"column\": \"zebra_time\"})\n        enc1_datum = datum_factory_z({\"column\": \"enc1_pi_r\"})\n\n        # self._document_cache defines resource and datum documents\n        self._document_cache = [(\"resource\", self.__filestore_resource)]\n        self._document_cache.extend(\n            (\"datum\", d)\n            for d in (\n                time_datum,\n                enc1_datum,\n            )\n        )\n\n        # grab the asset documents from all of the child detectors\n        for d in self._dets:\n            self._document_cache.extend(d.collect_asset_docs())\n\n        # Write the file.\n        # @timer_wrapper\n        def get_zebra_data():\n            export_zebra_data(self._encoder, self.__write_filepath)\n\n        get_zebra_data()\n\n        # Yield a (partial) Event document. The RunEngine will put this\n        # into metadatastore, as it does all readings.\n        self._last_bulk = {\n            \"time\": ttime.time(),\n            \"seq_num\": 1,\n            \"data\": {\n                \"zebra_time\": time_datum[\"datum_id\"],\n                \"enc1_pi_r\": enc1_datum[\"datum_id\"],\n            },\n            \"timestamps\": {\n                \"zebra_time\": time_datum[\"datum_id\"],  # not a typo#\n                \"enc1_pi_r\": time_datum[\"datum_id\"],\n            },\n        }\n\n        for d in self._dets:\n            reading = d.read()\n            self._last_bulk[\"data\"].update({k: v[\"value\"] for k, v in reading.items()})\n            self._last_bulk[\"timestamps\"].update(\n                {k: v[\"timestamp\"] for k, v in reading.items()}\n            )\n        # print(\n        #     f\"\\nin complete: {type(self._last_bulk)=}\\n{type(self._document_cache)=}\\n\"\n        # )\n        # print(f\"\\nin complete: {(self._last_bulk)=}\\n{(self._document_cache)=}\\n\")\n\n        return NullStatus()\n\n    def describe_collect(self):\n        ext_spec = \"FileStore:\"\n        num_zebra_data = self.encoder.pc.data.time.get().shape[0]\n\n        spec = {\n            \"external\": ext_spec,\n            \"dtype\": \"array\",\n            \"shape\": [num_zebra_data],\n            \"source\": \"\",  # make this the PV of the array the det is writing\n        }\n\n        desc = OrderedDict()  # desc defines data_keys\n\n        desc[\"zebra_time\"] = spec\n        desc[\"zebra_time\"][\"source\"] = getattr(self._encoder.pc.data, \"enc1\").pvname\n        desc[\"enc1_pi_r\"] = spec\n        desc[\"enc1_pi_r\"][\"source\"] = getattr(self._encoder.pc.data, \"enc1\").pvname\n\n        # Handle the detectors we are going to get\n        for d in self.detectors:\n            desc.update(d.describe())\n        # print(f\"\\nin describe_collect {desc=}\\n\")\n\n        # # Handle the ion chamber that the zebra is collecting\n        # desc[\"i0\"] = spec\n        # desc[\"i0\"][\"source\"] = self._sis.mca2.pvname\n        # desc[\"i0_time\"] = spec\n        # desc[\"i0_time\"][\"source\"] = self._sis.mca1.pvname\n        # desc[\"im\"] = spec\n        # desc[\"im\"][\"source\"] = self._sis.mca3.pvname\n        # desc[\"it\"] = spec\n        # desc[\"it\"][\"source\"] = self._sis.mca4.pvname\n\n        return {\"primary\": desc}\n\n    def collect(self):\n        # Create records in the FileStore database.\n        # move this to stage because I think that describe_collect needs the\n        # resource id\n        # TODO use ophyd.areadectector.filestoer_mixins.resllource_factory here\n        if self._last_bulk is None:\n            raise Exception(\n                \"the order of complete and collect is brittle and out \"\n                \"of sync. This device relies on in-order and 1:1 calls \"\n                \"between complete and collect to correctly create and stash \"\n                \"the asset registry documents\"\n            )\n        # self._last_bulk defines a event document\n        yield self._last_bulk\n        self._last_bulk = None\n        self._state = \"idle\"\n\n    def collect_asset_docs(self):\n        yield from iter(list(self._document_cache))\n        self._document_cache.clear()\n\n    def stop(self):\n        self._encoder.pc.block_state_reset.put(1)\n        pass\n\n    def pause(self):\n        \"Pausing in the middle of a kickoff nukes the partial dataset.\"\n        self._encoder.pc.block_state_reset.put(1)\n        for d in self._dets:\n            if hasattr(d, \"settings\"):\n                d.settings.acquire.put(0)\n            if hasattr(d, \"cam\"):\n                d.cam.acquire.put(0)\n        self._state = \"idle\"\n        self.unstage()\n\n    def resume(self):\n        self.unstage()\n        self.stage()\n\n    def preset_flyer(self, scn_cfg):\n        yield from FXITomoFlyer.bin_det(self.detectors[0], scn_cfg[\"bin_fac\"])\n        yield from FXITomoFlyer.prime_det(self.detectors[0])\n        yield from FXITomoFlyer.init_mot_r(scn_cfg)\n        scn_cfg = FXITomoFlyer.cal_cam_rot_params(self.detectors[0], scn_cfg)\n        pc_cfg = FXITomoFlyer.cal_zebra_pc_params(scn_cfg)\n        yield from self.preset_zebra(pc_cfg)\n        print(\"preset_flyer is done\")\n        return scn_cfg, pc_cfg\n\n    def set_pc_step_for_scan(self, scn_cfg, pc_cfg):\n        print(3.1)\n        print(f\"{pc_cfg=}\")\n        pc_cfg[self.scn_mode][\"dir\"] = self.pc_trig_dir[\n            int(scn_cfg[\"rot_dir\"])\n        ]\n        print(3.2)\n        print(f\"{pc_cfg=}\")\n        yield from abs_set(self.encoder.pc.dir, pc_cfg[self.scn_mode][\"dir\"], wait=True)\n        print(3.3)\n        print(f\"{pc_cfg=}\")\n        pc_cfg[self.scn_mode][\"gate_start\"] = FXITomoFlyer._adjust_zebra_gate_start(scn_cfg[\"ang_s\"])\n        print(3.4)\n        print(f\"{pc_cfg=}\")    \n        yield from abs_set(\n            self.encoder.pc.gate_start, pc_cfg[self.scn_mode][\"gate_start\"], wait=True\n        )\n        print(3.5)\n\n    @classmethod\n    def cal_cam_rot_params(cls, det, scn_cfg):\n        \"\"\"_summary_\n\n        Args:\n            det (str): choose from the set {\"Andor\", \"MaranaU\", \"KinetixU\", \"Oryx\"}\n            scn_cfg (dict): scan configuration parameters composed of\n                'scn_mode': choose between {\n                        0: \"standard\", # a single scan in a given angle range\n                        1: \"snaked: single file\", # back-forth rocking scan being saved into a single file\n                        2: \"snaked: multiple files\" # back-forth rocking scan with each swing being saved into a file\n                        }\n                'exp_t': detector exposure time in second,\n                'acq_p': acquisition period in second,\n                'bin_fac': detector binning factor,\n                'ang_s': scan starting angle,\n                'ang_e': scan end angle,\n                'num_swing': number of sub-scans; motion from one side to another side is defined as one swing\n                'vel': rotation velocity in deg/sec,\n                'tacc': rotation stage acceleration in sec,\n                \"taxi_dist\": taxi distance in unit deg\n\n        Returns:\n            dict: scan_cfg\n        \"\"\"\n        cam_model = _get_cam_model(det)\n        ############### calculate detector parameters ###############\n        if scn_cfg[\"exp_t\"] < FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"min_exp\"]:\n            print(\n                \"Exposure time is too small for the camera. Reset exposure time to minimum allowed exposure time.\"\n            )\n            scn_cfg[\"exp_t\"] = FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"min_exp\"]\n\n        acq_p, acq_min = FXITomoFlyer.check_cam_acq_p(det, scn_cfg[\"exp_t\"], scn_cfg[\"acq_p\"], scn_cfg[\"bin_fac\"])\n\n        if acq_p > scn_cfg[\"acq_p\"]:\n            print(\n                \"Acquisition period is too small for the camera. Reset acquisition period to minimum allowed exposure time.\"\n            )\n        scn_cfg[\"acq_p\"] = acq_p\n\n        print(f\"scn_cfg['acq_p']: {scn_cfg['acq_p']}, scn_cfg['exp_t']: {scn_cfg['exp_t']}\")\n\n        # if scn_cfg[\"exp_t\"] > (acq_p - acq_min):\n        #     scn_cfg[\"exp_t\"] = acq_p - acq_min\n\n        ############### calculate rotary stage parameters ###############\n        if scn_cfg[\"tacc\"] <= 0:\n            print(\"Acceleration time cannot be smaller than 0. Reset it to 1 second.\")\n            scn_cfg[\"tacc\"] = 1\n\n        if scn_cfg[\"vel\"] > cls.rot_axis.max_velo.get():\n            print(\n                \"Designed velocity exceeds the maximum allowed velocity. Reset it to the maximum allowed velocity\"\n            )\n            scn_cfg[\"vel\"] = cls.rot_axis.max_velo.get()\n        elif scn_cfg[\"vel\"] < cls.rot_axis.base_velo.get():\n            print(\n                \"Designed velocity is smaller than the minimum allowed velocity. Reset it to the minimum allowed velocity\"\n            )\n            scn_cfg[\"vel\"] = cls.rot_axis.base_velo.get()\n\n        taxi_dist = max(\n            np.ceil(\n            (scn_cfg[\"vel\"] - cls.rot_axis.base_velo.get()) * scn_cfg[\"tacc\"] / 2\n            ), 1\n        )\n        print(f\"{taxi_dist=}\")\n        if not (\n            cls.rot_axis.low_limit_switch.get() == 0\n            and cls.rot_axis.high_limit_switch.get() == 0\n        ):\n            if (scn_cfg[\"ang_s\"] - taxi_dist) < cls.rot_axis.low_limit.get():\n                print(\n                    \"Rotation range is beyond the low limit of the rotary stage. Quit!\"\n                )\n                return None\n            elif (scn_cfg[\"ang_s\"] - taxi_dist) > cls.rot_axis.high_limit.get():\n                print(\n                    \"Rotation range is beyond the high limit of the rotary stage. Quit!\"\n                )\n                return None\n\n            if (scn_cfg[\"ang_e\"] + taxi_dist) < cls.rot_axis.low_limit.get():\n                print(\n                    \"Rotation range is beyond the low limit of the rotary stage. Quit!\"\n                )\n                return None\n            elif (scn_cfg[\"ang_e\"] + taxi_dist) > cls.rot_axis.high_limit.get():\n                print(\n                    \"Rotation range is beyond the high limit of the rotary stage. Quit!\"\n                )\n                return None\n\n        print(f\"{taxi_dist=}\")\n        scn_cfg[\"taxi_dist\"] = taxi_dist\n        scn_cfg[\"ang_step\"] = scn_cfg[\"vel\"] * (scn_cfg[\"acq_p\"] + FXITomoFlyer.rot_var)\n        if cls.scn_modes[scn_cfg[\"scn_mode\"]] == \"snaked: single file\":\n            scn_cfg[\"num_images\"] = int(\n                int(\n                    round(\n                        abs(scn_cfg[\"ang_e\"] - scn_cfg[\"ang_s\"])\n                        / (scn_cfg[\"acq_p\"] * scn_cfg[\"vel\"])\n                        + 2 * scn_cfg[\"tacc\"] / scn_cfg[\"acq_p\"]\n                    )\n                )\n                * scn_cfg[\"num_swing\"]\n            )\n        else:\n            scn_cfg[\"num_images\"] = int(\n                round(\n                    abs(scn_cfg[\"ang_e\"] - scn_cfg[\"ang_s\"])\n                    / round(scn_cfg[\"ang_step\"], 3)\n                    + 1\n                )\n            )\n\n        if scn_cfg[\"ang_s\"] < scn_cfg[\"ang_e\"]:\n            scn_cfg[\"rot_dir\"] = 1\n        else:\n            scn_cfg[\"rot_dir\"] = -1\n        print(f\"scn_cfg: {scn_cfg}\")\n        return scn_cfg\n\n    @staticmethod\n    def check_cam_acq_p(det, exp_t, acq_p, bin_fac):\n        cam_model = _get_cam_model(det)\n        if cam_model == \"MARANA-4BV6X\":\n            full_acq_min = CAM_RD_CFG[cam_model][\"rd_time\"][det.pre_amp.enum_strs[det.pre_amp.value]]\n            acq_min = full_acq_min * (det.cam.size.size_y.value / 2046) + FXITomoFlyer.rot_var # add vel uncertainty tolerance\n        elif cam_model == \"SONA-4BV6X\":\n            full_acq_min = CAM_RD_CFG[cam_model][\"rd_time\"][det.pre_amp.enum_strs[det.pre_amp.value]]\n            acq_min = full_acq_min * (det.cam.size.size_y.value / 2048) + FXITomoFlyer.rot_var # add vel uncertainty tolerance\n        elif cam_model == \"KINETIX22\":\n            full_acq_min = CAM_RD_CFG[cam_model][\"rd_time\"][det.cam.readout_port_names[det.cam.readout_port_idx.value]]\n            acq_min = full_acq_min * (det.cam.size.size_y.value / 2400) + FXITomoFlyer.rot_var # add vel uncertainty tolerance\n        elif cam_model == \"KINETIX\":\n            full_acq_min = CAM_RD_CFG[cam_model][\"rd_time\"][det.cam.readout_port_names[det.cam.readout_port_idx.value]]\n            acq_min = full_acq_min * (det.cam.size.size_y.value / 3200) + FXITomoFlyer.rot_var # add vel uncertainty tolerance\n        acq_p = round(max(acq_min + exp_t, acq_p) * 1000) / 1000.  # add miminum exposure time\n        return acq_p, acq_min\n\n    @classmethod\n    def cal_zebra_pc_params(cls, scn_cfg):\n        \"\"\"_summary_\n\n        Args:\n            scn_cfg (dict): scan configuration parameters composed of\n                'scn_mode': choose between {\n                        0: \"standard\", # a single scan in a given angle range\n                        1: \"snaked: single file\", # back-forth rocking scan being saved into a single file\n                        2: \"snaked: multiple files\" # back-forth rocking scan with each swing being saved into a file\n                        }\n                'exp_t': detector exposure time in second,\n                'acq_p': acquisition period in second,\n                'bin_fac': detector binning factor,\n                'ang_s': scan starting angle,\n                'ang_e': scan end angle,\n                'num_swing': number of sub-scans; motion from one side to another side is defined as one swing\n                'vel': rotation velocity in deg/sec,\n                'tacc': rotation stage acceleration in sec,\n                \"taxi_dist\": taxi distance in unit deg\n\n        Returns:\n            dict: pc_cfg\n        \"\"\"\n        pc_cfg = {\n            \"standard\": {},\n            \"snaked: multiple files\": {},\n            \"snaked: single file\": {},\n        }\n        if cls.scn_modes[scn_cfg[\"scn_mode\"]] == \"standard\":\n            pc_cfg[\"standard\"][\"pulse_start\"] = 0\n            pc_cfg[\"standard\"][\"pulse_width\"] = (\n                cls.dft_pulse_wid[cls.tspre] * scn_cfg[\"vel\"]\n            )\n            pc_cfg[\"standard\"][\"pulse_step\"] = round(scn_cfg[\"ang_step\"], 3)\n            pc_cfg[\"standard\"][\"pulse_max\"] = int(\n                round(\n                    abs(scn_cfg[\"ang_e\"] - scn_cfg[\"ang_s\"])\n                    / pc_cfg[\"standard\"][\"pulse_step\"]\n                    + 1\n                )\n            )\n            pc_cfg[\"standard\"][\"gate_start\"] = cls._adjust_zebra_gate_start(scn_cfg[\"ang_s\"])\n            pc_cfg[\"standard\"][\"gate_width\"] = (\n                abs(scn_cfg[\"ang_e\"] - scn_cfg[\"ang_s\"])\n                + pc_cfg[\"standard\"][\"pulse_step\"]\n            )\n        elif cls.scn_modes[scn_cfg[\"scn_mode\"]] == \"snaked: multiple files\":\n            pc_cfg[\"snaked: multiple files\"][\"pulse_start\"] = 0\n            pc_cfg[\"snaked: multiple files\"][\"pulse_width\"] = (\n                cls.dft_pulse_wid[cls.tspre] * scn_cfg[\"vel\"]\n            )\n            pc_cfg[\"snaked: multiple files\"][\"pulse_step\"] = round(\n                scn_cfg[\"ang_step\"], 3\n            )\n            pc_cfg[\"snaked: multiple files\"][\"pulse_max\"] = int(\n                round(\n                    abs(scn_cfg[\"ang_e\"] - scn_cfg[\"ang_s\"])\n                    / pc_cfg[\"snaked: multiple files\"][\"pulse_step\"]\n                    + 1\n                )\n            )\n            pc_cfg[\"snaked: multiple files\"][\"gate_width\"] = (\n                abs(scn_cfg[\"ang_e\"] - scn_cfg[\"ang_s\"])\n                + pc_cfg[\"snaked: multiple files\"][\"pulse_step\"]\n            )\n        elif cls.scn_modes[scn_cfg[\"scn_mode\"]] == \"snaked: single file\":\n            pc_cfg[\"snaked: single file\"][\"pulse_start\"] = 0\n            pc_cfg[\"snaked: single file\"][\"pulse_start\"] = 0\n            pc_cfg[\"snaked: single file\"][\"pulse_width\"] = cls.dft_pulse_wid[cls.tspre]\n            pc_cfg[\"snaked: single file\"][\"pulse_step\"] = round(scn_cfg[\"acq_p\"], 4)\n            pc_cfg[\"snaked: single file\"][\"pulse_max\"] = int(\n                int(\n                    round(\n                        abs(scn_cfg[\"ang_e\"] - scn_cfg[\"ang_s\"])\n                        / (scn_cfg[\"acq_p\"] * scn_cfg[\"vel\"])\n                        + 2 * scn_cfg[\"tacc\"] / scn_cfg[\"acq_p\"]\n                    )\n                )\n                * scn_cfg[\"num_swing\"]\n            )\n        else:\n            print(\"Unrecognized scan mode. Quit\")\n            return None\n        pc_cfg[cls.scn_modes[scn_cfg[\"scn_mode\"]]][\"dir\"] = cls.pc_trig_dir[\n            scn_cfg[\"rot_dir\"]\n        ]\n        return pc_cfg\n\n    @staticmethod\n    def compose_scn_cfg(\n        scn_mode, exp_t, acq_p, bin_fac, ang_s, ang_e, vel, tacc, mb_vel, num_swing\n    ):\n        scn_cfg = {}\n        scn_cfg[\"scn_mode\"] = scn_mode\n        scn_cfg[\"exp_t\"] = exp_t\n        scn_cfg[\"acq_p\"] = acq_p\n        scn_cfg[\"bin_fac\"] = 0 if bin_fac is None else bin_fac\n        scn_cfg[\"ang_s\"] = ang_s\n        scn_cfg[\"ang_e\"] = ang_e\n        scn_cfg[\"vel\"] = vel\n        scn_cfg[\"tacc\"] = tacc\n        scn_cfg[\"mb_vel\"] = mb_vel\n        scn_cfg[\"num_swing\"] = num_swing\n        return scn_cfg\n\n    @staticmethod\n    def _prime_det(det):\n        cam_model = _get_cam_model(det)\n        if CAM_RD_CFG[cam_model][\"trigger_mode\"][det.cam.trigger_mode.value] != FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"trigger_mode\"][0]:\n            yield from abs_set(det.cam.trigger_mode, FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"trigger_mode\"][0], wait=True)\n        if CAM_RD_CFG[cam_model][\"image_mode\"][det.cam.image_mode.value] != FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"image_mode\"][1]:\n            yield from abs_set(det.cam.image_mode, FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"image_mode\"][1], wait=True)\n        yield from abs_set(det.cam.num_images, 5, wait=True)\n        yield from abs_set(det.cam.acquire, 1, wait=True)\n        print(f\"{det.name} is primed!\")\n\n    @staticmethod\n    def stop_det(det):\n        yield from abs_set_wait(det.cam.acquire, 0)\n        yield from abs_set_wait(det.hdf5.capture, 0)\n\n    @staticmethod\n    def bin_det(det, bin_fac):\n        cam_model = _get_cam_model(det)\n        if cam_model in [\"MARANA-4BV6X\", \"SONA-4BV6X\"]:\n            yield from FXITomoFlyer.stop_det(det)\n            if bin_fac is None:\n                bin_fac = 0\n            if int(bin_fac) not in FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model]['bin_options']:\n                raise ValueError(f\"binnng must be in {FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model]['bin_options']}\")            \n            try:\n                if det.binning.value != bin_fac:\n                    yield from abs_set(det.binning, bin_fac, wait=True)\n                return bin_fac\n            except Exception:\n                raise\n        elif cam_model in [\"KINETIX22\", \"KINETIX\"]:\n            yield from FXITomoFlyer.stop_det(det)\n            if bin_fac is None:\n                bin_fac = 0\n            if int(bin_fac) not in FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model]['bin_options']:\n                raise ValueError(f\"binnng must be in {FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model]['bin_options']}\")            \n            if bin_fac == 0:\n                binning = 1\n            elif bin_fac == 1:\n                binning = 2\n            elif bin_fac == 2:\n                binning = 4\n            try:\n                if det.cam.bin_x.value != binning:\n                    yield from abs_set(det.cam.bin_x, binning, wait=True)\n                if det.cam.bin_y.value != binning:\n                    yield from abs_set(det.cam.bin_y, binning, wait=True)\n                return bin_fac\n            except Exception:\n                raise\n\n    @staticmethod\n    def prime_det(det):\n        if (det.cam.array_size.array_size_x.value != det.hdf5.array_size.width.value) or (det.cam.array_size.array_size_y.value != det.hdf5.array_size.height.value):\n            yield from FXITomoFlyer._prime_det(det)\n\n    @staticmethod\n    def set_roi_det(det, roi):\n        \"\"\"\n        det.cam.min_x.value\n        det.cam.min_y.value\n        det.cam.size.size_x.value\n        det.cam.size.size_y.value\n        det.cam.max_size.max_size_x.value\n        det.cam.max_size.max_size_y.value\n        \"\"\"\n        if roi is None:\n            yield from abs_set_wait(det.cam.size.size_x, det.cam.max_size.max_size_x.value)\n            yield from abs_set_wait(det.cam.min_x, 0)\n            yield from abs_set_wait(det.cam.size.size_y, det.cam.max_size.max_size_y.value)\n            yield from abs_set_wait(det.cam.min_y, 0)\n        elif (((roi[\"min_x\"] + roi[\"size_x\"]) < det.cam.max_size.max_size_x.value) \n              and ((roi[\"min_y\"] + roi[\"size_y\"]) < det.cam.max_size.max_size_y.value)):\n            yield from abs_set_wait(det.cam.size.size_x, roi[\"size_x\"])\n            yield from abs_set_wait(det.cam.min_x, roi[\"min_x\"])\n            yield from abs_set_wait(det.cam.size.size_y, roi[\"size_y\"])\n            yield from abs_set_wait(det.cam.min_y, roi[\"min_y\"])\n        elif (roi[\"min_x\"] + roi[\"size_x\"]) < det.cam.max_size.max_size_x.value:\n            if (roi[\"min_y\"] + roi[\"size_y\"]) < det.cam.max_size.max_size_y.value:\n                raise ValueError(\"both roi x and y sizes exceed allowed range with given x/y start positions!\")\n            else:\n                raise ValueError(\"roi x size exceeds allowed range with given x start position!\")\n        elif (roi[\"min_y\"] + roi[\"size_y\"]) < det.cam.max_size.max_size_y.value:\n            raise ValueError(\"roi y size exceeds allowed range with given y start position!\")\n\n    @staticmethod\n    def def_abs_out_pos(\n        x_out,\n        y_out,\n        z_out,\n        r_out,\n        rel_out_flag,\n    ):\n        (x_ini, y_ini, z_ini, r_ini) = FXITomoFlyer.get_txm_cur_pos()\n        if rel_out_flag:\n            mot_x_out = x_ini + x_out if not (x_out is None) else x_ini\n            mot_y_out = y_ini + y_out if not (y_out is None) else y_ini\n            mot_z_out = z_ini + z_out if not (z_out is None) else z_ini\n            mot_r_out = r_ini + r_out if not (r_out is None) else r_ini\n        else:\n            mot_x_out = x_out if not (x_out is None) else x_ini\n            mot_y_out = y_out if not (y_out is None) else y_ini\n            mot_z_out = z_out if not (z_out is None) else z_ini\n            mot_r_out = r_out if not (r_out is None) else r_ini\n        return mot_x_out, mot_y_out, mot_z_out, mot_r_out\n\n    @staticmethod\n    def get_txm_cur_pos():\n        x_ini = zps.sx.position\n        y_ini = zps.sy.position\n        z_ini = zps.sz.position\n        r_ini = zps.pi_r.position\n        return x_ini, y_ini, z_ini, r_ini\n\n    @staticmethod\n    def init_mot_r(scn_cfg):\n        cur_pos = zps.pi_r.position\n        yield from abs_set(zps.pi_r.offset_freeze_switch, 1, wait=True)\n        cur_pos = (np.sign((scn_cfg[\"ang_s\"])) * (abs(scn_cfg[\"ang_s\"])//360)) * 360 \\\n            + np.sign(cur_pos) * (abs(cur_pos)%360)    \n        zps.pi_r.set_current_position(cur_pos)\n        yield from abs_set(zps.pi_r.acceleration, 1, wait=True)\n        yield from abs_set(zps.pi_r.velocity, scn_cfg[\"mb_vel\"], wait=True)\n        yield from abs_set(zps.pi_r, scn_cfg[\"ang_s\"], wait=True)\n\n    @staticmethod\n    def set_cam_step_for_scan(det, scn_cfg):\n        yield from abs_set(det.cam.acquire_time, scn_cfg[\"exp_t\"], wait=True)\n        yield from abs_set(det.hdf5.num_capture, scn_cfg[\"num_images\"], wait=True)\n        yield from abs_set(det.cam.num_images, scn_cfg[\"num_images\"], wait=True)\n\n    @staticmethod\n    def set_mot_r_step_for_scan(scn_cfg):\n        yield from abs_set(zps.pi_r.acceleration, scn_cfg[\"tacc\"], wait=True)\n        yield from abs_set(zps.pi_r.velocity, scn_cfg[\"vel\"], wait=True)\n        yield from abs_set(\n            zps.pi_r.user_setpoint,\n            scn_cfg[\"ang_s\"] - scn_cfg[\"rot_dir\"] * scn_cfg[\"taxi_dist\"], \n            wait=True,\n        )\n\n    @staticmethod\n    def set_cam_mode(det, stage=\"pre-scan\"):\n        yield from abs_set_wait(det.cam.acquire, 0)\n        cam_model = _get_cam_model(det)\n        if stage == \"pre-scan\":\n            print(f\"{stage=}\")\n            yield from abs_set_wait(det.cam.image_mode, CAM_RD_CFG[cam_model][\"image_mode\"].index(FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"image_mode\"][1]), timeout=5, settle_time=0.5)\n            yield from abs_set_wait(det.cam.trigger_mode, CAM_RD_CFG[cam_model][\"trigger_mode\"].index(FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"trigger_mode\"][1]), timeout=5, settle_time=0.5)\n        elif stage == \"ref-scan\":\n            print(f\"{stage=}\")\n            yield from abs_set_wait(det.cam.image_mode, CAM_RD_CFG[cam_model][\"image_mode\"].index(FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"image_mode\"][1]), timeout=5, settle_time=0.5)\n            yield from abs_set_wait(det.cam.trigger_mode, CAM_RD_CFG[cam_model][\"trigger_mode\"].index(FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"trigger_mode\"][0]), timeout=5, settle_time=0.5)\n        elif stage == \"post-scan\":\n            print(f\"{stage=}\")\n            yield from abs_set_wait(det.cam.image_mode, CAM_RD_CFG[cam_model][\"image_mode\"].index(FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"image_mode\"][0]), timeout=5, settle_time=0.5)\n            yield from abs_set_wait(det.cam.trigger_mode, CAM_RD_CFG[cam_model][\"trigger_mode\"].index(FXITomoFlyer.CAM_MODES_IN_FLYER[cam_model][\"trigger_mode\"][0]), timeout=5, settle_time=0.5)\n        return"
  },
  {
    "class_name": "Manipulator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/24-sample_envs.py",
    "source": "class Manipulator(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr')\n    y = Cpt(EpicsMotor, 'Y}Mtr')\n    z = Cpt(EpicsMotor, 'Z}Mtr')\n    t = Cpt(EpicsMotor, 'T}Mtr')"
  },
  {
    "class_name": "M1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/10-mirror.py",
    "source": "class M1(Device):\n    x = Cpt(EpicsMotor, '_Trans}Mtr')\n    pit = Cpt(EpicsMotor, '_Pitch}Mtr')\n    rol = Cpt(EpicsMotor, '_Roll}Mtr')"
  },
  {
    "class_name": "M6",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/10-mirror.py",
    "source": "class M6(Device):\n    z = Cpt(EpicsMotor, 'Z}Mtr')\n    pit = Cpt(EpicsMotor, 'Pch}Mtr')"
  },
  {
    "class_name": "MHexapod",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/10-mirror.py",
    "source": "class MHexapod(Device):\n    x = Cpt(EpicsMotor, '_X}Mtr')\n    y = Cpt(EpicsMotor, '_Y}Mtr')\n    z = Cpt(EpicsMotor, '_Z}Mtr')\n    yaw = Cpt(EpicsMotor, '_Rx}Mtr')\n    pit = Cpt(EpicsMotor, '_Ry}Mtr')\n    rol = Cpt(EpicsMotor, '_Rz}Mtr')"
  },
  {
    "class_name": "EHexapod",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/10-mirror.py",
    "source": "class EHexapod(Device):\n    x = Cpt(M5_axis, 'X')\n    y = Cpt(M5_axis, 'Y')\n    z = Cpt(M5_axis, 'Z')\n    yaw = Cpt(M5_axis, 'Yaw')\n    pit = Cpt(M5_axis, 'Pitch')\n    rol = Cpt(M5_axis, 'Roll')"
  },
  {
    "class_name": "PreDefinedPositions",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/81-PreDefinedClass.py",
    "source": "class PreDefinedPositions(Device):\n    '''\n    A class that is used to create a diagnostic unit and/or a single axis mask units. The\n    class has the axis as an attribute as well as a series of pre-defined 'locations'. It also \n    allows motion between these locations via 'paths' defined by the optional keyword dictionary\n    neighbours. If neighbours is not none it will define the shortest path between the current \n    location and the requested location moving only from a location to it's 'neighbours'.\n    \n    Parameters\n    ----------\n    self : numerous paramters\n        All of the parameters associated with the parent class 'Device'\n    locations : dictionary, optional\n        A keyword:Value dictionary that lists all of the predefined locations (keyword) and a \n        list of axis-value pairs to be set in this location in the form: \n        {location1:['axis1_name',value1,axis2_name',value2,...], \n            location2:['axis1_name',value1,axis2_name',value2,...],.....}.\n            NOTE: Not all axes need to have a specifed value for each device location, only \n            those with a specifed value are moved/checked for a given location. \n    neighbours : Dictionary, optional\n        A keyword:value dictionary where each keyword is a location defined in 'locations' and \n        each value is a list of 'neighbours' for that location. When defined motion occurs only \n        between neighbours, for non-neighbours a path through various locations will be used, if \n        it is found using self.find_path. \n    in_band : float or dictionary, optional\n        A float that gives the in-band range for all axes when deciding if the device is 'in' the \n        correct location or not. The default value is 0.1. The optional keyword:value dictionary \n        that lists all of the predefined locations (keyword) and a sub-dictionary that has axis_name\n        keywords and [min_val,max_val] values denoting the range of values for this location and \n        axis. This dictionary has the form: \n\n            {location1:{'axis1_name':[axis1_min_val,axis1_max_val],\n                                                   'axis2_name':[axis2_min_val,axis2_max_val],...}, \n            location2:{'axis1_name':[axis1_min_val,axis1_max_val],\n                                                   'axis2_name':[axis2_min_val,axis2_max_val],...},\n                                          ....}.\n            NOTE: All axes defined with a value in 'locations', for a given location, must have a \n            range in this dictionary for the given location, unless the 'value' in location is a \n            string.\n\n    cam_list : list, optional\n        A list of cameras associated with this device, they will be accesible via the attribute\n        cam or cam1,cam2 etc.\n    qem_list : list, optional\n        A list of qem's associated with this device, they will be accesible via the attribute\n        qem or qem1,qem2 etc.\n    gv_list : list, optional\n        A list of gv's associated with this device, they will be accesible via the attribute\n        gv or gv1,gv2 etc.\n    vis_path_options : dict, optional\n        A dictionary that allows for different path visulatiztion options, the parameters and values\n        are those defined for drawing in the python networkX Module. A set of defaults is used if this \n        parameter is None. May also contain the optional 'axis_labels':['x_label','y_label'] and \n        'fig_size':[x_size,y_size] values.\n\n    NOTES ON PREDEFINED MOTION WITH NEIGHBOURS:\n    1. The locations dictionary can include gate valves and/or parameter sets as axes with the \n        value being 'string'.\n    2. To ensure the motion to a predefined location always occurs when using neighbours to define\n        motion 'paths' it is best to ensure that the device is always in a 'location' by making sure\n        that motion can not move the device outside of all 'locations'.\n    3. Devices can be in more than one location at a time.\n    4. To ensure that motion occurs always via a path then each 'point' in the path should be a \n        location, and it should only have the neighbours that are before or after it in the required\n        path.\n    '''\n    def __init__(self, *args, locations=None, neighbours=None,in_band=0.1, cam_list=None, \n            qem_list=None, gv_list=None, vis_path_options=None,**kwargs):\n        super().__init__(*args, **kwargs)\n\n        self.locations = locations\n        self.in_band = in_band\n        self.neighbours = neighbours\n        self.vis_path_options=vis_path_options\n\n        self.nxGraph=nx.DiGraph(directed=True)\n        \n        if locations is not None: self.nxGraph.add_nodes_from(list(locations.keys()))\n\n        if neighbours is not None:\n            for key in neighbours.keys():\n                for neighbour in neighbours[key]:\n                    self.nxGraph.add_edge(str(key),neighbour)\n        elif locations is not None:\n            for location in locations.keys():\n                for location2 in locations.keys():\n                    if location is not location2:\n                        self.nxGraph.add_edge(str(location),str(location2))\n\n\n        if isinstance(cam_list,list): \n            if len(cam_list)==1:\n                self.cam=cam_list[0]\n            else:\n                for i,cam in enumerate(cam_list):\n                    setattr(self,'cam{}'.format(i+1),cam_list[i])                \n\n        if isinstance(qem_list,list): \n            if len(qem_list)==1:\n                self.qem=qem_list[0]\n            else:\n                for i,qem in enumerate(qem_list):\n                    setattr(self,'qem{}'.format(i+1),qem_list[i])  \n\n        if isinstance(gv_list,list): \n            if len(gv_list)==1:\n                self.gv=gv_list[0]\n            else:\n                for i,gv in enumerate(gv_list):\n                    setattr(self,'qem{}'.format(i+1),gv_list[i])  \n\n\n\n        def mv_axis(to_location):\n            '''\n            A function that moves the diagnostic or single axis slit to the location defined by \n            'value'\n    \n            Parameters\n            ----------\n            to_location: string\n                The name of the location that it is required to move too.\n            '''\n            \n            setattr(self,to_location,mv_axis(to_location))#this resolves an issue with the definition\n                                                          #being set to None after a call \n            \n            path_list = self.find_path(from_location='current_location',to_location=to_location)\n            if path_list == 'unknown location':#if the current location is unknown\n                print ('current location is not pre-defined, move to predefined position first')\n                print ('a list of locations and axis values can be found using the \"locations\"')\n                print ('attribute, e.g. device.locations')\n            else:\n                for location in path_list:\n                    print ('Move {} to \"{}\"'.format(self.name,location))\n                    axis_value_list=self.get_axis_value_list(location)\n                    yield from mv(*axis_value_list)\n                    \n\n        if locations is not None:\n            for location in self.locations:#define the position attributes\n                setattr(self,location,mv_axis(location))\n\n        \n        \n    def read(self):\n        '''\n        An attribute that returns the current 'location' of the unit as an ordered dictionary. This\n        is used identically to the read attribute function for a standard device and therefore can \n        be used in the baseline.\n        \n        Parameters\n        ----------\n        read_dict: ordered dictionary, ouput\n            The output dictionary that matches the standard output for a Device.\n        '''\n\n        out_dict = collections.OrderedDict()\n        out_dict[self.name+'_location'] = {'timestamp':time.time(),'value':self.status }\n\n        read_dict = super().read()\n        read_dict.update(out_dict)\n        \n        return read_dict\n\n    \n    \n    def describe(self):\n        '''\n        An attribute that returns the current 'location'description of the output data as an \n        ordered dictionary. This is used identically to the describe attribute function for a \n        standard device and therefore can be used in the baseline.\n        \n        Parameters\n        ----------\n        describe_dict: ordered dictionary, ouput\n            The output dictionary that matches the standard output for a Device.\n        '''\n\n        out_dict = collections.OrderedDict()\n        out_dict[self.name+'_location'] = {'dtype': 'string',\n               'lower_ctrl_limit': None,\n               'precision': None,\n               'shape': [],\n               'source': 'None',\n               'units': None,\n               'upper_ctrl_limit': None}\n              \n        describe_dict = super().describe()\n        describe_dict.update(out_dict)\n        \n        return describe_dict\n\n\n\n    def get_axis_value_list(self,location):\n        '''\n        Returns the axis-value list for a defined location\n        \n        Returns\n        -------\n        axis_value_list : list, output\n            the axis-value list for the inputted location that is returned\n        '''\n        axis_value_list=[]\n        for item in self.locations[location]:\n                if isinstance(item,str):\n                    axis_value_list.append(getattr(self,item))\n                else:\n                    axis_value_list.append(item)\n                    \n        return axis_value_list\n        \n\n    def find_path(self,from_location=None,to_location=None):\n        '''\n        Find the shortest path from the 'from_location' to 'to_location' passing only thorugh the \n        neighbours for each location defiend by the dictionary 'neighbours'. Returns an empty list \n        if no path found otherwise returns a list of 'locations' that define the path. If to_location \n        is None then it returns a dictionary showing the shortest path to all possible locations. If\n        from_location is None it returns a dictionary showing the shortest path from all locations to\n        the current location. If both are None it returns a dictioanry of dictionaries. If \n        from_location is 'current_location' the starting point is changed to the current location.\n\n        Parameters\n        ---------\n        from_location: string\n            The name of the starting location required for the path.\n\n        to_location: string\n            The name of the ending location required for the path.\n\n        path_list: list, output\n            A list locations indicating the path to take to reach the required position.\n\n        '''\n\n\n        if (from_location != 'current_location'):\n            path_list = nx.shortest_path(self.nxGraph,source=from_location,target=to_location)\n        elif isinstance(self.status_list,str) and self.neighbours is not None:\n            path_list=(self.status_list)\n        else:\n            if self.neighbours is None:\n                path_list=[to_location]\n            else:\n                path_list=[]\n                for location in self.status_list:\n                    prev_path_list=path_list\n                    path_list=nx.shortest_path(self.nxGraph,source=location,target=to_location)\n\n                    if len(prev_path_list)>1 and len(prev_path_len)<len(path_list):\n                        path_list=prev_path_list\n\n        return path_list\n\n    @property\n    def visualize_paths(self):\n        ''' Creates a plot of the possible paths between the predefined locations.\n\n        '''\n        if self.locations is None:\n            print ('No locations to visualize')\n        else:\n            \n            options={'pos':nx.circular_layout(self.nxGraph),'node_color':'darkturquoise','edge_color':'grey','node_size':6000,\n                     'width':3,'arrowstyle':'-|>','arrow_size':12}\n            if self.vis_path_options is not None:\n                options.update(self.vis_path_options)\n\n            if 'fig_size' in options.keys():\n                fig_size=[options['fig_size'][0],options['fig_size'][1]]\n                del options['fig_size']\n            else:\n                fig_size=[10,10]\n\n            if 'axis_labels' in options.keys():\n                axis_labels=[options['axis_labels'][0],options['axis_labels'][1]]\n                del options['axis_labels']\n            else:\n                axis_labels=['arbitrary axis','arbitrary axis']\n\n\n            plt.figure('visualize {} paths'.format(self.name),figsize=(fig_size[0],fig_size[1]))\n            plt.xlabel(axis_labels[0])\n            plt.ylabel(axis_labels[1])\n            nx.draw_networkx(self.nxGraph,arrows=True,**options)\n\n\n\n    @property\n    def status_list(self):\n        '''The current location of the device\n        \n        Returns\n        -------\n        position : list\n        '''\n   \n        if self.locations is not None:\n            loc_list='unknown location'\n            for location in self.locations:\n                in_position=True\n                for i in range(0,len(self.locations[location]),2):\n                    axis = self.locations[location][i]\n                    value = self.locations[location][i+1]\n\n                    if hasattr(getattr(self,axis),'position'):\n                        if isinstance(self.in_band, float):\n                            if getattr(self,axis).position < value - self.in_band or \\\n                                getattr(self,axis).position > value + self.in_band:\n                                in_position=False\n                        else:\n                            if getattr(self,axis).position < self.in_band[location][axis][0] or \\\n                                getattr(self,axis).position > self.in_band[location][axis][1] :\n                                in_position=False\n\n                    elif hasattr(getattr(self,axis),'get'):\n                        if isinstance(self.in_band, float):\n                            if getattr(self,axis).get() < value - self.in_band or \\\n                                getattr(self,axis).get() > value + self.in_band:\n                                in_position=False\n                        else:\n                            if getattr(self,axis).get() < self.in_band[location][axis][0] or \\\n                                getattr(self,axis).get() > self.in_band[location][axis][1] :\n                                in_position=False\n\n                    elif hasattr(getattr(self,axis),'status'):\n                        if getattr(self,axis).status is not value:\n                            in_position=False\n\n                if in_position: \n                    if loc_list == 'unknown location':\n                        loc_list = [location]\n                    else:\n                        loc_list.append(location)\n        else:\n            loc_list=['no locations']\n\n        return loc_list\n   \n    @property  \n    def status(self):\n        '''The current location of the device\n        \n        Returns\n        -------\n        position : string\n        '''\n\n        if isinstance(self.status_list,list):\n            position=''\n            for location in self.status_list:\n                if len(position)>1:\n                    position+=' , '\n\n                position+= location\n        else:\n            position = self.status_list\n\n        return position"
  },
  {
    "class_name": "PGMjoe",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/84-pgm.py",
    "source": "class PGMjoe(Device):\n    # cff = Cpt(EpicsMotor, '_Cff}Mtr')\n    # en = Cpt(EpicsMotor, '_Eng}Mtr')\n    grx = Cpt(EpicsMotor, '_GT}Trans:Mtr')\n    m2pit = Cpt(EpicsMotor, '_MP}Mtr')\n    grpit = Cpt(EpicsMotor, '_GP}Mtr')\n\n    gr500 = Cpt(EpicsSignalRO, '_GT}Trans:GT1Inp')\n    gr1200 = Cpt(EpicsSignalRO, '_GT}Trans:GT2Inp')\n    gr1800 = Cpt(EpicsSignalRO, '_GT}Trans:GT3Inp')"
  },
  {
    "class_name": "PGM_ES",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/84-pgm.py",
    "source": "class PGM_ES(Device):\n    cff = Cpt(EpicsMotor, 'cff}Mtr')\n    en = Cpt(EpicsMotor, 'E}Mtr')\n    #grx = Cpt(EpicsMotor, 'GXRaw}Mtr') #Commented on  12/15/2020 because it doesn't work with BS\n    grx = Cpt(EpicsMotor, 'GX}Mtr')\n    m7pit = Cpt(EpicsMotor, 'MP}Mtr')\n    grpit = Cpt(EpicsMotor, 'GP}Mtr')\n    grxrb = Cpt(EpicsSignalRO,'GXEnc}Mtr.RBV')"
  },
  {
    "class_name": "DIAGON",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/20-diagon.py",
    "source": "class DIAGON(Device):\n    hml = Cpt(EpicsMotor, '_HLPM}Mtr')\n    hyag = Cpt(EpicsMotor, '_HLPF}Mtr')\n    vml = Cpt(EpicsMotor, '_VLPM}Mtr')\n    vyag = Cpt(EpicsMotor, '_VLPF}Mtr')"
  },
  {
    "class_name": "DeadbandMixin",
    "bases": [
      "Device",
      "PositionerBase"
    ],
    "file": "profile-collections/six-profile-collection/startup/04-epu.py",
    "source": "class DeadbandMixin(Device, PositionerBase):\n    \"\"\"\n    Borrowed with gratitude from SST.\n    # TODO:  Add to nslsii package after testing and refactor.\n\n\n    Should be the leftmost class in the inheritance list so that it grabs move first!\n\n    Must be combined with either EpicsMotor or PVPositioner, or some other class\n    that has a done_value attribute\n\n    An EpicsMotor subclass that has an absolute tolerance for moves.\n    If the readback is within tolerance of the setpoint, the MoveStatus\n    is marked as finished, even if the motor is still settling.\n\n    This prevents motors with long, but irrelevant, settling times from\n    adding overhead to scans.\n    \"\"\"\n    tolerance = Cpt(Signal, value=-1, kind='config')\n    move_latch = Cpt(Signal, value=0, kind=\"omitted\")\n\n    def _done_moving(self, success=True, timestamp=None, value=None, **kwargs):\n        '''Call when motion has completed.  Runs ``SUB_DONE`` subscription.'''\n        if self.move_latch.get():\n            if success:\n                self._run_subs(sub_type=self.SUB_DONE, timestamp=timestamp,\n                               value=value)\n\n            self._run_subs(sub_type=self._SUB_REQ_DONE, success=success,\n                           timestamp=timestamp)\n            self._reset_sub(self._SUB_REQ_DONE)\n            self.move_latch.put(0)\n\n    def move(self, position, wait=True, **kwargs):\n        tolerance = self.tolerance.get()\n\n        if tolerance < 0:\n            self.move_latch.put(1)\n            return super().move(position, wait=wait, **kwargs)\n        else:\n            status = super().move(position, wait=False, **kwargs)\n            setpoint = position\n            done_value = getattr(self, \"done_value\", 1)\n\n            def check_deadband(value, timestamp, **kwargs):\n                if abs(value - setpoint) < tolerance:\n                    self._done_moving(timestamp=timestamp,\n                                      success=True,\n                                      value=done_value)\n\n            def clear_deadband(*args, timestamp, **kwargs):\n                self.clear_sub(check_deadband, event_type=self.SUB_READBACK)\n\n            self.subscribe(clear_deadband, event_type=self._SUB_REQ_DONE, run=False)\n            self.move_latch.put(1)\n            self.subscribe(check_deadband, event_type=self.SUB_READBACK, run=True)\n\n            try:\n                if wait:\n                    ophyd.status.wait(status)\n            except KeyboardInterrupt:\n                self.stop()\n                raise\n\n            return status"
  },
  {
    "class_name": "EPU",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/04-epu.py",
    "source": "class EPU(Device):\n    gap = Cpt(UgapPositioner, 'SR:C02-ID:G1A{EPU:1', settle_time=0)   #works without added table and offset & def below\n    phase = Cpt(UphasePositioner, 'SR:C02-ID:G1A{EPU:1', settle_time=0) #works without added table and offset\n    #gap = Cpt(UgapPositioner,'{self._epu_prefix}', settle_time=0)\n    #phase = Cpt(UphasePositioner,'self._epu_prefix', settle_time=0)\n    table = FmCpt(EpicsSignal,'{self._ai_prefix}Val:Table-Sel') # TODO add reference to PV string for meaning\n    offset = FmCpt(EpicsSignal,'{self._ai2_prefix}Val:InpOff1-SP', name = 'epu1_offset') #calibration offset \n    def __init__(self, *args, ai_prefix=None,  ai2_prefix='None', **kwargs): #,epu_prefix=None\n        #self._epu_prefix = epu_prefix\n        self._ai_prefix = ai_prefix\n        self._ai2_prefix = ai2_prefix\n        \n        super().__init__(*args, **kwargs)"
  },
  {
    "class_name": "BaffleSlitBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/12-slits.py",
    "source": "class BaffleSlitBase(Device):\n    hg = Cpt(EpicsMotor, '-Ax:HG}Mtr')\n    hc = Cpt(EpicsMotor, '-Ax:HC}Mtr')\n    vg = Cpt(EpicsMotor, '-Ax:VG}Mtr')\n    vc = Cpt(EpicsMotor, '-Ax:VC}Mtr')"
  },
  {
    "class_name": "VirtualMotorCenterAndGap",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/12-slits.py",
    "source": "class VirtualMotorCenterAndGap(Device):\n    \"Center and gap with virtual motors\"\n    hc = Cpt(VirtualCenter, '-Ax:X}')\n    vc = Cpt(VirtualCenter, '-Ax:Y}')\n    hg = Cpt(VirtualGap, '-Ax:X}')\n    vg = Cpt(VirtualGap, '-Ax:Y}')"
  },
  {
    "class_name": "ExitSlit",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/12-slits.py",
    "source": "class ExitSlit(Device):\n    hg = Cpt(EpicsMotor, '_HG}Mtr')\n    vg = Cpt(EpicsMotor, '_VG}Mtr')\n    hc = Cpt(EpicsMotor, '_HT}Mtr')"
  },
  {
    "class_name": "Lakeshore336Channel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/25-temp_control.py",
    "source": "class Lakeshore336Channel(Device):\n    T = Cpt(EpicsSignalRO, 'T-I')\n    V = Cpt(EpicsSignalRO, 'Val:Sens-I')\n    status = Cpt(EpicsSignalRO, 'T-Sts')"
  },
  {
    "class_name": "Lakeshore336",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/25-temp_control.py",
    "source": "class Lakeshore336(Device):\n    temp = DDC(_temp_fields(['A','B']))#,'C','D']))\n    ctrl1 = Cpt(Lakeshore336Setpoint, '-Out:1}')\n    ctrl2 = Cpt(Lakeshore336Setpoint, '-Out:2}')"
  },
  {
    "class_name": "Lakeshore336Picky",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/25-temp_control.py",
    "source": "class Lakeshore336Picky(Device):\n    setpoint = Cpt(EpicsSignal, read_pv='-Out:1}T-RB', write_pv='-Out:1}T-SP',\n                   add_prefix=('read_pv', 'write_pv'))\n    # TODO expose ramp rate\n    ramp_done = Cpt(EpicsSignalRO, '-Out:1}Sts:Ramp-Sts')\n    ramp_enabled = Cpt(EpicsSignal, '-Out:1}Enbl:Ramp-Sel')\n    ramp_rate = Cpt(EpicsSignal, read_pv='-Out:1}Val:Ramp-RB',\n                    write_pv='-Out:1}Val:Ramp-SP',\n                    add_prefix=('read_pv', 'write_pv'))\n\n    chanA = Cpt(Lakeshore336Channel, '-Chan:A}')\n    chanB = Cpt(Lakeshore336Channel, '-Chan:B}')\n\n    def __init__(self, *args, timeout=60*60*30, target='chanA', **kwargs):\n        # do the base stuff\n        super().__init__(*args, **kwargs)\n        # status object for communication\n        self._done_sts = None\n\n        # state for deciding if we are done or not\n        self._cache = deque()\n        self._start_time = 0\n        self._setpoint = None\n        self._count = -1\n\n        # longest we can wait before giving up\n        self._timeout = timeout\n        self._lagtime = 120\n\n        # the channel to watch to see if we are done\n        self._target_channel = target\n\n        # parameters for done testing\n        self.mean_thresh = .01\n        self.ptp_thresh = .1\n\n    def _value_cb(self, value, timestamp, **kwargs):\n        self._cache.append((value, timestamp))\n\n        if (timestamp - self._cache[0][1]) < self._lagtime / 2:\n            return\n\n        while (timestamp - self._cache[0][1]) > self._lagtime:\n            self._cache.popleft()\n\n        buff = np.array([v[0] for v in self._cache])\n        if self._done_test(self._setpoint, buff):\n            self._done_sts._finished()\n            self._reset()\n\n    def _setpoint_cb(value, **kwargs):\n        print('in cb', value)\n        if value == self._setpoint:\n            self._done_sts._finished()\n            self.setpoint.clear_sub(self._setpoint_cb, 'value')\n\n    def _reset(self):\n        if self._target_channel == 'setpoint':\n            target = self.setpoint\n            target.clear_sub(self._setpoint_cb, 'value')\n        else:\n            target = getattr(self, self._target_channel).T\n            target.clear_sub(self._value_cb, 'value')\n        self._done_sts = None\n        self._setpoint = None\n        self._cache.clear()\n\n    def _done_test(self, target, buff):\n        mn = np.mean(np.abs(buff - target))\n\n        if mn > self.mean_thresh:\n            return False\n\n        if np.ptp(buff) > self.ptp_thresh:\n            return False\n\n        return True\n\n\n    def set(self, new_position, *, timeout=None):\n        # to be subscribed to 'value' cb on readback\n        sts = self._done_sts = DeviceStatus(self, timeout=timeout)\n        if self.setpoint.get() == new_position:\n            self._done_sts._finished()\n            self._done_sts = None\n            return sts\n\n        self._setpoint = new_position\n\n        self.setpoint.set(self._setpoint)\n\n        # todo, set up subscription forwarding\n        if self._target_channel == 'setpoint':\n            self.setpoint.subscribe(local_cb, 'value')\n        else:\n            target = getattr(self, self._target_channel).T\n            target.subscribe(self._value_cb, 'value')\n\n        return self._done_sts"
  },
  {
    "class_name": "SCdevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/13-chamber.py",
    "source": "class SCdevice(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr')\n    z = Cpt(EpicsMotor, 'Z}Mtr')"
  },
  {
    "class_name": "Brdevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/13-chamber.py",
    "source": "class Brdevice(Device): \n    yin = Cpt(EpicsMotor, 'YUI}Mtr')\n    you = Cpt(EpicsMotor, 'YUO}Mtr')\n    ydn = Cpt(EpicsMotor, 'YD}Mtr')\n    pit = Cpt(EpicsMotor, 'Pch}Mtr')\n    roll = Cpt(EpicsMotor, 'Roll}Mtr')\n    y = Cpt(EpicsMotor, 'Y}Mtr')"
  },
  {
    "class_name": "OCdevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/13-chamber.py",
    "source": "class OCdevice(Device):\n    y = Cpt(EpicsMotor, 'Y}Mtr')\n    z = Cpt(EpicsMotor, 'Z}Mtr')\n    roll  = Cpt(EpicsMotor, 'Roll}Mtr')\n    twoth = Cpt(EpicsMotor, '2T}Mtr')\n    wlin = Cpt(EpicsMotor, 'YI}Mtr')\n    wlot = Cpt(EpicsMotor, 'YO}Mtr')"
  },
  {
    "class_name": "DCdevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/13-chamber.py",
    "source": "class DCdevice(Device):\n    z = Cpt(EpicsMotor, 'Z}Mtr')\n    twoth = Cpt(EpicsMotor, '2T}Mtr')"
  },
  {
    "class_name": "TriggeredCamExposure",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/six-profile-collection/startup/22-rixscam.py",
    "source": "class TriggeredCamExposure(Device):\n    '''A class designed for the setting of the detector exposure parameters\n    (acquire_time, acquire_period and num_images) at once.\n\n    This class is used to provide an attribute for setting the exposure\n    parameters in a single command. It sets the aqcuire_time (and at the same\n    time the delay generator parameters) the acquire_period and the num_images.\n    These are set via the child 'set' attribute.\n    '''\n\n    def __init__(self, *args, **kwargs):\n        self._Tc = 0.004\n        self._To = 0.0035\n        self._readout = 0.080\n        super().__init__(*args, **kwargs)\n\n    def set(self, exp):\n        '''Used for the setting of the detector exposure parameters\n        (acquire_time, acquire_period and num_images) and the delay\n        generator parameters.\n\n        This function is used to provide an attribute for setting the exposure\n        parameters in a single command. It sets the aqcuire_time (and at the\n        same time the delay generator parameters) the acquire_period and the\n        num_images.\n\n        PARAMETERS\n        ----------\n        exp: tuple.\n        A tuple with the structure (aqcuire_time, acquire_period, num_images).\n        '''\n\n        # Exposure time = 0\n        # Cycle time = 1\n\n        if exp[0] is not None:\n            Efccd = exp[0] + self._Tc + self._To\n            # To = start of FastCCD Exposure\n            aa = 0                          # Shutter open\n            bb = Efccd - self._Tc + aa      # Shutter close\n            cc = self._To * 3               # diag6 gate start\n            dd = exp[0] - (self._Tc * 2)    # diag6 gate stop\n            ee = 0                          # Channel Adv Start\n            ff = 0.001                      # Channel Adv Stop\n            gg = self._To                   # MCS Count Gate Start\n            hh = exp[0] + self._To          # MCS Count Gate Stop\n\n            # Set delay generator\n            self.parent.dg1.A.set(aa)\n            self.parent.dg1.B.set(bb)\n            self.parent.dg1.C.set(cc)\n            self.parent.dg1.D.set(dd)\n            self.parent.dg1.E.set(ee)\n            self.parent.dg1.F.set(ff)\n            self.parent.dg1.G.set(gg)\n            self.parent.dg1.H.set(hh)\n\n            # Set AreaDetector\n            self.parent.cam.acquire_time.set(Efccd)\n\n        # Now do period\n        if exp[1] is not None:\n            if exp[1] < (Efccd + self._readout):\n                p = Efccd + self._readout\n            else:\n                p = exp[1]\n\n        self.parent.cam.acquire_period.set(p)\n\n        if exp[2] is not None:\n            self.parent.cam.num_images.set(exp[2])\n\n        return NullStatus()\n\n    def get(self):\n        return None"
  },
  {
    "class_name": "Tpx3Files",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/optional_startup/9999-tpx3.py",
    "source": "class Tpx3Files(Device):\n    # The other PVs only take affect after this is set\n    set_settings = Cpt(EpicsSignal, \"WriteData\", kind=\"omitted\")\n\n    raw_filepath = Cpt(\n        EpicsPathSignal,\n        \"RawFilePath\",\n        string=True,\n        kind=\"config\",\n        path_semantics=\"posix\",\n    )\n    raw_file_template = Cpt(\n        EpicsSignalWithRBV, \"RawFileTemplate\", string=True, kind=\"config\"\n    )\n    raw_write_enable = Cpt(EpicsSignalWithRBV, \"WriteRaw\", string=True, kind=\"omitted\")\n\n    img_filepath = Cpt(EpicsSignalWithRBV, \"ImgFilePath\", kind=\"config\")\n    img_file_template = Cpt(EpicsSignalWithRBV, \"ImgFileTemplate\", kind=\"config\")\n    img_write_enable = Cpt(EpicsSignalWithRBV, \"WriteImg\", kind=\"omitted\")\n\n    prv_filepath = Cpt(EpicsSignal, \"PrvImgFilePath\", kind=\"config\")\n    prv_file_template = Cpt(EpicsSignal, \"PrvImgFileTemplate\", kind=\"config\")\n\n    prv1_filepath = Cpt(EpicsSignal, \"PrvImg1FilePath\", kind=\"config\")\n\n    # HACK UNTIL WE GET HANDLERS SET UP\n    raw_filepaths = Cpt(PreciseDtypeSignal, kind=\"normal\")\n\n    def __init__(self, *args, **kwargs):\n        self.sequence_id_offset = 1\n        # This is changed for when a datum is a slice\n        # also used by ophyd\n        self.filestore_spec = \"TPX3_RAW\"\n        self.frame_num = None\n        super().__init__(*args, **kwargs)\n        self._datum_kwargs_map = dict()  # store kwargs for each uid\n        self._n = 0\n\n        self.stage_sigs['img_write_enable'] = 'false'\n\n    def stage(self):\n        # TODO also do the images\n\n        self._res_uid = res_uid = new_short_uid()\n        write_path_template = 'file:/nsls2/data/chx/legacy/data/%Y/%m/%d/'\n        self._write_path = write_path = datetime.now().strftime(write_path_template)\n        self.raw_filepath.set(write_path).wait()\n\n        # TODO check what the % formatting means to the server\n        self.raw_file_template.set(f\"{res_uid}_0\").wait()\n\n        # because we need to flush setting to actual server from IOC\n        self.raw_write_enable.set(1).wait()\n        self.set_settings.set(1).wait()\n\n        # fill in first guess, this ill increment self._n but we really do not want to!\n        self.update_file_template()\n        # reset this back to 0!  \n        self._n = 0\n\n        super().stage()\n\n    def update_file_template(self):\n        # The server generates files with in a trigger that are formatted as\n        # filepath/template{datetime only}_{j:d6}.tpx3\n        # however the counting is only within the trigger and because we want to be able to predict the file names we can not\n        # rely on the date formatting, this we need to set this template on every trigger\n\n        \n        # TODO check what the % formatting means to the server\n        self.raw_file_template.set(f\"{self._res_uid}_{self._n:05d}_\").wait()\n        # because we need to flush setting to actual server from IOC\n        self.set_settings.set(1).wait()\n\n        filenames = [f'{self._write_path}{self._res_uid}_{self._n:05d}_{j:06d}.tpx3' for j in range(self.parent.cam.num_images.get())]\n        self._n += 1\n        self.raw_filepaths.set(filenames).wait()\n\n    def unstage(self) -> List[object]:\n        # TODO reset these to their original values rather than junk\n        self.raw_filepath.set('file:/media/nvme/raw/').wait()\n        self.raw_file_template.set(f\"garbage\").wait()\n        self.raw_write_enable.set(0).wait()\n\n        # because we need to flush setting to actual server from IOC\n        self.set_settings.set(1).wait()\n        return super().unstage()"
  },
  {
    "class_name": "Printer_3D",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/optional_startup/30-SAXS_WAXS.py",
    "source": "class Printer_3D(Device):\n    \"4 axes for the 3D printer\"\n    x_bed = Cpt(EpicsMotor,'Bed:X}Mtr')\n    z_bed = Cpt(EpicsMotor,'Bed:Z}Mtr')\n    x_head = Cpt(EpicsMotor,'Head:X}Mtr')\n    y_head = Cpt(EpicsMotor,'Head:Y}Mtr')"
  },
  {
    "class_name": "EigerSimulatedFilePlugin",
    "bases": [
      "Device",
      "FileStoreBase"
    ],
    "file": "profile-collections/chx-profile-collection/startup/20-area-detectors.py",
    "source": "class EigerSimulatedFilePlugin(Device, FileStoreBase):\n    sequence_id = ADComponent(EpicsSignalRO, 'SequenceId')\n    file_path = ADComponent(EpicsSignalWithRBV, 'FilePath', string=True)\n    file_write_name_pattern = ADComponent(EpicsSignalWithRBV, 'FWNamePattern',\n                                          string=True)\n    file_write_images_per_file = ADComponent(EpicsSignalWithRBV,\n                                             'FWNImagesPerFile')\n    current_run_start_uid = Cpt(Signal, value='', add_prefix=())\n    enable = SimpleNamespace(get=lambda: True)\n\n    def __init__(self, *args, **kwargs):\n        self.sequence_id_offset = 1\n        # This is changed for when a datum is a slice\n        # also used by ophyd\n        self.filestore_spec = \"AD_EIGER2\"\n        self.frame_num = None\n        super().__init__(*args, **kwargs)\n        self._datum_kwargs_map = dict()  # store kwargs for each uid\n\n    def stage(self):\n        res_uid = new_short_uid()\n        write_path = datetime.now().strftime(self.write_path_template)\n        #set_and_wait(self.file_path, write_path + '/')\n        self.file_path.set(write_path + '/').wait()\n        #set_and_wait(self.file_write_name_pattern, '{}_$id'.format(res_uid))\n        self.file_write_name_pattern.set('{}_$id'.format(res_uid)).wait()\n        super().stage()\n        fn = (PurePath(self.file_path.get()) / res_uid)\n        ipf = int(self.file_write_images_per_file.get())\n        # logger.debug(\"Inserting resource with filename %s\", fn)\n        self._fn = fn\n        res_kwargs = {'images_per_file' : ipf}\n        self._generate_resource(res_kwargs)\n\n    def generate_datum(self, key, timestamp, datum_kwargs):\n        # The detector keeps its own counter which is uses label HDF5\n        # sub-files.  We access that counter via the sequence_id\n        # signal and stash it in the datum.\n        seq_id = int(self.sequence_id_offset) + int(self.sequence_id.get())  # det writes to the NEXT one\n        datum_kwargs.update({'seq_id': seq_id})\n        if self.frame_num is not None:\n            datum_kwargs.update({'frame_num': self.frame_num})\n        return super().generate_datum(key, timestamp, datum_kwargs)\n\n    def describe(self,):\n        ret = super().describe()\n        if hasattr(self.parent.cam, 'bit_depth'):\n            cur_bits = self.parent.cam.bit_depth.get()\n            dtype_str_map = {8: '|u1', 16: '<u2', 32:'<u4'}\n            ret[self.parent._image_name]['dtype_str'] = dtype_str_map[cur_bits]\n        return ret"
  },
  {
    "class_name": "FastShutterTrigger",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/20-area-detectors.py",
    "source": "class FastShutterTrigger(Device):\n    \"\"\"This represents the fast trigger *device*.\n\n    See below, FastTriggerMixin, which defines the trigging logic.\n    \"\"\"\n    auto_shutter_mode = Cpt(EpicsSignal, 'Mode-Sts', write_pv='Mode-Cmd')\n    num_images = Cpt(EpicsSignal, 'NumImages-SP')\n    exposure_time = Cpt(EpicsSignal, 'ExposureTime-SP')\n    acquire_period = Cpt(EpicsSignal, 'AcquirePeriod-SP')\n    acquire = Cpt(EpicsSignal, 'Acquire-Cmd', trigger_value=1)"
  },
  {
    "class_name": "LinkamThermal",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/51_Linkam.py",
    "source": "class LinkamThermal(Device):\n    # Set-and-read signals\n    cmd = Cpt(EpicsSignal, \"STARTHEAT\")\n    temperature_setpoint = Cpt(EpicsSignal, \"SETPOINT:SET\")\n    temperature_rate_setpoint = Cpt(EpicsSignal, \"RAMPRATE:SET\")\n\n    # Read-Only signals\n    status_power = Cpt(EpicsSignalRO, \"STARTHEAT\")\n    status_code = Cpt(EpicsSignalRO, \"STATUS\")\n    # status_code = Cpt(EpicsSignal, 'STATUS')\n    # done = Cpt(AtSetpoint, parent_attr = 'status_code')\n    temperature_current = Cpt(EpicsSignalRO, \"TEMP\")\n    temperature_rate_current = Cpt(EpicsSignalRO, \"RAMPRATE\")\n\n    # not commonly used\n    init = Cpt(EpicsSignal, \"INIT\")\n    model_array = Cpt(EpicsSignal, \"MODEL\")\n    serial_array = Cpt(EpicsSignal, \"SERIAL\")\n    stage_model_array = Cpt(EpicsSignal, \"STAGE:MODEL\")\n    stage_serial_array = Cpt(EpicsSignal, \"STAGE:SERIAL\")\n    firm_ver = Cpt(EpicsSignal, \"FIRM:VER\")\n    hard_ver = Cpt(EpicsSignal, \"HARD:VER\")\n    ctrllr_err = Cpt(EpicsSignal, \"CTRLLR:ERR\")\n    config = Cpt(EpicsSignal, \"CONFIG\")\n    stage_config = Cpt(EpicsSignal, \"STAGE:CONFIG\")\n    disable = Cpt(EpicsSignal, \"DISABLE\")\n    dsc = Cpt(EpicsSignal, \"DSC\")\n    # RR_set = Cpt(EpicsSignal, 'RAMPRATE:SET')\n    # RR = Cpt(EpicsSignal, 'RAMPRATE')\n    ramptime = Cpt(EpicsSignal, \"RAMPTIME\")\n    # startheat = Cpt(EpicsSignal, 'STARTHEAT')\n    holdtime_set = Cpt(EpicsSignal, \"HOLDTIME:SET\")\n    holdtime = Cpt(EpicsSignal, \"HOLDTIME\")\n    power = Cpt(EpicsSignalRO, \"POWER\")\n    lnp_speed = Cpt(EpicsSignal, \"LNP_SPEED\")\n    lnp_mode_set = Cpt(EpicsSignal, \"LNP_MODE:SET\")\n    lnp_speed_set = Cpt(EpicsSignal, \"LNP_SPEED:SET\")\n\n    def on(self):\n        return self.cmd.put(1)\n\n    def _on(self):\n        yield from bps.mv(self.cmd, 1)\n\n    def off(self):\n        return self.cmd.put(0)\n\n    def _off(self):\n        yield from bps.mv(self.cmd, 0)\n\n    def setTemperature(self, temperature):\n        return self.temperature_setpoint.put(temperature)\n\n    def setTemperatureRate(self, temperature_rate):\n        return self.temperature_rate_setpoint.put(temperature_rate)\n\n    def temperature(self):\n        return self.temperature_current.get()\n\n    def temperatureRate(self):\n        return self.temperature_rate_current.get()\n\n    @property\n    def serial(self):\n        return self.arr2word(self.serial_array.get())\n\n    @property\n    def model(self):\n        return self.arr2word(self.model_array.get())\n\n    @property\n    def stage_model(self):\n        return self.arr2word(self.stage_model_array.get())\n\n    @property\n    def stage_serial(self):\n        return self.arr2word(self.stage_serial_array.get())\n\n    @property\n    def firmware_version(self):\n        return self.arr2word(self.firm_ver.get())\n\n    @property\n    def hardware_version(self):\n        return self.arr2word(self.hard_ver.get())\n\n    def status(self):\n        text = f\"\\nCurrent temperature = {self.temperature():.1f}, setpoint = {self.temperature_setpoint.get():.1f}\\n\\n\"\n        code = int(self.status_code.get())\n\n        if code & 1:  # Error\n            text += \"Error        : yes\" + \"\\n\"\n        else:\n            text += \"Error        : no\\n\"\n        if code & 2:  # at setpoint\n            text += \"At setpoint  : yes\" + \"\\n\"\n        else:\n            text += \"At setpoint  : no\\n\"\n        if code & 4:  # heater\n            text += \"Heater       : on\" + \"\\n\"\n        else:\n            text += \"Heater       : off\\n\"\n        if code & 8:  # pump\n            text += \"Pump         : on\" + \"\\n\"\n        else:\n            text += \"Pump         : off\\n\"\n        if code & 16:  # pump auto\n            text += \"Pump Auto    : yes\" + \"\\n\"\n        else:\n            text += \"Pump Auto    : no\\n\"\n\n        print(text)"
  },
  {
    "class_name": "MotorCenterAndGap",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class MotorCenterAndGap(Device):\n    \"Center and gap using Epics Motor records\"\n    xc = Cpt(EpicsMotor, '-Ax:XCtr}Mtr')\n    yc = Cpt(EpicsMotor, '-Ax:YCtr}Mtr')\n    xg = Cpt(EpicsMotor, '-Ax:XGap}Mtr')\n    yg = Cpt(EpicsMotor, '-Ax:YGap}Mtr')\n\n    @property\n    def hints(self):\n        fields = []\n        for name in self.component_names:\n            motor = getattr(self, name)\n            fields.extend(motor.hints['fields'])\n        return {'fields': fields}"
  },
  {
    "class_name": "VirtualMotorCenterAndGap",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class VirtualMotorCenterAndGap(Device):\n    \"Center and gap with virtual motors\"\n    xc = Cpt(VirtualCenter, '-Ax:X}')\n    yc = Cpt(VirtualCenter, '-Ax:Y}')\n    xg = Cpt(VirtualGap, '-Ax:X}')\n    yg = Cpt(VirtualGap, '-Ax:Y}')\n    @property\n    def hints(self):\n        fields = []\n        for name in self.component_names:\n            motor = getattr(self, name)\n            fields.extend(motor.hints['fields'])\n        return {'fields': fields}"
  },
  {
    "class_name": "Blades",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class Blades(Device):\n    top = Cpt(EpicsMotor, '-Ax:T}Mtr')\n    bottom = Cpt(EpicsMotor, '-Ax:B}Mtr')\n    outboard = Cpt(EpicsMotor, '-Ax:O}Mtr')\n    inboard = Cpt(EpicsMotor, '-Ax:I}Mtr')"
  },
  {
    "class_name": "XYMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class XYMotor(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')"
  },
  {
    "class_name": "DCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class DCM(Device):\n    en = Cpt(EpicsMotor, '-Ax:Energy}Mtr')\n    b = Cpt(EpicsMotor, '-Ax:B}Mtr')\n    r = Cpt(EpicsMotor, '-Ax:R}Mtr')\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    fp = Cpt(EpicsMotor, '-Ax:FP}Mtr')\n    p = Cpt(EpicsMotor, '-Ax:P}Mtr')"
  },
  {
    "class_name": "SAXSBeamStop",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class SAXSBeamStop( Device):\n    x = Cpt(     EpicsMotor, '-Ax:X}Mtr' )\n    y1 = Cpt(     EpicsMotor, '-Ax:YFT}Mtr')\n    x2 = Cpt(     EpicsMotor, '-Ax:XFB}Mtr')\n    y2 = Cpt(     EpicsMotor, '-Ax:YFB}Mtr')\n  \n    @property\n    def hints(self):\n        fields = []\n        for name in self.component_names:\n            motor = getattr(self, name)\n            fields.extend(motor.hints['fields'])\n        return {'fields': fields}"
  },
  {
    "class_name": "DMM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class DMM(Device):\n    # en = Cpt(EpicsMotor, '-Ax:Energy}Mtr')\n    b = Cpt(EpicsMotor, '-Ax:B}Mtr')\n    r = Cpt(EpicsMotor, '-Ax:R}Mtr')\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    fp = Cpt(EpicsMotor, '-Ax:FP}Mtr')"
  },
  {
    "class_name": "Transfocator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class Transfocator(Device):\n    crl = DDC({'num%d' % i: (EpicsMotor, '%d-Ax:X}Mtr' % i, {})\n               for i in range(1, 9)})\n    x = Cpt(EpicsMotor, 'Ves-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, 'Ves-Ax:Y}Mtr')\n    z = Cpt(EpicsMotor, 'Ves-Ax:Z}Mtr')\n    ph = Cpt(EpicsMotor, 'Ves-Ax:Ph}Mtr')\n    th = Cpt(EpicsMotor, 'Ves-Ax:Th}Mtr')"
  },
  {
    "class_name": "Kinoform",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class Kinoform(Device):\n    z = Cpt(EpicsMotor, '-Ax:ZB}Mtr')\n    x = Cpt(EpicsMotor, '-Ax:XB}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:YB}Mtr')\n    chi = Cpt(EpicsMotor, '-Ax:Ch}Mtr')\n    theta = Cpt(EpicsMotor, '-Ax:Th}Mtr')\n    phi = Cpt(EpicsMotor, '-Ax:Ph}Mtr')\n    lx = Cpt(EpicsMotor, '-Ax:XT}Mtr')\n    ly = Cpt(EpicsMotor, '-Ax:YT}Mtr')"
  },
  {
    "class_name": "SmarAct_single_axis",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class SmarAct_single_axis(Device):\n    x = Cpt(EpicsMotor, '{POS:1}Mtr')"
  },
  {
    "class_name": "Diffractometer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class Diffractometer(Device):\n    \n    Del= Cpt( EpicsMotor, '-Ax:Del}Mtr')\n    gam = Cpt(EpicsMotor, '-Ax:Gam}Mtr')\n    om = Cpt(EpicsMotor, '-Ax:Om}Mtr')\n    phi = Cpt(EpicsMotor, '-Ax:Ph}Mtr')\n    xb = Cpt(EpicsMotor, '-Ax:XB}Mtr')\n    yb = Cpt(EpicsMotor, '-Ax:YB}Mtr')\n    chh = Cpt(EpicsMotor, '-Ax:ChH}Mtr')\n    thh = Cpt(EpicsMotor, '-Ax:ThH}Mtr')\n    phh = Cpt(EpicsMotor, '-Ax:PhH}Mtr')\n    xh = Cpt(EpicsMotor, '-Ax:XH}Mtr')\n    yh = Cpt(EpicsMotor, '-Ax:YH2}Mtr')\n    zh = Cpt(EpicsMotor, '-Ax:ZH}Mtr')\n    chv = Cpt(EpicsMotor, '-Ax:ChV}Mtr')\n    #thv = Cpt(EpicsMotor, '-Ax:ThV}Mtr')\n    phv = Cpt(EpicsMotor, '-Ax:ThV}Mtr')  #Xiao's requested change\n    xv = Cpt(EpicsMotor, '-Ax:XV}Mtr')\n    yv = Cpt(EpicsMotor, '-Ax:YV}Mtr')\n    zv = Cpt(EpicsMotor, '-Ax:ZV}Mtr')\n    xv2 = Cpt(EpicsMotor, '-Ax:XV2}Mtr')\n\n    @property\n    def hints(self):\n        fields = []\n        for name in self.component_names:\n            motor = getattr(self, name)\n            fields.extend(motor.hints['fields'])\n        return {'fields': fields}"
  },
  {
    "class_name": "XBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class XBPM( Device):\n   vt = Cpt( EpicsSignal, 'CtrlDAC:BLevel-SP' )"
  },
  {
    "class_name": "amp_motor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/10-optics.py",
    "source": "class amp_motor(Device):\n    #x = EpicsMotor('XF:11IDB-OP{BS:Sam-Ax:X}Mtr')\n    ampx = EpicsSignal('XF:11IDB-OP{BS:Samp-Ax:X}Mtr.VAL', name='ampx')\n    ampy = EpicsSignal('XF:11IDB-OP{Stg:Samp-Ax:Phi}Mtr.VAL', name='ampy')\n    ampz = EpicsSignal('XF:11IDB-OP{BS:Samp-Ax:Y}Mtr.VAL', name='ampz')"
  },
  {
    "class_name": "FourPVShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/25-shutter.py",
    "source": "class FourPVShutter(Device):\n    def __init__(self, open=None, open_status=None,\n                 close=None, close_status=None):\n       super(Shutter, self).__init__()\n       signals = [EpicsSignal(open_status, write_pv=open, alias='_open'),\n                  EpicsSignal(close_status, write_pv=close, alias='_close'),\n                  ]\n\n       for sig in signals:\n           self.add_signal(sig)\n\n    def open(self):\n        self._open.value = 1\n\n    def close(self):\n        self._close.value = 1"
  },
  {
    "class_name": "FourPVShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/25-shutter.py",
    "source": "class FourPVShutter(Device):\n    open_command = Cpt(EpicsSignal, 'Cmd:Opn-Cmd')\n    open_status = Cpt(EpicsSignal, 'Cmd:Opn-Sts')\n    close_command = Cpt(EpicsSignal, 'Cmd:Cls-Cmd')\n    close_status = Cpt(EpicsSignal, 'Cmd:Cls-Sts')\n\n    def open(self):\n        self.open_command.put(1)\n\n    def close(self):\n        self.close_command.put(1)\n\n    @property\n    def is_open(self):\n        self._check_sanity()\n        return self.open_status.get()\n\n    def _check_sanity(self):\n        consistency = self.open_status.get() ^ self.close_status.get()\n        assert consistency, \"Shutter status is not self-consistent\""
  },
  {
    "class_name": "TwoPVShutter",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/chx-profile-collection/startup/25-shutter.py",
    "source": "class TwoPVShutter(EpicsSignal):\n    \"TODO: Make me a Device.\"\n    def open(self):\n        self.put(1)\n    \n    def close(self):\n        self.put(0)"
  },
  {
    "class_name": "XBpm",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/35-detectors.py",
    "source": "class XBpm(Device):\n    x = Cpt(EpicsSignalRO, 'Pos:X-I')\n    y = Cpt(EpicsSignalRO, 'Pos:Y-I')\n    a = Cpt(EpicsSignalRO, 'Ampl:ACurrAvg-I')\n    b = Cpt(EpicsSignalRO, 'Ampl:BCurrAvg-I')\n    c = Cpt(EpicsSignalRO, 'Ampl:CCurrAvg-I')\n    d = Cpt(EpicsSignalRO, 'Ampl:DCurrAvg-I')"
  },
  {
    "class_name": "Elm",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/35-detectors.py",
    "source": "class Elm(Device):\n\tsum_x = Cpt(EpicsSignalRO, 'SumX:MeanValue_RBV')\n\tsum_y = Cpt(EpicsSignalRO, 'SumY:MeanValue_RBV')\n\tsum_all = Cpt(EpicsSignalRO, 'SumAll:MeanValue_RBV', kind='hinted')"
  },
  {
    "class_name": "InsertionDevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/15-machines.py",
    "source": "class InsertionDevice(Device):\n    gap = Cpt(EpicsMotor, '-Ax:Gap}-Mtr',\n              kind='hinted', name='')\n    brake = Cpt(EpicsSignal, '}BrakesDisengaged-Sts',\n                write_pv='}BrakesDisengaged-SP',\n                kind='omitted', add_prefix=('read_pv', 'write_pv', 'suffix'))\n\n    def set(self, *args, **kwargs):\n        set_and_wait(self.brake, 1)\n        return self.gap.set(*args, **kwargs)\n\n    def stop(self, *, success=False):\n        return self.gap.stop(success=success)"
  },
  {
    "class_name": "Syringe_Pump",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/31-syringe_pump.py",
    "source": "class Syringe_Pump(Device):\n    \"Syringe pump controller\"\n    \n    vol_sp = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Val:Vol-SP'%i, {}) for i in range(1, 3)})\n    vol_rb = DDC({'p%d' % i: (EpicsSignalRO, '{Pmp:%s}Val:Vol-RB'%i, {}) for i in range(1, 3)})\n    \n    rate_sp = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Val:Rate-SP'%i, {}) for i in range(1, 3)})\n    rate_rb = DDC({'p%d' % i: (EpicsSignalRO, '{Pmp:%s}Val:Rate-RB'%i, {}) for i in range(1, 3)})\n    \n    dia_sp = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Val:Dia-SP'%i, {}) for i in range(1, 3)})\n    dia_rb = DDC({'p%d' % i: (EpicsSignalRO, '{Pmp:%s}Val:Dia-RB'%i, {}) for i in range(1, 3)})\n    \n    dir_sp   =   DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Val:Dir-Sel'%i, {}) for i in range(1, 3)})\n    dir_rb   =   DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Val:Dir-Sts'%i, {}) for i in range(1, 3)})\n    \n    vol_unit_sp = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Unit:Vol-Sel'%i, {}) for i in range(1, 3)})\n    rate_unit_sp = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Unit:Rate-Sel'%i, {}) for i in range(1, 3)})      \n    vol_unit_rb = DDC({'p%d' % i: (EpicsSignalRO, '{Pmp:%s}Unit:Vol-Sel'%i, {}) for i in range(1, 3)})\n    rate_unit_rb = DDC({'p%d' % i: (EpicsSignalRO, '{Pmp:%s}Unit:Rate-Sel'%i, {}) for i in range(1, 3)})     \n      \n    \n    Run   =    DDC({'p%s' % i: (EpicsSignal, '{Pmp:%s}Cmd:Run-Cmd'%i, {}) for i in [1,2,'All'] } )  \n    Stop   =   DDC({'p%s' % i: (EpicsSignal, '{Pmp:%s}Cmd:Stop-Cmd'%i, {}) for i in [1,2,'All'] } ) \n    Purge  =   DDC({'p%s' % i: (EpicsSignal, '{Pmp:%s}Cmd:Purge-Cmd'%i, {}) for i in [1,2,'All'] } ) \n          \n    disI_vol_rb = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Val:InfDisp-I'%i, {}) for i in [1,2] } ) \n    disI_unit_rb = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Val:InfDisp-I.EGU'%i, {}) for i in [1,2] } )\n    \n    disW_vol_rb = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Val:WdlDisp-I'%i, {}) for i in [1,2] } ) \n    disW_unit_rb = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Val:WdlDisp-I.EGU'%i, {}) for i in [1,2] } )    \n    \n    Clr = DDC({'p%d' % i: (EpicsSignal, '{Pmp:%s}Cmd:Clr-Cmd'%i, {}) for i in [1,2] } ) \n         \n   \n    \n    p='All'\n    run_all = Cpt(EpicsSignal, '{Pmp:%s}Cmd:Run-Cmd'%p)\n    purge_all = Cpt(EpicsSignal, '{Pmp:%s}Cmd:Purge-Cmd'%p)\n    stop_all = Cpt(EpicsSignal, '{Pmp:%s}Cmd:Stop-Cmd'%p)    \n     \n    def get_vol( self, pump =1 ):\n        if pump==1:\n            return self.vol_rb.p1.value\n        else:\n            return self.vol_rb.p2.value\n            \n    def get_vol_unit( self, pump =1 ):\n        if pump==1:\n            return self.vol_unit_rb.p1.value\n        else:\n            return self.vol_unit_rb.p2.value \n               \n    def set_vol_unit( self, pump =1 ):\n        if pump==1:\n            return self.vol_unit_sp.p1.value\n        else:\n            return self.vol_unit_sp.p2.value  \n            \n    def get_rate_unit( self, pump =1 ):\n        if pump==1:\n            return self.rate_unit_rb.p1.value\n        else:\n            return self.rate_unit_rb.p2.value \n               \n    def set_rate_unit( self, pump =1 ):\n        if pump==1:\n            return self.rate_unit_sp.p1.value\n        else:\n            return self.rate_unit_sp.p2.value    \n                                           \n            \n    def set_vol( self, val, pump =1 ):\n        if pump==1:\n            return self.vol_sp.p1.set( val) \n        else:\n            return self.vol_sp.p2.set( val) \n            \n    def get_rate( self, pump =1 ):\n        if pump==1:\n            return self.rate_rb.p1.value\n        else:\n            return self.rate_rb.p2.value\n            \n    def set_rate( self, val, pump =1 ):\n        if pump==1:\n            return self.rate_sp.p1.set( val) \n        else:\n            return self.rate_sp.p2.set( val) \n            \n    def get_dia( self, pump =1 ):\n        if pump==1:\n            return self.dia_rb.p1.value\n        else:\n            return self.dia_rb.p2.value\n            \n    def set_dia( self, val, pump =1 ):\n        if pump==1:\n            return self.dia_sp.p1.set( val) \n        else:\n            return self.dia_sp.p2.set( val)\n            \n    def get_dir( self, pump =1 ):\n        if pump==1:\n            return self.dir_rb.p1.value\n        else:\n            return self.dir_rb.p2.value\n            \n    def set_dir( self, val, pump =1 ):\n        if pump==1:\n            return self.dir_sp.p1.set( val) \n        else:\n            return self.dir_sp.p2.set( val)  \n            \n    def run( self, pump=1 ):\n         if pump==1:\n            return self.Run.p1.set(1) \n         elif pump==2:\n            return self.Run.p2.set(1)                 \n         else:\n            return sp.Run.pAll.set(1)           \n            \n    def stop( self, pump=1 ):\n         if pump==1:\n            return self.Stop.p1.set(1) \n         elif pump==2:\n            return self.Stop.p2.set(1)                 \n         else:\n            return self.Stop.pAll.set(1)      \n            \n    def get_disvol( self,  pump=1, Dir=None, ): \n        '''dir: 0 for infusion, 1 for withdraw '''\n        if Dir is None:\n            Dir = self.get_dir(   pump  ) \n        if Dir ==0:\n            if pump==1:\n                return self.disI_vol_rb.p1.value\n            else:\n                return self.disI_vol_rb.p2.value  \n        else:\n            if pump==1:\n                return self.disW_vol_rb.p1.value\n            else:\n                return self.disW_vol_rb.p2.value   \n           \n    def clr( self,  pump=1, Dir=None, ): \n        '''dir: 0 for infusion, 1 for withdraw '''\n        if Dir is None:\n            Dir = self.get_dir(   pump  ) \n        if pump==1:\n            return self.Clr.p1.set( Dir )   \n        else:\n            return self.Clr.p2.set( Dir )   \n                          \n    \n    @property\n    def hints(self):\n        fields = []\n        for name in self.component_names:\n            motor = getattr(self, name)\n            fields.extend(motor.hints['fields'])\n        return {'fields': fields}"
  },
  {
    "class_name": "Peltier_Cooler",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/30-user.py",
    "source": "class Peltier_Cooler(Device):\n    enable_command = Cpt(EpicsSignal, 'B-ES{Pel-IO:1}DO:1-Cmd')\n    enable_status = Cpt(EpicsSignal, 'B-ES{Pel-IO:1}DO:1-Sts')\n    set_power_command = Cpt(EpicsSignal, '-CT{Peltier:1}ai2')\n    setup_power = Cpt(EpicsSignal, '-CT{Peltier:1}ai2.DESC')\n    setup_hot_side_max = Cpt(EpicsSignal, '-CT{Peltier:1}ai3.DESC')\n    set_hot_side_max = Cpt(EpicsSignal, '-CT{Peltier:1}ai3')\n    setup_chiller_temperature = Cpt(EpicsSignal, '-CT{Peltier:1}ai1.DESC')\n    set_chiller_temperature = Cpt(EpicsSignal, '-CT{Peltier:1}ai1')\n    setup_peltier_enabled = Cpt(EpicsSignal, '-CT{Peltier:1}bi9.DESC')\n\n    def enable(self):\n        self.enable_command.put(1)\n        print('Peltier Power enabled.')\n        \n    def disable(self):\n        self.enable_command.put(0,use_complete=True)\n        print('Peltier Power diabled.')\n            \n    def power(self,P):\n        self.set_power_command.put(P)\n        print('Peltier Power set to: %s percent'%P)\n        \n    def status(self):\n        return print('Peltier enabled: %s   Peltier Power: %s percent'%(bool(self.enable_status.get()),self.set_power_command.get()))\n    \n    def setup(self):\n        self.setup_chiller_temperature.put('chiller temp. [12-22C]')\n        self.set_chiller_temperature.put(22)\n        self.setup_power.put('Peltier Power [0-100%]')\n        self.set_power_command.put(0)\n        self.setup_hot_side_max.put('Pel. hot side max T [C]')\n        self.set_hot_side_max.put(17.5)\n        self.setup_peltier_enabled.put('Peltier ENABLED')\n    \n    def chiller_temperature(self,T):\n        self.set_chiller_temperature.put(T)\n        print('Chiller temperature set to: %s [C]'%T)"
  },
  {
    "class_name": "ZebraINP",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/98-xspress3.py",
    "source": "class ZebraINP(Device):\n    use = FC(EpicsSignal, \n             '{self.prefix}_ENA:B{self._bindex}')\n    source_addr = FC(EpicsSignalWithRBV, \n                     '{self.prefix}_INP{self.index}')\n    source_str = FC(EpicsSignalRO, \n                    '{self.prefix}_INP{self.index}:STR', \n                    string=True)\n    source_status = FC(EpicsSignalRO, \n                    '{self.prefix}_INP{self.index}:STA')\n    invert = FC(EpicsSignal, \n                '{self.prefix}_INV:B{self._bindex}')\n\n    def __init__(self, prefix, *, index, read_attrs=None, configuration_attrs=None,\n                 **kwargs):\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = ['use', 'source_addr', 'source_str', 'invert']\n        self.index = index\n        self._bindex = index - 1\n        super().__init__(prefix, read_attrs=read_attrs, configuration_attrs=configuration_attrs,\n                         **kwargs)"
  },
  {
    "class_name": "ZebraLogic",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/98-xspress3.py",
    "source": "class ZebraLogic(Device):\n\n    inp1 = Cpt(ZebraINP, '', index=1)\n    inp2 = Cpt(ZebraINP, '', index=2)\n    inp3 = Cpt(ZebraINP, '', index=3)\n    inp4 = Cpt(ZebraINP, '', index=4)\n    out = Cpt(EpicsSignalRO, '_OUT')\n\n    def __init__(self, *args, read_attrs=None, configuration_attrs=None,\n                 **kwargs):\n        if read_attrs is None:\n            read_attrs = ['out']\n        if configuration_attrs is None:\n            configuration_attrs = ['inp{}'.format(j) for j in range(1, 5)]\n\n        super().__init__(*args, read_attrs=read_attrs, \n                          configuration_attrs=configuration_attrs, **kwargs)"
  },
  {
    "class_name": "CHXXspress3Detector",
    "bases": [
      "XspressTrigger",
      "Xspress3Detector"
    ],
    "file": "profile-collections/chx-profile-collection/startup/98-xspress3.py",
    "source": "class CHXXspress3Detector(XspressTrigger, Xspress3Detector):\n    roi_data = Cpt(PluginBase, 'ROIDATA:')\n    channel1 = Cpt(Xspress3Channel, \n                   'C1_', channel_num=1, \n                   read_attrs=['rois'])"
  },
  {
    "class_name": "GateConfig",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/98-xspress3.py",
    "source": "class GateConfig(Device):\n    trig_source = Cpt(EpicsSignalWithRBV, 'PC_GATE_SEL', string=True)\n    start = Cpt(EpicsSignal, 'PC_GATE_START')\n    width = Cpt(EpicsSignal, 'PC_GATE_WID')\n    step = Cpt(EpicsSignal, 'PC_GATE_STEP')\n    ngate = Cpt(EpicsSignal, 'PC_GATE_NGATE')\n    status = Cpt(EpicsSignal, 'PC_GATE_OUT')"
  },
  {
    "class_name": "PulseConfig",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/98-xspress3.py",
    "source": "class PulseConfig(Device):\n    trig_source = Cpt(EpicsSignalWithRBV, 'PC_PULSE_SEL', string=True)\n    start = Cpt(EpicsSignal, 'PC_PULSE_START')\n    width = Cpt(EpicsSignal, 'PC_PULSE_WID')\n    step = Cpt(EpicsSignal, 'PC_PULSE_STEP')\n    delay = Cpt(EpicsSignal, 'PC_PULSE_DLY')\n    nmax = Cpt(EpicsSignal, 'PC_PULSE_MAX')\n    status = Cpt(EpicsSignal, 'PC_PULSE_OUT')"
  },
  {
    "class_name": "Zebra",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/98-xspress3.py",
    "source": "class Zebra(Device):\n    soft_input1 = Cpt(EpicsSignal, 'SOFT_IN:B0')\n    soft_input2 = Cpt(EpicsSignal, 'SOFT_IN:B1')\n    soft_input3 = Cpt(EpicsSignal, 'SOFT_IN:B2')\n    soft_input4 = Cpt(EpicsSignal, 'SOFT_IN:B3')\n\n    pulse1 = Cpt(ZebraPulse, 'PULSE1_', index=1)\n    pulse2 = Cpt(ZebraPulse, 'PULSE2_', index=2)\n    pulse3 = Cpt(ZebraPulse, 'PULSE3_', index=3)\n    pulse4 = Cpt(ZebraPulse, 'PULSE4_', index=4)\n\n    output1 = Cpt(ZebraFrontOutput12, 'OUT1_', index=1)\n    output2 = Cpt(ZebraFrontOutput12, 'OUT2_', index=2)\n    output3 = Cpt(ZebraFrontOutput3, 'OUT3_', index=3)\n    output4 = Cpt(ZebraFrontOutput4, 'OUT4_', index=4)\n\n    output5 = Cpt(ZebraRearOutput, 'OUT5_', index=5)\n    output6 = Cpt(ZebraRearOutput, 'OUT6_', index=6)\n    output7 = Cpt(ZebraRearOutput, 'OUT7_', index=7)\n    output8 = Cpt(ZebraRearOutput, 'OUT8_', index=8)\n\n    gate1 = Cpt(ZebraGate, 'GATE1_', index=1)\n    gate2 = Cpt(ZebraGate, 'GATE2_', index=2)\n    gate3 = Cpt(ZebraGate, 'GATE3_', index=3)\n    gate4 = Cpt(ZebraGate, 'GATE4_', index=4)\n\n    or1 = Cpt(ZebraLogic, 'OR1')\n    or2 = Cpt(ZebraLogic, 'OR2')\n    or3 = Cpt(ZebraLogic, 'OR3')\n    or4 = Cpt(ZebraLogic, 'OR4')\n\n    and1 = Cpt(ZebraLogic, 'AND1')\n    and2 = Cpt(ZebraLogic, 'AND2')\n    and3 = Cpt(ZebraLogic, 'AND3')\n    and4 = Cpt(ZebraLogic, 'AND4')\n\n    addresses = ZebraAddresses\n\n    arm = Cpt(EpicsSignal, 'PC_ARM')\n    arm_status = Cpt(EpicsSignal, 'PC_ARM_OUT')\n    arm_trig = Cpt(EpicsSignalWithRBV, 'PC_ARM_SEL', string=True)\n    \n    gate_config = Cpt(GateConfig, '', read_attrs=[], configuration_attrs=['trig_source', 'start', 'width', 'step', 'ngate'])\n    pulse_config = Cpt(PulseConfig, '', read_attrs=[], configuration_attrs=['trig_source', 'start', 'width', 'step', 'delay', 'nmax'])"
  },
  {
    "class_name": "XspressZebra",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/chx-profile-collection/startup/98-xspress3.py",
    "source": "class XspressZebra(Device):\n    zebra = Cpt(CHXZebra, 'XF:11IDB-ES{Zebra}:', add_prefix=(),\n                configuration_attrs=['{}{}'.format(n, j) for n in ['pulse', 'gate', 'or', 'and']  \n                                     for j in range(1,5)] + ['output{}'.format(i) for i in range(1, 9)] + ['gate_config', 'pulse_config', 'arm_trig'],\n                read_attrs=[])\n    #xs = Cpt(CHXXspress3Detector, 'XSPRESS3-EXAMPLE:', add_prefix=())\n    xs = Cpt(CHXXspress3Detector, 'XF:11IDB-ES{Xsp:1}:', add_prefix=())\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        \n\n    def trigger(self):\n        st = self.xs.trigger()\n        # TODO make sure Xspress is actually ready before \n        # arming zebra\n        self.zebra.arm.set(1)\n        return st\n    \n    @property\n    def hints(self):\n        return {'fields': [  self.xs.channel1.rois.roi01.value.name ] }"
  },
  {
    "class_name": "XPStraj",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/tests/traj_py.py",
    "source": "class XPStraj(Device):\n    def __init__(self, ip_addr, group, name, \n                 devices={'scan.rY': ss2.ry, 'scan.Y': ss2.y, 'scan.X': ss2.x}):\n        \"\"\" ip_addr: IP of the XPS controller\n            group: PVT positioner grouped defined in the controller\n            name: \n            devices: the corresponding Ophyd device for the posiitoner group, useful in a scan\n        \"\"\"\n        super().__init__(name=name)\n        self.xps = XPS()\n        self.ip_addr = ip_addr\n        self.sID = self.xps.TCP_ConnectToServer(ip_addr, 5001, 0.050)\n        # 20 ms timeout is suggested for single-socket communication, per programming manual\n        \n        objs = self.xps.ObjectsListGet(self.sID)[1].split(';;')[0].split(';')\n        if group not in objs:\n            print(\"group %s does not exist.\" % group)\n            print(\"valid objects are\", objs)\n            raise Exception\n        self.group = group\n        self.motors = [mot for mot in objs if (group+'.') in mot] \n        self.Nmot = len(self.motors) \n        \n        self.devices = devices\n        for m in devices.keys():\n            if m not in self.motors:\n                raise Exception('invalid motor: ', m)\n            print(m, devices[m].name)\n        self.device_names = [devices[k].name for k in devices.keys()]\n        \n        self.verified = False\n        uname = getpass.getuser()\n        self.traj_files = [\"TrajScan_FW.trj-%s\" % uname, \"TrajScan_BK.trj-%s\" % uname]\n        self.traj_par = {'run_forward_traj': True, \n                         'no_of_segments': 0, \n                         'no_of_rampup_points': 0,\n                         'segment_displacement': 0,\n                         'segment_duration': 0,\n                         'motor': None,\n                         'rampup_distance': 0,\n                         'motor2': None\n                        }\n        self.time_modified = time.time()\n        self.start_time = 0\n        self._traj_status = None\n        self.detectors = None\n        self.datum = None\n        \n    def stage(self):\n        self.datum = {}\n    \n    def unstage(self):\n        \"\"\" abort whatever is still going on??\n        \"\"\"\n        self.abort_traj()\n        self._traj_status = None\n        \n    def pulse(self, duration=0.00001):\n        # GPIO3.DO, pin 4\n        mask = '1'   # it seems that only DO1 works\n        self.xps.GPIODigitalSet(self.sID, \"GPIO3.DO\", mask, 1)\n        #time.sleep(duration)\n        self.xps.GPIODigitalSet(self.sID, \"GPIO3.DO\", mask, 0)\n        \n    def read_configuration(self):\n        ret = [(k, {'value': self.traj_par[k], \n                    'timestamp': self.time_modified}) for k in self.traj_par.keys()]\n        return OrderedDict(ret)\n        \n    def describe_configuration(self):\n        pass\n        \n    def select_forward_traj(self, op=True):\n        if op:\n            self.traj_par['run_forward_traj'] = True\n        else:\n            self.traj_par['run_forward_traj'] = False\n        \n    def moving(self):\n        err,msg = self.xps.GroupMotionStatusGet(self.sID, self.group, self.Nmot)\n        if (np.asarray(msg.split(','))=='0').all():\n            return False\n        return True\n    \n    def abort_traj(self):\n        if self.moving():\n            err,msg = self.xps.GroupMoveAbort(self.sID, self.group)\n            return err,msg\n        return\n        \n    def kickoff(self):\n        \"\"\"\n        run the trajectory\n        \"\"\"\n        if self.verified==False:\n            raise Exception(\"trajectory not defined/verified.\")\n        \n        #self._traj_status = DeviceStatus(self.ExecuteState)\n        self._traj_status = DeviceStatus(self)\n      \n        ##self.exec_traj(self.traj_par['run_forward_traj'])  # should not block\n        th = threading.Thread(target=self.exec_traj, args=(self.traj_par['run_forward_traj'], ) )\n        th.start() \n        # always done, the scan should never even try to wait for this\n        #status = DeviceStatus(self)\n        #status._finished()\n        return self._traj_status\n        \n    def complete(self):\n        \"\"\"\n        Return a status object tied to 'done'.\n        \"\"\"\n        #if self._traj_status is None:\n        #    raise RuntimeError(\"must call kickoff() before complete()\")\n        self._traj_status.done = not self.moving()\n        \n        return self._traj_status\n        \n    def collect_asset_docs(self):\n        \"\"\" adapted from HXN fly scan example\n        \"\"\"\n        asset_docs_cache = []\n\n        for det in self.detectors:\n            k = f'{det.name}_image'\n            #det.dispatch(k, ttime.time())\n            (name, resource), = det.file.collect_asset_docs()\n            assert name == 'resource'\n            asset_docs_cache.append(('resource', resource))\n            resource_uid = resource['uid']\n            datum_id = '{}/{}'.format(resource_uid, 0)\n            self.datum[k] = [datum_id, ttime.time()]\n            datum = {'resource': resource_uid,\n                     'datum_id': datum_id,\n                     'datum_kwargs': {'point_number': 0}}\n            asset_docs_cache.append(('datum', datum))\n            \n        return tuple(asset_docs_cache)\n            \n        \n    def collect(self):\n        \"\"\"\n        save position data, called at the end of a scan (not at the end of a trajectory)\n        this is now recorded in self.readback, as accumulated by self.update_readback()\n        \"\"\"\n        now = time.time()\n        data = {}\n        ts = {}\n        \n        data[self.traj_par['fast_axis']] = self.read_back['fast_axis']\n        ts[self.traj_par['fast_axis']] = now\n        if self.traj_par['motor2'] is not None:\n            data[self.traj_par['slow_axis']] = self.read_back['slow_axis']\n            ts[self.traj_par['slow_axis']] = now\n\n        for det in self.detectors:\n            k = f'{det.name}_image'\n            (data[k], ts[k]) = self.datum[k]\n            for k,desc in det.read().items():\n                data[k] = desc['value']\n                ts[k] = desc['timestamp']\n                \n        ret = {'time': time.time(),\n               'data': data,\n               'timestamps': ts,\n              }\n        \n        yield ret\n\n    def describe_collect(self):\n        '''Describe details for the flyer collect() method'''\n        ret = {}\n        ret[self.traj_par['fast_axis']] = {'dtype': 'number',\n                                           'shape': (1,),\n                                           'source': 'PVT trajectory readback position'}\n        if self.traj_par['motor2'] is not None:\n            ret[self.traj_par['slow_axis']] = {'dtype': 'number',\n                                               'shape': (1,),\n                                               'source': 'motor position readback'}\n        for det in self.detectors:\n            ret[f'{det.name}_image'] = det.make_data_key() \n            for k,desc in det.describe().items():\n                ret[k] = desc\n                \n        return {'primary': ret}\n        \n    def define_traj(self, motor, N, dx, dt, motor2=None, dy=0, Nr=2):\n        \"\"\" the idea is to use FW/BK trjectories in a scan\n            each trajactory involves a single motor only\n            relative motion, N segements of length dx from the current position\n            duration of each segment is dt\n            \n            Additional segments (Nr, at least 2) are required to ramp up and down, e.g.:\n            \n            # dt,  x,  v_out\n            1.0,  0.16667, 0.5\n            1.0,  1.0,     1.0\n            ... ...\n            1.0,  1.0,     1.0\n            1.0,  0.83333, 0.5\n            1.0,  0,0,     0.0\n            detector triggering should start from the 5th segment\n            \n        \"\"\"        \n        self.verified = False\n\n        if motor not in self.motors:\n            print(\"motor %s not in the list of motors: \"%motor, self.motors)\n            raise Exception\n        \n        err,ret = self.xps.PositionerMaximumVelocityAndAccelerationGet(self.sID, motor)\n        mvel,macc = np.asarray(ret.split(','), dtype=np.float)\n        midx = self.motors.index(motor)\n        \n        jj = np.zeros(Nr+N+Nr)\n        jj[0] = 1; jj[Nr-1] = -1\n        jj[-1] = 1; jj[-Nr] = -1\n        # these include the starting state of acc=vel=disp=0\n        disp = np.zeros(Nr+N+Nr+1)\n        vel = np.zeros(Nr+N+Nr+1)\n        acc = np.zeros(Nr+N+Nr+1)\n\n        for i in range(N+2*Nr):\n            acc[i+1] = acc[i] + jj[i]*dt\n            vel[i+1] = vel[i] + acc[i]*dt + jj[i]*dt*dt/2\n            disp[i+1] = vel[i]*dt + acc[i]*dt*dt/2 + jj[i]*dt*dt*dt/6\n        vel = vel/vel.max()*dx/dt\n        disp = disp/disp.max()*dx\n        self.ramp_dist = disp[1:Nr+1].sum()\n        \n        # rows in a PVT trajectory file correspond ot the segments  \n        # for each row/segment, the elements are\n        #     time, axis 1 displancement, axis 1 velocity out, axsi 2 ... \n        ot1 = np.zeros((Nr+N+Nr, 1+2*self.Nmot))\n        ot1[:, 0] = dt\n        ot1[:, 2*midx+1] = disp[1:] \n        ot1[:, 2*midx+2] = vel[1:] \n        ot2 = np.zeros((Nr+N+Nr, 1+2*self.Nmot))\n        ot2[:, 0] = dt\n        ot2[:, 2*midx+1] = -disp[1:] \n        ot2[:, 2*midx+2] = -vel[1:] \n        \n        np.savetxt(\"/tmp/\"+self.traj_files[0], ot1, fmt='%f', delimiter=', ')\n        np.savetxt(\"/tmp/\"+self.traj_files[1], ot2, fmt='%f', delimiter=', ')\n        ftp = FTP(self.ip_addr)\n        ftp.connect()\n        ftp.login(\"Administrator\", \"Administrator\")\n        ftp.cwd(\"Public/Trajectories\")\n        for fn in self.traj_files:\n            file = open(\"/tmp/\"+fn, \"rb\")\n            ftp.storbinary('STOR %s' % fn, file)\n            file.close()\n        ftp.quit()\n        \n        for fn in self.traj_files:\n            err,ret = self.xps.MultipleAxesPVTVerification(self.sID, self.group, fn)\n            if err!='0':\n                print(ret)\n                raise Exception(\"trajectory verification failed.\")\n            err,ret = self.xps.MultipleAxesPVTVerificationResultGet (self.sID, motor)\n        self.verified = True\n        self.traj_par = {'run_forward_traj': True, \n                         'no_of_segments': N, \n                         'no_of_rampup_points': Nr,\n                         'segment_displacement': dx,\n                         'segment_duration': dt,\n                         'motor': motor,\n                         'rampup_distance': self.ramp_dist,\n                         'motor2': motor2,\n                         'motor2_disp': dy\n                        }\n        self.traj_par['fast_axis'] = xps_trj.devices[motor].name\n        if motor2 is not None:\n            self.traj_par['slow_axis'] = motor2.name\n        self.time_modified = time.time()\n        \n    def exec_traj(self, forward=True, clean_event_queue=False):\n        \"\"\"\n           execuate either the foward or backward trajectory\n        \"\"\"\n        if self.verified==False:\n            raise Exception(\"trajectory not defined/verified.\")\n\n        N = self.traj_par['no_of_segments']\n        Nr = self.traj_par['no_of_rampup_points']\n        motor = self.traj_par['motor']\n        dt = self.traj_par['segment_duration']\n        \n        if forward: \n            traj_fn = self.traj_files[0]\n        else:\n            traj_fn = self.traj_files[1]\n        \n        # otherwise starting the trajectory might generate an error\n        while self.moving():\n            time.sleep(0.2)\n        \n        # first set up gathering\n        self.xps.GatheringReset(self.sID)        \n        # pulse is generated when the positioner enters the segment\n        print(\"setting triggering parameters: %d, %d, %.3f\" % (Nr+1, N+Nr+1, dt))\n        self.xps.MultipleAxesPVTPulseOutputSet (self.sID, self.group, Nr+1, N+Nr+1, dt)\n        self.xps.MultipleAxesPVTVerification(self.sID, self.group, traj_fn)\n        self.xps.GatheringConfigurationSet(self.sID, [motor+\".CurrentPosition\"])\n        self.xps.sendAndReceive(self.sID, \n                                'EventExtendedConfigurationTriggerSet('+\n                                'Always,0,0,0,0,%s.PVT.TrajectoryPulse,0,0,0,0)'%self.group )\n        self.xps.sendAndReceive(self.sID, \n                                'EventExtendedConfigurationActionSet('+\n                                'GatheringOneData,0,0,0,0)')\n        # all trigger event for gathering should be removed\n        if clean_event_queue:\n            err,ret = self.xps.EventExtendedAllGet(self.sID)\n            if err=='0':\n                for ev in ret.split(';'):\n                    self.xps.EventExtendedRemove(self.sID, ev) \n        eID = self.xps.EventExtendedStart(self.sID)[1]\n        self.start_time = time.time()\n        self.xps.MultipleAxesPVTExecution (self.sID, self.group, traj_fn, 1)\n        self.xps.GatheringStopAndSave(self.sID)\n        self.xps.EventExtendedRemove(self.sID, eID)\n        self.update_readback()\n\n        if self._traj_status != None:\n            self._traj_status._finished()\n    \n    def readback_traj(self):\n        err,ret = self.xps.GatheringCurrentNumberGet(self.sID)\n        ndata = int(ret.split(',')[0])\n        err,ret = self.xps.GatheringDataMultipleLinesGet(self.sID, 0, ndata)\n        return [float(p) for p in ret.split('\\n') if p!='']\n    \n    def clear_readback(self):\n        self.read_back = {}\n        self.read_back['fast_axis'] = []\n        if self.traj_par['motor2'] is not None:\n            self.read_back['slow_axis'] = []\n        \n    def update_readback(self):\n        self.read_back['fast_axis'] += self.readback_traj()\n        if self.traj_par['motor2'] is not None:\n            self.read_back['slow_axis'] += [self.traj_par['motor2'].position]"
  },
  {
    "class_name": "Region",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/20-spectro.py",
    "source": "class Region(Device):\n    lower_limit = Cpt(EpicsSignal, \"LowerLimit\")\n    upper_limit = Cpt(EpicsSignal, \"UpperLimit\")\n    luminescence = Cpt(EpicsSignalRO, \"Luminescence\")"
  },
  {
    "class_name": "USB4000",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/20-spectro.py",
    "source": "class USB4000(Device):\n    region1 = Cpt(Region, \"Region1:\")\n    region2 = Cpt(Region, \"Region2:\")\n    region3 = Cpt(Region, \"Region3:\")\n    region4 = Cpt(Region, \"Region4:\")\n    region5 = Cpt(Region, \"Region5:\")\n\n    acquire = Cpt(EpicsSignal, \"Acquire\", trigger_value=1)\n    acquiring = Cpt(EpicsSignal, \"Acquiring.RVAL\")\n    acquisition_mode = Cpt(EpicsSignal, \"AcquisitionMode\", string=True)\n\n    time_resolution = Cpt(EpicsSignal, \"IntegrationTime:Resolution\", string=True)\n    time_value = Cpt(EpicsSignal, \"IntegrationTime:Value\")\n\n    total_luminescence = Cpt(EpicsSignalRO, \"TotalLuminescence\")\n\n    spectra = Cpt(EpicsSignalRO, \"Spectra\")\n\n    spectra_processed = Cpt(EpicsSignalRO, \"Spectra:Processed\")\n\n    dark_cor_spectra = Cpt(EpicsSignalRO, \"DarkCorrectedSpectra\")\n    back_cor_spectra = Cpt(EpicsSignalRO, \"BackgroundSpectra\")\n    absorption_spectra = Cpt(EpicsSignalRO, \"AbsorptionSpectra\")\n\n    dark_correction = Cpt(EpicsSignal, \"ElectricalDark\")\n\n    progress_bar = Cpt(EpicsSignal, \"ProgressBar\")\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._acquiring_status = None\n        #self.stage_sigs[self.acquire] = 0 # Stop\n        #self.stage_sigs[self.acquisition_mode] = 0 # Single\n        #self.stage_sigs[self.time_resolution] = 1 # mSeconds\n\n    def stage(self):\n        super().stage()\n        #self.acquiring.subscribe(self._acquiring_changed)\n        self.progress_bar.subscribe(self._acquiring_changed)\n\n    def unstage(self):\n        super().unstage()\n        #self.acquiring.clear_sub(self._acquiring_changed)\n        self.progress_bar.clear_sub(self._acquiring_changed)\n        self._acquiring_status = None\n\n    def trigger(self):\n        self.acquire.put(1, use_complete=True)\n        self._acquiring_status = DeviceStatus(self.progress_bar)\n        return self._acquiring_status\n\n    def _acquiring_changed(self, value, old_value, **kwargs):\n        if self._acquiring_status is None:\n            return\n        #if (old_value == 1) and (value == 0):\n        #    self._acquiring_status._finished()\n        if (old_value < 100.0) and (value == 100.0):\n            self._acquiring_status._finished()"
  },
  {
    "class_name": "Vortex",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/20-vortex.py",
    "source": "class Vortex(Device):\n    mca = Cpt(EpicsMCA, 'mca1')\n    vortex = Cpt(EpicsDXP, 'dxp1:')\n\n    @property\n    def trigger_signals(self):\n        return [self.mca.erase_start]"
  },
  {
    "class_name": "PilatusFilePlugin",
    "bases": [
      "Device",
      "FileStoreIterativeWrite"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/20-pilatus.py",
    "source": "class PilatusFilePlugin(Device, FileStoreIterativeWrite):\n    file_path = ADComponent(EpicsSignalWithRBV, 'FilePath', string=True)\n    file_number = ADComponent(EpicsSignalWithRBV, 'FileNumber')\n    file_name = ADComponent(EpicsSignalWithRBV, 'FileName', string=True)\n    file_template = ADComponent(EpicsSignalWithRBV, 'FileTemplate', string=True)\n    file_number_reset = 1\n    next_file_number = 1\n    sub_directory = None\n    froot = data_file_path.gpfs\n    enable = SimpleNamespace(get=lambda: True)\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._datum_kwargs_map = dict()  # store kwargs for each uid\n        self.filestore_spec = 'AD_CBF'\n\n    def stage(self):\n        global proposal_id\n        global run_id\n        global current_sample\n        global data_path\n\n        f_tplt = '%s%s_%06d_'+self.parent.detector_id+'.cbf'\n        set_and_wait(self.file_template, f_tplt, timeout=99999)\n\n        if PilatusFilePlugin.sub_directory is not None:\n            f_path = data_path+PilatusFilePlugin.sub_directory\n        else:\n            f_path = data_path\n\n        f_fn = current_sample\n        print('%s: setting file path ...' % self.name)\n        if self.froot == data_file_path.ramdisk:\n            f_path = f_path.replace(data_file_path.gpfs.value, data_file_path.ramdisk.value) \n        set_and_wait(self.file_path, f_path, timeout=99999) \n        set_and_wait(self.file_name, f_fn, timeout=99999)\n        self._fn = Path(f_path)\n\n        fpp = self.get_frames_per_point()\n        # when camserver collects in \"multiple\" mode, another number is added to the file name\n        # even though the template does not specify it. \n        # Camserver doesn't like the template to include the second number\n        # The template will be revised in the CBF handler if fpp>1\n\n        print('%s: super().stage() ...' % self.name)\n        super().stage()\n        res_kwargs = {'template': f_tplt, # self.file_template(),\n                      'filename': f_fn, # self.file_name(),\n                      'frame_per_point': fpp,\n                      'initial_number': self.file_number.get()}\n        print('%s: _generate_resource() ...' % self.name)\n        self._generate_resource(res_kwargs)\n\n    def unstage(self):\n        super().unstage()\n\n    def get_frames_per_point(self):\n        return self.parent.parent._num_images"
  },
  {
    "class_name": "LiXPilatusDetectors",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/20-pilatus.py",
    "source": "class LiXPilatusDetectors(Device):\n    pil1M = Cpt(LIXPilatus, '{Det:SAXS}', name=\"pil1M\", detector_id=\"SAXS\")\n    pilW1 = Cpt(LIXPilatus, '{Det:WAXS1}', name=\"pilW1\", detector_id=\"WAXS1\")\n    pilW2 = Cpt(LIXPilatus, '{Det:WAXS2}', name=\"pilW2\", detector_id=\"WAXS2\")\n    trigger_lock = None\n    reset_file_number = True\n    _num_images = 1\n    _num_repeats = 1\n    active_detectors = []\n    trig_wait = 1.\n    acq_time = 1.\n    trigger_mode = PilatusTriggerMode.soft\n    \n    def __init__(self, prefix):\n        super().__init__(prefix=prefix, name=\"pil\")\n        self.dets = {\"pil1M\": self.pil1M, \"pilW1\": self.pilW1, \"pilW2\": self.pilW2}\n        if self.trigger_lock is None:\n            self.trigger_lock = threading.Lock()\n        for dname,det in self.dets.items():\n            det.name = dname\n            det.read_attrs = ['file']\n        self.active_detectors = list(self.dets.values())\n            \n        self._trigger_signal = EpicsSignal('XF:16IDC-ES{Zeb:1}:SOFT_IN:B0')\n        self._exp_completed = 0\n        if not \"pilatus\" in RE.md.keys():\n            RE.md['pilatus'] = {}\n        # ver 0, or none at all: filename template must be set by CBF file handler\n        # ver 1: filename template is already revised by the file plugin\n        RE.md['pilatus']['cbf_file_handler_ver'] = 0 \n        self.set_trigger_mode(PilatusTriggerMode.soft)\n        \n    def update_header(self, uid):\n        for det in self.active_detectors:\n            det.HeaderString.put(f\"uid={uid}\")\n\n    def activate(self, det_list):\n        \"\"\" e.g.\n            activate(['pil1M', 'pilW2'])\n        \"\"\"\n        for det in det_list:\n            if det not in self.dets.keys():\n                raise Exception(f\"{det} is not a known Pilatus detector.\")\n        self.active_detectors = [self.dets[d] for d in det_list]\n    \n    def set_trigger_mode(self, trigger_mode):\n        if isinstance(trigger_mode, PilatusTriggerMode):\n            self.trigger_mode = trigger_mode\n        else: \n            print(f\"invalid trigger mode: {trigger_mode}\")\n        RE.md['pilatus']['trigger_mode'] = trigger_mode.name\n        \n    def set_num_images(self, num, rep=1):\n        self._num_images = num\n        self._num_repeats = rep\n        \n    def number_reset(self, reset=True):\n        self.reset_file_number = reset\n        for det in self.dets.values():\n            det.file.file_number.put(0)\n        \n    def exp_time(self, exp):\n        for det_name in self.dets.keys():\n            self.dets[det_name].read_attrs = ['file']\n            self.dets[det_name].cam.acquire_time.put(exp)\n            self.dets[det_name].cam.acquire_period.put(exp+0.005)\n        self.acq_time = exp+0.005\n\n    def use_sub_directory(self, sd=None):\n        if sd is not None:\n            if sd[-1]!='/':\n                sd += '/'\n            makedirs(data_path+sd, mode=0o0777)\n            RE.md['subdir'] = PilatusFilePlugin.sub_directory\n            PilatusFilePlugin.sub_directory = sd\n        elif 'subdir' in RE.md.keys():\n            del RE.md['subdir'] \n            PilatusFilePlugin.sub_directory = sd\n        \n    def set_thresh(self):\n        ene = int(pseudoE.energy.position/10*0.5+0.5)*0.01\n        for det in self.dets.values():\n            det.set_thresh(ene)\n            \n    def stage(self):\n        if self._staged == Staged.yes:\n            return\n        change_path()\n        fno = np.max([det.file.file_number.get() for det in self.dets.values()])        \n        if self.reset_file_number:\n            fno = 1\n        for det in self.dets.values():\n            det.file.file_number.put(fno+1)\n            \n        for det in self.active_detectors:\n            det.stage(self.trigger_mode)\n            \n        if self.trigger_mode == PilatusTriggerMode.ext_multi:\n            # the name is misleading, multi_triger means one image per trigger\n            self.trig_wait = self.acq_time+0.02\n        else:\n            self.trig_wait = self.acq_time*self._num_images+0.02\n        \n    def unstage(self):\n        for det in self.active_detectors:\n            det.unstage()\n                \n    def trigger(self):\n        #if len(self.active_detectors)==0:\n        #    return\n        self._status = DeviceStatus(self)\n        if self.trigger_mode is not PilatusTriggerMode.soft:  \n            while self.trigger_lock.locked():\n                time.sleep(0.005)\n            print(\"generating triggering pulse ...\")\n            self._trigger_signal.put(1, wait=True)\n            self._trigger_signal.put(0, wait=True)\n        for det in self.active_detectors:\n            det.trigger()\n        if self.trigger_mode is not PilatusTriggerMode.soft:\n            # soft: status to be cleared by _acquire_changed()\n            # ext: set up callback to clear status after the end-of-exposure\n            threading.Timer(self.trig_wait, self._status._finished, ()).start()\n        # should advance the file number in external trigger mode???\n        \n        return self._status\n    \n    def repeat_ext_trigger(self, rep):\n        \"\"\" this is used to produce external triggers to complete data collection by camserver\n        \"\"\"\n        for i in reversed(range(rep)):\n            self._trigger_signal.put(1, wait=True)\n            self._trigger_signal.put(0, wait=True)\n            time.sleep(self.acq_time)\n            print(f\"# of triggers to go: {i} \\r\", end=\"\")\n\n    def _acquire_changed(self, value=None, old_value=None, **kwargs):\n        if old_value==1 and value==0:\n            self._exp_completed += 1\n        if self._exp_completed==len(self.active_detectors):\n            self._exp_completed = 0\n            self._status._finished()\n\n    def collect_asset_docs(self):\n        for det in self.active_detectors:\n            yield from det.collect_asset_docs()"
  },
  {
    "class_name": "HPLC",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/25-hplc.py",
    "source": "class HPLC(Device):\n    ready = Cpt(EpicsSignal, 'out')\n    injected = Cpt(EpicsSignalRO, 'in1')\n    done = Cpt(EpicsSignalRO, 'in2')\n    bypass = Cpt(EpicsSignal, '_bypass')\n    \n    def __init__(self, *args, read_filepath, write_filepath, **kwargs):\n        self.hplc_status = HPLCStatus.idle\n        self._injected_status = None\n        self._done_status = None\n        self._bypass_status = None\n        self._resource = None\n        self._read_filepath = read_filepath\n        self._write_filepath = write_filepath\n        super().__init__(*args, **kwargs)\n\n    def stage(self):\n        self.injected.subscribe(self._injected_changed)\n        self.done.subscribe(self._done_changed)\n        self.bypass.subscribe(self._bypass_changed)\n\n    def unstage(self):\n        self.injected.clear_sub(self._injected_changed)\n        self.done.clear_sub(self._done_changed)\n        self.bypass.clear_sub(self._bypass_changed)\n        self._injected_status = None\n        self._done_status = None\n        self._bypass_status = None\n        # self._resource = None\n\n    def kickoff(self):\n        \"\"\"\n        Set 'ready' to True and return a status object tied to 'injected'.\n        \"\"\"\n        self.ready.set(1)\n        self.hplc_status = HPLCStatus.waiting_injected\n        self._injected_status = DeviceStatus(self.injected)\n        self._done_status = DeviceStatus(self.done)\n        return self._injected_status\n\n    def complete(self):\n        \"\"\"\n        Return a status object tied to 'done'.\n        \"\"\"\n        if self._done_status is None:\n            raise RuntimeError(\"must call kickoff() before complete()\")\n        return self._done_status\n\n    def collect(self):\n        \"\"\"\n        Yield events that reference the data files generated by HPLC.\n        the HPLC run using a batch file should always export data into /nsls2/xf16id1/Windows/hplc_export.txt\n        \"\"\"\n\n        # in principle there are lots of things that can be saved\n        # for now just keep the chromatograms\n        sections = readShimadzuDatafile('/nsls2/xf16id1/Windows/hplc_export.txt', return_all_sections=True)\n        \n        import numpy as np\n        yield {'time': time.time(),\n               'seq_num': 1,\n               'data': {'foo': np.random.rand(2048, 1)},\n               'timestamps': {'foo': time.time()}}\n\n        # TODO Decide whether you want to 'chunk' the dataset into 'events'.\n        # Insert a datum per event and yield a partial event document.\n        #for i in range(1):\n        #    yield {'time': time.time(),\n        #           'seq_num': i+1,\n        #           'data': {'foo': np.random.rand(2048, 1)},  #datum_id},\n        #           'timestamps': {'foo': time.time()}}\n\n    def describe_collect(self):\n        return {self.name: {'foo': {'dtype': 'array',\n                             'shape': (2048,),\n                             'source': 'TO DO'}}}\n\n    def _injected_changed(self, value, old_value, **kwargs):\n        \"\"\"Mark the status object returned by 'kickoff' as finished when\n        injected goes from 0 to 1.\"\"\"\n        if self._injected_status is None:\n            return\n        if (old_value == 0) and (value == 1):\n            self.ready.set(0)\n            self.hplc_status = HPLCStatus.waiting_done\n            self._injected_status._finished()\n\n    def _done_changed(self, value, old_value, **kwargs):\n        \"\"\"Mark the status object returned by 'complete' as finished when\n        done goes from 0 to 1.\"\"\"\n        if self._done_status is None:\n            return\n        if (old_value == 0) and (value == 1):\n            self.hplc_status = HPLCStatus.idle\n            self._done_status._finished()\n\n    def _bypass_changed(self, value, old_value, **kwargs):\n        \"\"\"Mark the status object returned by 'complete' as finished when\n        done goes from 0 to 1.\"\"\"\n        if value == 0:\n            return\n        print('Bypass used: {}, hplc state: {}'.format(value, self.hplc_status))\n        if (value == 1) and self.hplc_status == HPLCStatus.waiting_injected:\n            self._injected_changed(1,0)\n        elif (value == 2) and self.hplc_status == HPLCStatus.waiting_done:\n            self._done_changed(1,0)\n        self.bypass.set(0)"
  },
  {
    "class_name": "XPStraj",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/2023Sep/25-XPS.py",
    "source": "class XPStraj(Device):\n    def __init__(self, controller, group):\n        \"\"\" controller is a XPS controller instance\n            fast_axis is a XPS motor name, e.g. scan.X\n        \"\"\"        \n        if not group in controller.groups.keys():\n            raise Exception(f\"{fast_axis} is not a valid motor\")\n        # also need to make sure that the group is a MultiAxis type\n            \n        super().__init__(name=controller.name+\"_traj\")\n        self.controller = controller\n        self.group = group\n        self.motors = {}\n        for m in controller.groups[group]:\n            if \"ophyd\" in controller.motors[m].keys():\n                self.motors[controller.motors[m]['ophyd'].name] = m\n        self.Nmot = len(self.motors.keys())\n        self.xps = controller.xps\n        self.sID = controller.sID\n        \n        self.verified = False\n        uname = getpass.getuser()\n        self.traj_files = [\"TrajScan_FW.trj-%s\" % uname, \"TrajScan_BK.trj-%s\" % uname]\n        self.traj_par = {'run_forward_traj': True, \n                         'no_of_segments': 0, \n                         'no_of_rampup_points': 0,\n                         'segment_displacement': 0,\n                         'segment_duration': 0,\n                         'motor': None,\n                         'rampup_distance': 0\n                        }\n        self.time_modified = time.time()\n        self.start_time = 0\n        self._traj_status = None\n        self.detectors = None\n        self.datum = None\n        self.flying_motor = None\n    \n    def stage(self):\n        self.datum = {}\n        self.aborted = False\n        self.clear_readback()\n\n    def unstage(self):\n        \"\"\" abort whatever is still going on??\n        \"\"\"\n        #self.abort_traj()\n        while self.moving():\n            time.sleep(0.2)\n        self._traj_status = None\n        \n    def read_configuration(self):\n        ret = [(k, {'value': val, \n                    'timestamp': self.time_modified}) for k, val in self.traj_par.items() if val is not None]\n        return OrderedDict(ret)\n        \n    def describe_configuration(self):\n        return {\n          k: {\"source\": \"trajectory_state\", \"dtype\": data_type(val), \"shape\": data_shape(val)}\n          for k, val\n          in self.traj_par.items()\n          if val is not None\n        }\n        \n    def select_forward_traj(self, op=True):\n        if op:\n            self.traj_par['run_forward_traj'] = True\n        else:\n            self.traj_par['run_forward_traj'] = False\n        \n    def moving(self):\n        if self.flying_motor is None:\n            return False\n        return self.flying_motor.moving\n    \n    def abort_traj(self):\n        if self.flying_motor is not None:\n            self.flying_motor.stop()\n        return\n        \n    def kickoff(self):\n        \"\"\"\n        run the trajectory\n        \"\"\"\n        if self.verified==False:\n            raise Exception(\"trajectory not defined/verified.\")\n        \n        self._traj_status = DeviceStatus(self)\n      \n        th = threading.Thread(target=self.exec_traj, args=(self.traj_par['run_forward_traj'], ) )\n        th.start() \n        return self._traj_status\n        \n    def complete(self):\n        \"\"\"\n            according to run_engine.py: Tell a flyer, 'stop collecting, whenever you are ready'.\n            Return a status object tied to 'done'.\n        \"\"\"\n        if self._traj_status is None:\n            raise RuntimeError(\"must call kickoff() before complete()\")\n        while not self._traj_status.done:\n            print(f\"{time.asctime()}: waiting for the trajectory to finish ...   \", end='')\n            time.sleep(1)\n        if self.aborted:\n            raise Exception(\"unable to complete the scan due to hardware issues ...\")\n        print(\"Done.\")\n             \n        return self._traj_status\n        \n    def collect_asset_docs(self):\n        \"\"\" when the run eigine process the \"collect\" message, 3 functions are called (see bluesky.bundlers)\n                collect_asset_docs(): returns resource and datum document (name, doc)\n                                      RE emit(DocumentNames(name), doc)\n                                      called once per scan? name is always \"resource\"?\n                describe_collect(): returns a dictionary of {stream_name: data_keys, ...}\n                                    RE emit(DocumentNames.descriptor, doc) \n                collect(): returns a list of events [ev, ...], \n                           RE emit(DocumentNames.event, ev) or add to bulk data for later emit() call\n            DocumentNames is defined in event_model, enum\n\n            followed HXN example\n        \"\"\"\n        asset_docs_cache = []\n        \n        for det in pil.active_detectors:\n            k = f'{det.name}_image'\n            print(list(det.hdf._asset_docs_cache))\n            (name, resource), = det.hdf.collect_asset_docs()\n            assert name == 'resource'\n            # hack the resource\n            resource['resource_kwargs']['frame_per_point'] = pil._num_images\n            asset_docs_cache.append(('resource', resource))\n            resource_uid = resource['uid']\n            datum_id = '{}/{}'.format(resource_uid, 0)\n            self.datum[k] = [datum_id, ttime.time()]\n            datum = {'resource': resource_uid,\n                     'datum_id': datum_id,\n                     'datum_kwargs': {'point_number': 0}}\n            asset_docs_cache.append(('datum', datum))\n        \n        return tuple(asset_docs_cache)\n        \n    def collect(self):\n        \"\"\"\n        this is the \"event\"???\n        save position data, called at the end of a scan (not at the end of a trajectory)\n        this is now recorded in self.readback, as accumulated by self.update_readback()\n        also include the detector image info\n        \"\"\"\n        now = time.time()\n        data = {}\n        ts = {}\n\n        # bandage solution for getting timestamps\n        # need to have ssh key on the data collection workstation\n        #fn0 = \"/tmp/data.log\"\n        #fn = pil.active_detectors[0].cam.full_file_name.get().rsplit(\"_\", maxsplit=1)[0]+\".log\"\n        #os.system(f\"scp det@{pil.active_detectors[0].hostname}:{fn} {fn0}\")\n        ##with open(fn.replace('ramdisk', 'exp_path')) as fh:\n        #with open(fn0) as fh:\n        #    lns = fh.read().split('\\n')[1:-2]\n        #timestamps = [datetime.fromisoformat(l.split()[0]).timestamp() for l in lns]\n\n        # the hdf file produced by areDetector contains the time stamp:\n        # entry/instrument/NDAttributes/NDArrayEpicsTSSec\n        # entry/instrument/NDAttributes/NDArrayEpicsTSnSec\n        # TSec + 1e-9*TnSec\n        # for now just save the time stamp from the readback\n        \n        data[self.traj_par['fast_axis']] = self.read_back['fast_axis']\n        ts[self.traj_par['fast_axis']] = self.read_back['timestamp']  # timestamps\n        if self.motor2 is not None:\n            data[self.traj_par['slow_axis']] = self.read_back['slow_axis']\n            ts[self.traj_par['slow_axis']] = self.read_back['timestamp2']\n        \n        for det in pil.active_detectors:\n            k = f'{det.name}_image'\n            (data[k], ts[k]) = self.datum[k]\n            for k,desc in det.read().items():\n                data[k] = desc['value']\n                ts[k] = desc['timestamp']\n\n        for det in [em2ext.ts.SumAll]: \n            for k,desc in det.read().items():\n                data[k] = self.read_back['em2'] #desc['value']\n                ts[k] = self.read_back['em2ts'] #desc['timestamp']            \n                \n        ret = {'time': time.time(),\n               'data': data,\n               'timestamps': ts,\n              }\n        \n        yield ret\n\n    def describe_collect(self):\n        '''Describe details for the flyer collect() method'''\n        ret = {}\n        ret[self.traj_par['fast_axis']] = {'dtype': 'number',\n                                           'shape': (len(self.read_back['fast_axis']),),\n                                           'source': 'PVT trajectory readback position'}\n        if self.motor2 is not None:\n            ret[self.traj_par['slow_axis']] = {'dtype': 'number',\n                                               'shape': (len(self.read_back['slow_axis']),),\n                                               'source': 'motor position readback'}\n        for det in pil.active_detectors:\n            ret[f'{det.name}_image'] = det.make_data_key()\n            ret[f'{det.name}_image']['shape'] = [pil._num_images, *ret[f'{det.name}_image']['shape'][1:]]\n            for k,desc in det.describe().items():\n                ret[k] = desc\n\n        for det in [em2ext.ts.SumAll]: \n            for k,desc in det.describe().items():\n                if k==em1.ts.SumAll.name:\n                    desc['shape'] = [self.traj_par['Nem1']]\n                if k==em2ext.ts.SumAll.name:\n                    desc['shape'] = [self.traj_par['Nem2']]\n                ret[k] = desc\n                \n        return {'primary': ret}\n        \n    def define_traj(self, motor, N, dx, dt, motor2=None, dy=0, Nr=2):\n        \"\"\" the idea is to use FW/BK trjectories in a scan\n            each trajactory involves a single motor only\n            relative motion, N segements of length dx from the current position\n            duration of each segment is dt\n            \n            Additional segments (Nr, at least 2) are required to ramp up and down, e.g.:\n            \n            # dt,  x,  v_out\n            1.0,  0.16667, 0.5\n            1.0,  1.0,     1.0\n            ... ...\n            1.0,  1.0,     1.0\n            1.0,  0.83333, 0.5\n            1.0,  0,0,     0.0\n            detector triggering should start from the 5th segment\n            \n        \"\"\"        \n        self.verified = False\n\n        if motor.name not in self.motors.keys():\n            # motor is an Ophyd device \n            print(f\"{motor.name} not in the list of motors: \", self.motors)\n            raise Exception\n        self.flying_motor = self.controller.motors[self.motors[motor.name]]['ophyd']\n        \n        err,ret = self.xps.PositionerMaximumVelocityAndAccelerationGet(self.sID, self.motors[motor.name])\n        mvel,macc = np.asarray(ret.split(','), dtype=float)\n        midx = self.controller.motors[self.motors[motor.name]]['index']\n        \n        jj = np.zeros(Nr+N+Nr)\n        jj[0] = 1; jj[Nr-1] = -1\n        jj[-1] = 1; jj[-Nr] = -1\n        # these include the starting state of acc=vel=disp=0\n        disp = np.zeros(Nr+N+Nr+1)\n        vel = np.zeros(Nr+N+Nr+1)\n        acc = np.zeros(Nr+N+Nr+1)\n\n        for i in range(N+2*Nr):\n            acc[i+1] = acc[i] + jj[i]*dt\n            vel[i+1] = vel[i] + acc[i]*dt + jj[i]*dt*dt/2\n            disp[i+1] = vel[i]*dt + acc[i]*dt*dt/2 + jj[i]*dt*dt*dt/6\n        vel = vel/vel.max()*dx/dt\n        disp = disp/disp.max()*dx\n        self.ramp_dist = disp[1:Nr+1].sum()\n        \n        # rows in a PVT trajectory file correspond ot the segments  \n        # for each row/segment, the elements are\n        #     time, axis 1 displancement, axis 1 velocity out, axsi 2 ... \n        ot1 = np.zeros((Nr+N+Nr, 1+2*self.Nmot))\n        ot1[:, 0] = dt\n        ot1[:, 2*midx+1] = disp[1:] \n        ot1[:, 2*midx+2] = vel[1:] \n        ot2 = np.zeros((Nr+N+Nr, 1+2*self.Nmot))\n        ot2[:, 0] = dt\n        ot2[:, 2*midx+1] = -disp[1:] \n        ot2[:, 2*midx+2] = -vel[1:] \n        \n        np.savetxt(\"/tmp/\"+self.traj_files[0], ot1, fmt='%f', delimiter=', ')\n        np.savetxt(\"/tmp/\"+self.traj_files[1], ot2, fmt='%f', delimiter=', ')\n        ftp = FTP(self.controller.ip_addr)\n        ftp.connect()\n        ftp.login(\"Administrator\", \"Administrator\")\n        ftp.cwd(\"Public/Trajectories\")\n        for fn in self.traj_files:\n            file = open(\"/tmp/\"+fn, \"rb\")\n            ftp.storbinary('STOR %s' % fn, file)\n            file.close()\n        ftp.quit()\n        \n        for fn in self.traj_files:\n            err,ret = self.xps.MultipleAxesPVTVerification(self.sID, self.group, fn)\n            if err!='0':\n                print(ret)\n                raise Exception(\"trajectory verification failed.\")\n            err,ret = self.xps.MultipleAxesPVTVerificationResultGet (self.sID, self.motors[motor.name])\n        self.verified = True\n        self.traj_par = {'run_forward_traj': True, \n                         'no_of_segments': N, \n                         'no_of_rampup_points': Nr,\n                         'segment_displacement': dx,\n                         'segment_duration': dt,\n                         'motor': self.motors[motor.name],\n                         'rampup_distance': self.ramp_dist,\n                         'motor2_disp': dy,\n                        }\n        self.traj_par['fast_axis'] = motor.name\n        self.motor2 = motor2\n        if motor2 is not None:\n            self.traj_par['slow_axis'] = motor2.name\n        self.time_modified = time.time()\n        \n    def exec_traj(self, forward=True, clean_event_queue=False, n_retry=5):\n        \"\"\"\n           execuate either the foward or backward trajectory\n        \"\"\"\n        if self.verified==False:\n            raise Exception(\"trajectory not defined/verified.\")\n\n        N = self.traj_par['no_of_segments']\n        Nr = self.traj_par['no_of_rampup_points']\n        motor = self.traj_par['motor']\n        dt = self.traj_par['segment_duration']\n        \n        if forward: \n            traj_fn = self.traj_files[0]\n        else:\n            traj_fn = self.traj_files[1]\n        \n        print(\"moving into starting position ...\")\n        pos = (self.traj_par['ready_pos'][0] if forward else self.traj_par['ready_pos'][1])\n        err,ret = self.xps.GroupMoveAbsolute(self.sID, self.traj_par['motor'], [pos])\n            \n        # otherwise starting the trajectory might generate an error\n        while self.moving():\n            time.sleep(0.2)\n        \n        print(\"executing trajectory ...\")\n        # first set up gathering\n        self.xps.GatheringReset(self.sID)        \n        # pulse is generated when the positioner enters the segment\n        print(\"starting a trajectory with triggering parameters: %d, %d, %.3f ...\" % (Nr+1, N+Nr+1, dt))\n        self.xps.MultipleAxesPVTPulseOutputSet(self.sID, self.group, Nr+1, N+Nr+1, dt)\n        self.xps.MultipleAxesPVTVerification(self.sID, self.group, traj_fn)\n        self.xps.GatheringConfigurationSet(self.sID, [motor+\".CurrentPosition\"])        \n        self.xps.EventExtendedConfigurationTriggerSet(self.sID,\n                                                      [\"Always\", f\"{self.group}.PVT.TrajectoryPulse\"],\n                                                      [\"0\", \"0\"], [\"0\", \"0\"], [\"0\", \"0\"], [\"0\", \"0\"])\n        self.xps.EventExtendedConfigurationActionSet(self.sID,\n                                                     [\"GatheringOneData\"], [\"0\"], [\"0\"], [\"0\"], [\"0\"])\n                \n        # all trigger event for gathering should be removed\n        if clean_event_queue:\n            err,ret = self.xps.EventExtendedAllGet(self.sID)\n            if err=='0':\n                for ev in ret.split(';'):\n                    self.xps.EventExtendedRemove(self.sID, ev) \n        eID = self.xps.EventExtendedStart(self.sID)[1]\n        self.start_time = time.time()\n        \n        [err, ret] = self.xps.MultipleAxesPVTExecution(self.sID, self.group, traj_fn, 1)\n        if err!='0':\n            self.safe_stop()\n            print(\"motion group re-initialized ...\")\n            #    break\n            print(f'An error (code {err}) as occured when starting trajectory execution') #, retry #{i+1} ...')\n            #if err=='-22': # Group state must be READY                \n            [err, ret] = self.xps.GroupMotionEnable(self.sID, self.group)\n            print(f\"attempted to re-enable motion group: \", end='')\n            time.sleep(1)\n        \n        if not self.aborted:\n            self.xps.GatheringStopAndSave(self.sID)\n            self.xps.EventExtendedRemove(self.sID, eID)\n            self.update_readback()\n            print('end of trajectory execution, ', end='')\n\n        if self._traj_status != None:\n            self._traj_status._finished()\n\n        # for testing only\n        #if caget('XF:16IDC-ES:XPSAux1Bi0'):\n        #    self.aborted = True\n            \n    def safe_stop(self):\n        fast_shutter.close()\n        ## needs work\n        return\n        \n        # generate enough triggers to complete exposure \n        #det = self.detectors[0]\n        det = pil.active_detectors[0]\n        Ni = det.cam.num_images.get() \n        Nc = det.cam.array_counter.get()\n        pil.repeat_ext_trigger(Ni-Nc)\n        \"\"\"for i in range(Ni-Nc):\n            det.trigger()\n            print('%d more data points to complete exposure ...   ' % (Ni-Nc-i), end='\\r')\n            time.sleep(self.traj_par['segment_duration'])     \n        \"\"\"\n        st = self.xps.GroupStatusGet(self.sID, self.group) \n        if st==['0', '1']: # group likely need initilization and homing\n            self.xps.GroupInitialize(self.sID, self.group)\n            time.sleep(1)\n            st = self.xps.GroupStatusGet(self.sID, self.group)\n            if st==['0', '42']: # ready for home search\n                self.xps.GroupHomeSearch(self.sID, self.group) \n                time.sleep(1)\n                st = self.xps.GroupStatusGet(self.sID, self.group)\n                if st==['0', '11']: # home search successful \n                    print('stages re-initialized ... ')\n        \n        self.aborted = True\n        if self._traj_status != None:\n            self._traj_status._finished()\n        print(\"giving up the current scan ...\")\n        raise Exception('a hardware error has occured, aborting ... ')\n    \n    def readback_traj(self):\n        print('reading back trajectory ...')\n        err,ret = self.xps.GatheringCurrentNumberGet(self.sID)\n        ndata = int(ret.split(',')[0])\n        err,ret = self.xps.GatheringDataMultipleLinesGet(self.sID, 0, ndata)\n        return [float(p) for p in ret.split('\\n') if p!='']\n    \n    def clear_readback(self):\n        self.read_back = {}\n        self.read_back['fast_axis'] = []\n        self.read_back['timestamp'] = []\n        self.read_back['em2'] = []\n        self.read_back['em2ts'] = []\n        if self.motor2 is not None:\n            self.read_back['slow_axis'] = []\n            self.read_back['timestamp2'] = []\n        \n    def update_readback(self):\n        pos = self.readback_traj()\n        # start_time is the beginning of the execution\n        # pulse is generated when the positioner enters the segment ??\n        # timestamp correspond to the middle of the segment\n        N = self.traj_par['no_of_segments']\n        Nr = self.traj_par['no_of_rampup_points']\n        dt = self.traj_par['segment_duration']\n        ts = self.start_time + (0.5 + Nr + np.arange(N+1))*dt\n        if len(pos)!=N+1:\n            print(f\"Warning: incorrect readback length {len(pos)}, expecting {N+1}\")\n            print(pos)\n        self.read_back['fast_axis'] += pos\n        self.read_back['timestamp'] += list(ts)\n        caput(em2ext.ts.prefix+\"TSRead\", 1)\n        time.sleep(1)\n        em2d = em2ext.ts.SumAll.read()['em2_ts_SumAll']\n        self.read_back['em2'].extend(em2d['value'][:self.traj_par['Nfast']])  # data legnth is always 2048 \n        self.read_back['em2ts'].append(em2d['timestamp'])\n        if self.motor2 is not None:\n            self.read_back['slow_axis'].append(self.motor2.position)\n            self.read_back['timestamp2'].append(time.time())"
  },
  {
    "class_name": "LiXDetectors",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/2023Sep/20-pilatus.py",
    "source": "class LiXDetectors(Device):\n    pil1M = Cpt(LIXPilatus, '{Det:SAXS}', name=\"pil1M\", detector_id=\"SAXS\", hostname=\"xf16idc-pilatus1m.nsls2.bnl.local\")\n    #pilW1 = Cpt(LIXPilatus, '{Det:WAXS1}', name=\"pilW1\", detector_id=\"WAXS1\", hostname=\"xf16idc-pilatus300k1.nsls2.bnl.local\")\n    pilW2 = Cpt(LIXPilatus, '{Det:WAXS2}', name=\"pilW2\", detector_id=\"WAXS2\", hostname=\"xf16idc-pilatus900k.nsls2.bnl.local\")\n    trigger_lock = None\n    reset_file_number = True\n    _num_images = 1\n    _num_repeats = 1\n    active_detectors = []\n    trig_wait = 1.\n    acq_time = 1.\n    trigger_mode = PilatusTriggerMode.soft\n\n\n    def __init__(self, prefix):\n        super().__init__(prefix=prefix, name=\"pil\")\n        self.dets = {\"pil1M\": self.pil1M,  \"pilW2\": self.pilW2} # \"pilW1\": self.pilW1,\n        #self.dets = {\"pilW2\": self.pilW2}\n        if self.trigger_lock is None:\n            self.trigger_lock = threading.Lock()\n        for dname,det in self.dets.items():\n            det.name = dname\n            det.read_attrs = ['hdf'] #['file']\n        self.active_detectors = list(self.dets.values())\n        self.trigger_time = Signal(name=\"pilatus_trigger_time\")\n\n        self._trigger_signal = EpicsSignal('XF:16IDC-ES{Zeb:1}:SOFT_IN:B0')\n        self._exp_completed = 0\n\n        RE.md['pilatus'] = {}\n        RE.md['pilatus']['ramdisk'] = pilatus_data_dir\n\n        # ver 0, or none at all: filename template must be set by CBF file handler\n        # ver 1: filename template is already revised by the file plugin\n        #RE.md['pilatus']['cbf_file_handler_ver'] = 0\n\n    def update_cbf_name(self, cn=None):\n        for det in self.active_detectors:\n            det.update_cbf_name(cn)\n\n    def update_header(self, uid):\n        for det in self.active_detectors:\n            det.HeaderString.put(f\"uid={uid}\")\n\n    def activate(self, det_list):\n        \"\"\" e.g.\n            activate(['pil1M', 'pilW2'])\n        \"\"\"\n        for det in det_list:\n            if det not in self.dets.keys():\n                raise Exception(f\"{det} is not a known Pilatus detector.\")\n        self.active_detectors = [self.dets[d] for d in det_list]\n        RE.md['pilatus']['active_detectors'] = [d.name for d in self.active_detectors]\n\n    def set_trigger_mode(self, trigger_mode):\n        if isinstance(trigger_mode, PilatusTriggerMode):\n            self.trigger_mode = trigger_mode\n        else:\n            print(f\"invalid trigger mode: {trigger_mode}\")\n        RE.md['pilatus']['trigger_mode'] = trigger_mode.name\n\n    def set_num_images(self, num, rep=1):\n        self._num_images = num\n        self._num_repeats = rep\n        RE.md['pilatus']['num_images'] = [num, rep]\n\n    def number_reset(self, reset=True):\n        self.reset_file_number = reset\n        if reset:\n            for det in self.dets.values():\n                det.cbf_file_number.put(0)\n                det.hdf.file_number.put(0)\n\n    def exp_time(self, exp):\n        for det_name in self.dets.keys():\n            self.dets[det_name].read_attrs = ['hdf']\n            self.dets[det_name].cam.acquire_time.put(exp)\n            self.dets[det_name].cam.acquire_period.put(exp+0.005)\n        self.acq_time = exp+0.005\n        RE.md['pilatus']['exposure_time'] = exp\n\n\n    def use_sub_directory(self, sd=None):\n        if sd is not None:\n            if sd[-1]!='/':\n                sd += '/'\n            #makedirs(data_path+sd, mode=0o0777)\n            LIXhdfPlugin.sub_directory = sd\n            RE.md['subdir'] = LIXhdfPlugin.sub_directory\n        elif 'subdir' in RE.md.keys():\n            del RE.md['subdir'] \n            LIXhdfPlugin.sub_directory = sd\n\n    def set_thresh(self):\n        ene = int(pseudoE.energy.position/100*0.5+0.5)*0.1\n        for det in self.active_detectors: #self.dets.values():\n            det.set_thresh(ene)\n\n    def stage(self):\n        if self._staged == Staged.yes:\n            return\n        change_path()\n        fno = np.max([det.cbf_file_number.get() for det in self.dets.values()])\n        if self.reset_file_number:\n            fno = 1\n        for det in self.dets.values():\n            det.cbf_file_number.put(fno+1)\n\n        for det in self.active_detectors:\n            det.stage(self.trigger_mode)\n\n        if self.trigger_mode == PilatusTriggerMode.ext_multi:\n            # the name is misleading, multi_triger means one image per trigger\n            self.trig_wait = self.acq_time+0.02\n        else:\n            self.trig_wait = self.acq_time*self._num_images+0.02\n\n    def unstage(self):\n        for det in self.active_detectors:\n            det.unstage()\n\n    def trigger(self):\n        #if len(self.active_detectors)==0:\n        #    return\n        self._status = DeviceStatus(self)\n        if self.trigger_mode is not PilatusTriggerMode.soft:\n            while self.trigger_lock.locked():\n                time.sleep(0.005)\n            self.trigger_time.put(time.time())\n            print(\"generating triggering pulse ...\")\n            self._trigger_signal.put(1, wait=True)\n            self._trigger_signal.put(0, wait=True)\n        for det in self.active_detectors:\n            det.trigger()\n        if self.trigger_mode is not PilatusTriggerMode.soft:\n            # soft: status to be cleared by _acquire_changed()\n            # ext: set up callback to clear status after the end-of-exposure\n            threading.Timer(self.trig_wait, self._status._finished, ()).start()\n        # should advance the file number in external trigger mode???\n\n       \treturn self._status\n\n    def repeat_ext_trigger(self, rep):\n        \"\"\" this is used to produce external triggers to complete data collection by camserver\n        \"\"\"\n        for i in reversed(range(rep)):\n            self._trigger_signal.put(1, wait=True)\n            self._trigger_signal.put(0, wait=True)\n            time.sleep(self.acq_time)\n            print(f\"# of triggers to go: {i} \\r\", end=\"\")\n\n    def _acquire_changed(self, value=None, old_value=None, **kwargs):\n        if old_value==1 and value==0:\n            self._exp_completed += 1\n        if self._exp_completed==len(self.active_detectors):\n            self._exp_completed = 0\n            self._status._finished()\n\n    def collect_asset_docs(self):\n        for det in self.active_detectors:\n            yield from det.collect_asset_docs()"
  },
  {
    "class_name": "Best",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/2023Sep/20-bpm.py",
    "source": "class Best(Device):\n    x_mean  = Cpt(EpicsSignal, ':BPM0:PosX_Mean')\n    posx = Cpt(EpicsSignal, ':BPM0:PosX')\n    x_std = Cpt(EpicsSignal, ':BPM0:PosX_Std')\n    y_mean  = Cpt(EpicsSignal,':BPM0:PosY_Mean')\n    posy  = Cpt(EpicsSignal,':BPM0:PosY')\n    y_std = Cpt(EpicsSignal, ':BPM0:PosY_Std')\n    int_mean  = Cpt(EpicsSignal, ':BPM0:Int_Mean')\n    int_std = Cpt(EpicsSignal, ':BPM0:Int_Std')\n    ch1 = Cpt(EpicsSignal, ':TetrAMM0:Ch1')\n    ch2 = Cpt(EpicsSignal, ':TetrAMM0:Ch2')\n    ch3 = Cpt(EpicsSignal, ':TetrAMM0:Ch3')\n    ch4 = Cpt(EpicsSignal, ':TetrAMM0:Ch4')\n    acquire_time = Cpt(Signal, name='time', value=1)\n\n    def trigger(self):\n        #TODO: modify settle_time to be from a acquiretime pv\n        acq_time = self.acquire_time.get()\n        _status = DeviceStatus(self, settle_time=acq_time)\n        _status._finished(success=True)\n        return _status"
  },
  {
    "class_name": "TimeSeries",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/obsolete/2023Sep/20-bpm.py",
    "source": "class TimeSeries(Device):\n    SumAll = ADCpt(EpicsSignalRO, \"SumAll:TimeSeries\", kind='normal')\n    current1 = ADCpt(EpicsSignalRO, \"Current1:TimeSeries\", kind='normal')\n    current2 = ADCpt(EpicsSignalRO, \"Current2:TimeSeries\", kind='normal')\n    current3 = ADCpt(EpicsSignalRO, \"Current3:TimeSeries\", kind='normal')\n    current4 = ADCpt(EpicsSignalRO, \"Current4:TimeSeries\", kind='normal')\n\n    acquire = ADCpt(EpicsSignal, \"TSAcquire\", kind='omitted')\n    acquire_mode = ADCpt(EpicsSignal, \"TSAcquireMode\", string=True, kind='config')\n    acquiring = ADCpt(EpicsSignalRO, \"TSAcquiring\", kind='omitted')\n\n    time_axis = ADCpt(EpicsSignalRO, \"TSTimeAxis\", kind='config')\n    read_rate = ADCpt(EpicsSignal, \"TSRead.SCAN\", string=True, kind='config')\n    num_points = ADCpt(EpicsSignal, \"TSNumPoints\", kind='config')\n    averaging_time = ADCpt(EpicsSignalWithRBV, \"TSAveragingTime\", kind=\"config\")\n    current_point = ADCpt(EpicsSignalRO, \"TSCurrentPoint\", kind=\"omitted\")"
  },
  {
    "class_name": "SolutionScatteringControlUnit",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/experiments/25-EM_sol.py",
    "source": "class SolutionScatteringControlUnit(Device):\n    reset_pump = Cpt(EpicsSignal, 'pp1c_reset')\n    halt_pump = Cpt(EpicsSignal, 'pp1c_halt')\n    piston_pos = Cpt(EpicsSignal, 'pp1c_piston_pos')\n    valve_pos = Cpt(EpicsSignal, 'pp1c_valve_pos')\n    pump_spd = Cpt(EpicsSignal, 'pp1c_spd')\n    status = Cpt(EpicsSignal, 'pp1c_status')\n    water_pump = Cpt(EpicsSignal, \"sv_water\")\n    water_pump_spd = Cpt(EpicsSignal, \"water_pump_spd\")\n    sv_sel = Cpt(EpicsSignal, \"sv_sel\")\n    sv_N2 = Cpt(EpicsSignal, \"sv_N2\")\n    sv_drain1 = Cpt(EpicsSignal, \"sv_drain1\")\n    sv_drain2 = Cpt(EpicsSignal, \"sv_drain2\")\n    sv_pcr_tubes = Cpt(EpicsSignal, \"sv_pcr_tubes\")\n    sv_solenoid = Cpt(EpicsSignal, \"sv_solenoid\")\n    #sampleT = Cpt(EpicsSignal, \"sample_temp\")\n    #sampleTs = Cpt(EpicsSignal, \"sample_temp_SP\")\n    #sampleTCsts = Cpt(EpicsSignal, \"sample_TCsts\")\n    vc_4port = Cpt(EpicsSignal, \"vc_4port_valve\")\n    serial_busy = Cpt(EpicsSignal, \"busy\")\n    ready = Cpt(EpicsSignal, \"ready\")\n    pause_request = Cpt(EpicsSignal, \"pause\")\n \n    def halt(self):\n        self.halt_pump.put(1)\n        self.water_pump.put('off')\n        self.sv_N2.put('off')\n        self.sv_drain1.put('off')\n        self.sv_drain2.put('off')\n        self.sv_solenoid.put('off')\n        \n    def reset(self):\n        self.reset_pump.put(1)\n        \n    def wait(self):\n        while True:\n            if self.status.get()==0 and self.serial_busy.get()==0:\n                break\n            sleep(0.5)\n\n    def pump_mvA(self, des):\n        self.piston_pos.put(des)\n    def pump_mvR(self, dV):\n        cur = self.piston_pos.get()\n        self.piston_pos.put(cur+dV)\n\n    def delayed_mvR(self, dV):\n        cur = self.piston_pos.get()\n        while self.ready.get()==0:\n            sleep(.1)\n        self.ready.put(0)\n        self.piston_pos.put(cur+dV)\n        \n    def delayed_oscill_mvR(self, dV, times):\n        cur = self.piston_pos.get()\n        dO=dV-10\n        #self.piston_pos.put(cur+3)\n        dV=dV-10\n        while self.ready.get()==0:\n            sleep(.2)\n        self.ready.put(0)\n        for n in range(times):\n            cur1 = self.piston_pos.get()\n            self.piston_pos.put(cur1+dV)\n            self.wait()\n            dV=-dO"
  },
  {
    "class_name": "ZebraPositionCaptureData",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-zebra.py",
    "source": "class ZebraPositionCaptureData(Device):\n    \"\"\"\n    Data arrays for the Zebra position capture function and their metadata.\n    \"\"\"\n\n    # Data arrays\n    div1 = Cpt(EpicsSignal, \"PC_DIV1\")\n    div2 = Cpt(EpicsSignal, \"PC_DIV2\")\n    div3 = Cpt(EpicsSignal, \"PC_DIV3\")\n    div4 = Cpt(EpicsSignal, \"PC_DIV4\")\n    enc1 = Cpt(EpicsSignal, \"PC_ENC1\")\n    enc2 = Cpt(EpicsSignal, \"PC_ENC2\")\n    enc3 = Cpt(EpicsSignal, \"PC_ENC3\")\n    enc4 = Cpt(EpicsSignal, \"PC_ENC4\")\n    filt1 = Cpt(EpicsSignal, \"PC_FILT1\")\n    filt2 = Cpt(EpicsSignal, \"PC_FILT2\")\n    filt3 = Cpt(EpicsSignal, \"PC_FILT3\")\n    filt4 = Cpt(EpicsSignal, \"PC_FILT4\")\n    time = Cpt(EpicsSignal, \"PC_TIME\")\n    # Array sizes\n    num_cap = Cpt(EpicsSignal, \"PC_NUM_CAP\")\n    num_down = Cpt(EpicsSignal, \"PC_NUM_DOWN\")\n    # BOOLs to denote arrays with data\n    cap_enc1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B0\")\n    cap_enc2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B1\")\n    cap_enc3_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B2\")\n    cap_enc4_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B3\")\n    cap_filt1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B4\")\n    cap_filt2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B5\")\n    cap_div1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B6\")\n    cap_div2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B7\")\n    cap_div3_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B8\")\n    cap_div4_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B9\")\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "ZebraPositionCapture",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-zebra.py",
    "source": "class ZebraPositionCapture(Device):\n    \"\"\"\n    Signals for the position capture function of the Zebra\n    \"\"\"\n\n    # Configuration settings and status PVs\n    enc = Cpt(EpicsSignalWithRBV, \"PC_ENC\")\n    egu = Cpt(EpicsSignalRO, \"M1:EGU\")\n    dir = Cpt(EpicsSignalWithRBV, \"PC_DIR\")\n    tspre = Cpt(EpicsSignalWithRBV, \"PC_TSPRE\")\n    trig_source = Cpt(EpicsSignalWithRBV, \"PC_ARM_SEL\")\n    arm = Cpt(EpicsSignal, \"PC_ARM\")\n    disarm = Cpt(EpicsSignal, \"PC_DISARM\")\n    armed = Cpt(EpicsSignalRO, \"PC_ARM_OUT\")\n    gate_source = Cpt(EpicsSignalWithRBV, \"PC_GATE_SEL\")\n    gate_start = Cpt(EpicsSignalWithRBV, \"PC_GATE_START\")\n    gate_width = Cpt(EpicsSignalWithRBV, \"PC_GATE_WID\")\n    gate_step = Cpt(EpicsSignalWithRBV, \"PC_GATE_STEP\")\n    gate_num = Cpt(EpicsSignalWithRBV, \"PC_GATE_NGATE\")\n    gated = Cpt(EpicsSignalRO, \"PC_GATE_OUT\")\n    pulse_source = Cpt(EpicsSignalWithRBV, \"PC_PULSE_SEL\")\n    pulse_start = Cpt(EpicsSignalWithRBV, \"PC_PULSE_START\")\n    pulse_width = Cpt(EpicsSignalWithRBV, \"PC_PULSE_WID\")\n    pulse_step = Cpt(EpicsSignalWithRBV, \"PC_PULSE_STEP\")\n    pulse_max = Cpt(EpicsSignalWithRBV, \"PC_PULSE_MAX\")\n    pulse = Cpt(EpicsSignalRO, \"PC_PULSE_OUT\")\n    \n    # the PVs for these 4 are manually added to the Zebra IOC at LiX\n    enc_mot1_prefix = Cpt(EpicsSignal, \"M1:PREFIX\")\n    enc_mot2_prefix = Cpt(EpicsSignal, \"M2:PREFIX\")\n    enc_mot3_prefix = Cpt(EpicsSignal, \"M3:PREFIX\")\n    enc_mot4_prefix = Cpt(EpicsSignal, \"M4:PREFIX\")\n    \n    enc_pos1_sync = Cpt(EpicsSignal, \"M1:SETPOS.PROC\")\n    enc_pos2_sync = Cpt(EpicsSignal, \"M2:SETPOS.PROC\")\n    enc_pos3_sync = Cpt(EpicsSignal, \"M3:SETPOS.PROC\")\n    enc_pos4_sync = Cpt(EpicsSignal, \"M4:SETPOS.PROC\")\n    enc_res1 = Cpt(EpicsSignal, \"M1:MRES\")\n    enc_res2 = Cpt(EpicsSignal, \"M2:MRES\")\n    enc_res3 = Cpt(EpicsSignal, \"M3:MRES\")\n    enc_res4 = Cpt(EpicsSignal, \"M4:MRES\")\n    enc_off1 = Cpt(EpicsSignal, \"M1:OFF\")\n    enc_off2 = Cpt(EpicsSignal, \"M2:OFF\")\n    enc_off3 = Cpt(EpicsSignal, \"M3:OFF\")\n    enc_off4 = Cpt(EpicsSignal, \"M4:OFF\")\n    data_in_progress = Cpt(EpicsSignalRO, \"ARRAY_ACQ\")\n    block_state_reset = Cpt(EpicsSignal, \"SYS_RESET.PROC\")\n    data = Cpt(ZebraPositionCaptureData, \"\")\n\n    def stage(self):\n        self.arm.put(1)\n\n        super().stage()\n\n    def unstage(self):\n        self.disarm.put(1)\n        self.block_state_reset.put(1)\n\n        super().unstage()"
  },
  {
    "class_name": "ZebraOR",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-zebra.py",
    "source": "class ZebraOR(Device):\n    use1 = Cpt(EpicsSignal, '_ENA:B0')\n    use2 = Cpt(EpicsSignal, '_ENA:B1')\n    use3 = Cpt(EpicsSignal, '_ENA:B2')\n    use4 = Cpt(EpicsSignal, '_ENA:B3')\n    input_source1 = Cpt(EpicsSignal, '_INP1')\n    input_source2 = Cpt(EpicsSignal, '_INP2')\n    input_source3 = Cpt(EpicsSignal, '_INP3')\n    input_source4 = Cpt(EpicsSignal, '_INP4')\n    invert1 = Cpt(EpicsSignal, '_INV:B0')\n    invert2 = Cpt(EpicsSignal, '_INV:B1')\n    invert3 = Cpt(EpicsSignal, '_INV:B2')\n    invert4 = Cpt(EpicsSignal, '_INV:B3')\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "ZebraAND",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-zebra.py",
    "source": "class ZebraAND(Device):\n    # I really appreciate the different indexing for input source\n    # Thank you for that\n    use1 = Cpt(EpicsSignal, '_ENA:B0')\n    use2 = Cpt(EpicsSignal, '_ENA:B1')\n    use3 = Cpt(EpicsSignal, '_ENA:B2')\n    use4 = Cpt(EpicsSignal, '_ENA:B3')\n    input_source1 = Cpt(EpicsSignal, '_INP1')\n    input_source2 = Cpt(EpicsSignal, '_INP2')\n    input_source3 = Cpt(EpicsSignal, '_INP3')\n    input_source4 = Cpt(EpicsSignal, '_INP4')\n    invert1 = Cpt(EpicsSignal, '_INV:B0')\n    invert2 = Cpt(EpicsSignal, '_INV:B1')\n    invert3 = Cpt(EpicsSignal, '_INV:B2')\n    invert4 = Cpt(EpicsSignal, '_INV:B3')\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "ZebraPulse",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-zebra.py",
    "source": "class ZebraPulse(Device):\n    width = Cpt(EpicsSignalWithRBV, 'WID')\n    input_addr = Cpt(EpicsSignalWithRBV, 'INP')\n    input_str = Cpt(EpicsSignalRO, 'INP:STR', string=True)\n    input_status = Cpt(EpicsSignalRO, 'INP:STA')\n    delay = Cpt(EpicsSignalWithRBV, 'DLY')\n    delay_sync = Cpt(EpicsSignal, 'DLY:SYNC')\n    time_units = Cpt(EpicsSignalWithRBV, 'PRE', string=True)\n    output = Cpt(EpicsSignal, 'OUT')\n\n    input_edge = FC(EpicsSignal,\n                    '{self._zebra_prefix}POLARITY:{self._edge_addr}')\n\n    _edge_addrs = {1: 'BC',\n                   2: 'BD',\n                   3: 'BE',\n                   4: 'BF',\n                   }\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['input_addr', 'input_edge', 'delay', 'width', 'time_units']\n        if configuration_attrs is None:\n            configuration_attrs = []\n\n        zebra = parent\n        self.index = index\n        self._zebra_prefix = zebra.prefix\n        self._edge_addr = self._edge_addrs[index]\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, parent=parent, **kwargs)"
  },
  {
    "class_name": "Transfocator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/15-transfocator.py",
    "source": "class Transfocator(Device):\n    #za = Cpt(EpicsMotor,'-Ax:Z}Mtr')\n    z = Cpt(EpicsMotor,'-Ax:Z}Mtr')\n    x1 = Cpt(EpicsMotor,'-Ax:UX}Mtr')\n    y1 = Cpt(EpicsMotor,'-Ax:UY}Mtr')\n    x2 = Cpt(EpicsMotor,'-Ax:DX}Mtr')\n    y2 = Cpt(EpicsMotor,'-Ax:DY}Mtr')\n    busy = Cpt(EpicsSignalRO, \"}busy\")\n    saved_states = {}\n    current_state = None\n\n    def __init__(self, prefix, num_lens_group, name):\n        super().__init__(prefix, name=name)\n        self.lens_group = []\n        self.lens_group_config = []\n        self.num_lens_group = num_lens_group\n        for i in range(num_lens_group):\n            self.lens_group.append(EpicsSignal(prefix+\":%d}sts\" % (i+1)))\n            self.lens_group_config.append(caget(prefix+(':%d}config' % (i+1))))\n        self.current_state = [self.lens_group[i].get() for i in range(self.num_lens_group)]\n            \n    def wait(self):\n        while self.busy.get()>0:   \n            sleep(0.2)\n    \n    def state(self):\n        self.get_state(silent=True)\n        return self.current_state\n    \n    def get_state(self, silent=False):\n        if not silent:\n            print(\"inserted lens groups:\")\n        for i in range(self.num_lens_group):\n            self.current_state[i] = self.lens_group[i].get()\n            if self.current_state[i]==state_inserted and not silent:\n                print(\"\\tgroup %d: %s\" % (i+1, self.lens_group_config[i]))\n        \n        if not 'CRL' in RE.md['CRL'].keys():\n            RE.md['CRL'] = {}\n        RE.md['CRL']['state'] = self.current_state\n                \n    def get_focal_length(self):\n        pass\n    \n    def set_focal_length(self):\n        pass\n    \n    def insert_grp(self, grp):\n        if grp<1 or grp>self.num_lens_group:\n            print(\"invalid lens group: # %d\" % grp)\n            return\n        self.lens_group[grp-1].put(state_inserted)\n        self.wait()\n        self.get_state(silent=True)\n        \n    def remove_grp(self, grp):\n        if grp<1 or grp>self.num_lens_group:\n            print(\"invalid lens group: # %d\" % grp)\n            return\n        self.lens_group[grp-1].put(state_removed)\n        self.wait()  \n        self.get_state(silent=True)\n        \n    def restore_state(self, name=\"last\"):\n        for i in range(len(self.saved_states[name])):\n            self.lens_group[i].put(self.saved_states[name][i])\n            self.wait()\n        self.get_state(silent=True)\n        \n    def save_state(self, name=\"last\"):\n        self.get_state(silent=True)\n        self.saved_states[name] = self.current_state\n        \n    def remove_all(self):\n        for i in range(self.num_lens_group):\n            self.lens_group[i].put(state_removed)\n            self.wait()\n        self.get_state(silent=True)"
  },
  {
    "class_name": "FastShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/12-shutter.py",
    "source": "class FastShutter(Device):\n    OPEN_SHUTTER = \"open\"\n    CLOSE_SHUTTER = \"closed\"\n    SETTLE_TIME = 0.1  # seconds\n    output = Cpt(EpicsSignal,'{shutter:1}sts', string=True, put_complete=True)\n    busy = Cpt(EpicsSignal,'{shutter}busy')\n    stage = None\n    stage_move = 0\n\n    def open(self):\n        while True:\n            status = self.busy.get()\n            if status==0:\n                break\n            print('shutter busy, re-try opening in 2 seconds ...')\n            time.sleep(2)\n            \n        print(\"opening shutter ...\",)\n        #self.output.put(FastShutter.OPEN_SHUTTER)\n        self.output.set(FastShutter.OPEN_SHUTTER, settle_time=FastShutter.SETTLE_TIME)\n        if np.fabs(self.stage_move)>0.01 and isinstance(self.stage, EpicsMotor):\n            print(\"move shutter stage to compensate for position.\")\n            self.stage.move(self.stage.position+self.stage_move)\n        print(\" done.\")\n        \n    def close(self):\n        print(\"closing shutter ...\",)\n        #self.output.put(FastShutter.CLOSE_SHUTTER)\n        self.output.set(FastShutter.CLOSE_SHUTTER, settle_time=FastShutter.SETTLE_TIME)\n        if np.fabs(self.stage_move)>0.01 and isinstance(self.stage, EpicsMotor):\n            print(\"move shutter stage to compensate for position.\")\n            self.stage.move(self.stage.position-self.stage_move)\n        print(\" done.\")"
  },
  {
    "class_name": "PhotonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/12-shutter.py",
    "source": "class PhotonShutter(Device):\n    OPEN_SHUTTER = \"Open\"\n    CLOSE_SHUTTER = \"Not Open\"\n    output = Cpt(EpicsSignal, '{PSh}Pos-Sts', string=True, put_complete=True)\n    \n    def open(self):\n        self.output.set(Scintillator.OPEN_SHUTTER)\n        \n    def close(self):\n        self.output.set(Scintillator.CLOSE_SHUTTER)"
  },
  {
    "class_name": "Screen",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/20-detectors.py",
    "source": "class Screen(Device):\n    y=Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    \n    def __init__(self, pos_dict, *args, cam_name=None, **kwargs):\n        if cam_name is not None:\n            self.cam = setup_cam(cam_name)\n        self.pos_dict = pos_dict\n        super().__init__(*args, **kwargs)\n\n    def mov(self, pos):\n        if not pos in list(self.pos_dict.keys()):\n            raise Exception(f\"{pos} is not an known location.\")\n        self.y.mov(self.pos_dict[pos])"
  },
  {
    "class_name": "LiXDetectors",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/20-pilatus.py",
    "source": "class LiXDetectors(Device):\n    pil1M = Cpt(LIXPilatus, '{Det:SAXS}', name=\"pil1M\", detector_id=\"SAXS\", hostname=\"xf16idc-pilatus1m.nsls2.bnl.local\")\n    #pilW1 = Cpt(LIXPilatus, '{Det:WAXS1}', name=\"pilW1\", detector_id=\"WAXS1\", hostname=\"xf16idc-pilatus300k1.nsls2.bnl.local\")\n    pilW2 = Cpt(LIXPilatus, '{Det:WAXS2}', name=\"pilW2\", detector_id=\"WAXS2\", hostname=\"xf16idc-pilatus900k.nsls2.bnl.local\")\n    trigger_lock = None\n    reset_file_number = True\n    _num_images = 1\n    _num_repeats = 1\n    active_detectors = []\n    trig_wait = 1.\n    acq_time = 1.\n    trigger_mode = PilatusTriggerMode.soft\n    _trigger_width = 0.002\n\n    def __init__(self, prefix):\n        super().__init__(prefix=prefix, name=\"pil\")\n        self.dets = {\"pil1M\": self.pil1M,  \"pilW2\": self.pilW2} # \"pilW1\": self.pilW1,\n        #self.dets = {\"pilW2\": self.pilW2}\n        if self.trigger_lock is None:\n            self.trigger_lock = threading.Lock()\n        for dname,det in self.dets.items():\n            det.name = dname\n            det.read_attrs = ['hdf'] #['file']\n        self.active_detectors = list(self.dets.values())\n        self.trigger_time = Signal(name=\"pilatus_trigger_time\")\n\n        self._trigger_signal = EpicsSignal('XF:16IDC-ES{Zeb:1}:SOFT_IN:B0')\n        self._exp_completed = 0\n        self._flying = False\n\n        RE.md['pilatus'] = {}\n        RE.md['pilatus']['ramdisk'] = pilatus_data_dir\n\n        # ver 0, or none at all: filename template must be set by CBF file handler\n        # ver 1: filename template is already revised by the file plugin\n        #RE.md['pilatus']['cbf_file_handler_ver'] = 0\n\n    def update_cbf_name(self, cn=None):\n        for det in self.active_detectors:\n            det.update_cbf_name(cn)\n\n    def update_header(self, hdr_str):\n        for det in self.active_detectors:\n            det.HeaderString.put(hdr_str)\n\n    def activate(self, det_list):\n        \"\"\" e.g.\n            activate(['pil1M', 'pilW2'])\n        \"\"\"\n        for det in det_list:\n            if det not in self.dets.keys():\n                raise Exception(f\"{det} is not a known Pilatus detector.\")\n        self.active_detectors = [self.dets[d] for d in det_list]\n        RE.md['pilatus']['active_detectors'] = [d.name for d in self.active_detectors]\n\n    def set_trigger_mode(self, trigger_mode):\n        if isinstance(trigger_mode, PilatusTriggerMode):\n            self.trigger_mode = trigger_mode\n        else:\n            print(f\"invalid trigger mode: {trigger_mode}\")\n        RE.md['pilatus']['trigger_mode'] = trigger_mode.name\n\n    def set_num_images(self, num, rep=1):\n        self._num_images = num\n        self._num_repeats = rep\n        RE.md['pilatus']['num_images'] = [num, rep]\n\n    def number_reset(self, reset=True):\n        self.reset_file_number = reset\n        if reset:\n            for det in self.dets.values():\n                det.cbf_file_number.put(0)\n                det.hdf.file_number.put(0)\n\n    def exp_time(self, exp):\n        for det_name in self.dets.keys():\n            self.dets[det_name].read_attrs = ['hdf']\n            self.dets[det_name].cam.acquire_time.put(exp)\n            self.dets[det_name].cam.acquire_period.put(exp+self._trigger_width)\n        self.acq_time = exp+self._trigger_width\n        RE.md['pilatus']['exposure_time'] = exp\n\n\n    def use_sub_directory(self, sd=None):\n        if sd is not None:\n            if sd[-1]!='/':\n                sd += '/'\n            #makedirs(data_path+sd, mode=0o0777)\n            LIXhdfPlugin.sub_directory = sd\n            RE.md['subdir'] = LIXhdfPlugin.sub_directory\n        elif 'subdir' in RE.md.keys():\n            del RE.md['subdir'] \n            LIXhdfPlugin.sub_directory = sd\n\n    def set_thresh(self):\n        ene = int(pseudoE.energy.position/100*0.5+0.5)*0.1\n        for det in self.active_detectors: #self.dets.values():\n            det.set_thresh(ene)\n\n    def stage(self):\n        if self._staged == Staged.yes:\n            return\n        change_path()\n        # sc 11/12/24\n        #for det in self.active_detectors:\n        #    det.update_cbf_name(current_sample)\n        #self.update_cbf_name(cn=current_sample)\n        # sc 11/12/24\n        fno = np.max([det.cbf_file_number.get() for det in self.dets.values()])\n        if self.reset_file_number:\n            fno = 1\n        for det in self.dets.values():\n            det.cbf_file_number.put(fno+1)\n\n        for det in self.active_detectors:\n            det._num_images = self._num_images\n            det._num_repeats = self._num_repeats\n            det.stage(self.trigger_mode)\n\n        if self.trigger_mode == PilatusTriggerMode.ext_multi:\n            # the name is misleading, multi_triger means one image per trigger\n            self.trig_wait = self.acq_time   #+0.02\n        else:\n            self.trig_wait = self.acq_time*self._num_images*self._num_repeats   #+0.02\n        \n        self.datum={}\n\n    def unstage(self):\n        self._flying = False\n        for det in self.active_detectors:\n            det.unstage()\n\n    def kickoff(self):\n        return NullStatus()\n\n    def complete(self):\n        return NullStatus()\n        \n    def trigger(self):\n        #if len(self.active_detectors)==0:\n        #    return\n        self._status = DeviceStatus(self)\n        if self.trigger_mode is not PilatusTriggerMode.soft and not self._flying:\n            while self.trigger_lock.locked():\n                time.sleep(self._trigger_width)\n            self.trigger_time.put(time.time())\n            print(\"generating triggering pulse ...\")\n            self._trigger_signal.put(1, wait=True)\n            self._trigger_signal.put(0, wait=True)\n        for det in self.active_detectors:\n            det.trigger()\n        if self.trigger_mode is not PilatusTriggerMode.soft:\n            # soft: status to be cleared by _acquire_changed()\n            # ext: set up callback to clear status after the end-of-exposure\n            threading.Timer(self.trig_wait, self._status._finished, ()).start()\n        # should advance the file number in external trigger mode???\n\n        return self._status\n\n    def repeat_ext_trigger(self, rep):\n        \"\"\" this is used to produce external triggers to complete data collection by camserver\n        \"\"\"\n        for i in reversed(range(rep)):\n            self._trigger_signal.put(1, wait=True)\n            self._trigger_signal.put(0, wait=True)\n            time.sleep(self.acq_time)\n            print(f\"# of triggers to go: {i} \\r\", end=\"\")\n\n    def _acquire_changed(self, value=None, old_value=None, **kwargs):\n        if old_value==1 and value==0:\n            self._exp_completed += 1\n        if self._exp_completed==len(self.active_detectors):\n            self._exp_completed = 0\n            self._status._finished()\n\n#    def describe(self):\n#        \"\"\" aim to reduce the amount of information saved in the databroker\n#            all detectors share the same name, path and template\n#            in fact these are the same for the entire scan\n#        \"\"\"\n#        attrs = OrderedDict([])\n#        common_attrs = self.active_detectors[0].describe()\n\n    def collect_asset_docs(self):\n        print(f\"in {self.name} collect_asset_docs\")\n        for det in self.active_detectors:\n            yield from det.collect_asset_docs()\n\n    def complete(self):\n        ''' prepare asset_docs_cache() to be collected\n        \n            when the run eigine process the \"collect\" message, 3 functions are called (see bluesky.bundlers)\n                collect_asset_docs(): returns resource and datum document (name, doc)\n                                      RE emit(DocumentNames(name), doc)\n                                      called once per scan? name is always \"resource\"?\n                describe_collect(): returns a dictionary of {stream_name: data_keys, ...}\n                                    RE emit(DocumentNames.descriptor, doc) \n                collect(): returns a list of events [ev, ...], \n                           RE emit(DocumentNames.event, ev) or add to bulk data for later emit() call\n            DocumentNames is defined in event_model, enum\n\n            following HXN example\n        '''\n        print(f\"in {self.name} complete ...\")\n\n        for det in self.active_detectors:\n            k = f'{det.name}_image'\n            print(list(det.hdf._asset_docs_cache))\n            (name, resource), = det.hdf.collect_asset_docs()\n            assert name == 'resource'\n            # hack the resource\n            resource['resource_kwargs']['frame_per_point'] = self._num_images\n            det.hdf._asset_docs_cache.append(('resource', resource))\n            resource_uid = resource['uid']\n            datum_id = '{}/{}'.format(resource_uid, 0)\n            #datum_id = resource_uid\n            self.datum[k] = [datum_id, ttime.time()]\n            datum = {'resource': resource_uid,\n                     'datum_id': datum_id,\n                     'datum_kwargs': {'point_number': 0}}\n            det.hdf._asset_docs_cache.append(('datum', datum))     # the scattering patterns go to the hdf plugin asset_docs_cache\n\n        print(\"+++\", det.hdf._asset_docs_cache)\n        print(\"---\", self.datum)   \n        return NullStatus()\n\n    def collect(self):\n        print(f\"in {self.name} collect ...\")\n        data = {}\n        ts = {}\n        for det in self.active_detectors:\n            k = f'{det.name}_image'\n            data[k],ts[k] = self.datum[k]\n        \n        ret = {'time': time.time(),\n               'data': data,\n               'timestamps': ts,\n              }\n        \n        yield ret\n\n    def describe_collect(self):\n        print(f\"in {self.name} describe_collect ...\")\n        ret = {}\n        for det in self.active_detectors:\n            ret[f'{det.name}_image'] = det.make_data_key()\n            ret[f'{det.name}_image']['shape'] = (self._num_images, *ret[f'{det.name}_image']['shape'][1:])\n            for k,desc in det.describe().items():\n                ret[k] = desc\n        #return {'primary': ret}\n        return {self.name: ret}"
  },
  {
    "class_name": "MonoDCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/14-energy.py",
    "source": "class MonoDCM(Device):\n    bragg = Cpt(EpicsMotor, '-Ax:Bragg}Mtr')\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Of2}Mtr')\n    pitch2 = Cpt(EpicsMotor, '-Ax:P2}Mtr')\n    roll2 = Cpt(EpicsMotor, '-Ax:R2}Mtr')\n    fine_pitch = Cpt(EpicsMotor, '-Ax:PF2}Mtr')\n    ccm_fine_pitch = Cpt(EpicsMotor, '-Ax:CCM_PF}Mtr')\n    pitch2_rb = Cpt(EpicsSignalRO, '-Ax:PF_RDBK}Mtr.RBV')"
  },
  {
    "class_name": "XBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/14-energy.py",
    "source": "class XBPM(Device):\n    x = Cpt(EpicsSignalRO, 'Pos:X-I')\n    y = Cpt(EpicsSignalRO, 'Pos:Y-I')\n\n    def pos(self, navg=5):\n        if self.x.connected==False or self.y.connected==False:\n            return (np.nan, np.nan)\n        \n        xpos = np.average([self.x.get() for _ in range(navg)])\n        ypos = np.average([self.y.get() for _ in range(navg)])\n        return (xpos, ypos)"
  },
  {
    "class_name": "XYMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-motors.py",
    "source": "class XYMotor(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')"
  },
  {
    "class_name": "ApertureDev",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-motors.py",
    "source": "class ApertureDev(Device):\n    dx = Cpt(EpicsMotor, '-Ax:dX}Mtr')\n    dy = Cpt(EpicsMotor, '-Ax:dY}Mtr')"
  },
  {
    "class_name": "SlitsCenterAndGap",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-motors.py",
    "source": "class SlitsCenterAndGap(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    dx = Cpt(EpicsMotor, '-Ax:dX}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    dy = Cpt(EpicsMotor, '-Ax:dY}Mtr')"
  },
  {
    "class_name": "HRM1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-motors.py",
    "source": "class HRM1(Device):\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    pitch = Cpt(EpicsMotor, '-Ax:Th}Mtr')"
  },
  {
    "class_name": "HRM2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-motors.py",
    "source": "class HRM2(Device):\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    pitch = Cpt(EpicsMotor, '-Ax:Th}Mtr')\n    # Upstream\n    bend1 = Cpt(EpicsMotor, '-Ax:BU}Mtr')\n    # Downstream\n    bend2 = Cpt(EpicsMotor, '-Ax:BD}Mtr')"
  },
  {
    "class_name": "StageScan",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-motors.py",
    "source": "class StageScan(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    r = Cpt(EpicsMotor, '-Ax:Rot}Mtr')"
  },
  {
    "class_name": "Tilt",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/10-motors.py",
    "source": "class Tilt(Device):\n    rx = Cpt(EpicsMotor, '-Ax:RX}Mtr')\n    ry = Cpt(EpicsMotor, '-Ax:RY}Mtr')"
  },
  {
    "class_name": "Best",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/20-bpm.py",
    "source": "class Best(Device):\n    x_mean  = Cpt(EpicsSignal, ':BPM0:PosX_Mean')\n    posx = Cpt(EpicsSignal, ':BPM0:PosX')\n    x_std = Cpt(EpicsSignal, ':BPM0:PosX_Std')\n    y_mean  = Cpt(EpicsSignal,':BPM0:PosY_Mean')\n    posy  = Cpt(EpicsSignal,':BPM0:PosY')\n    y_std = Cpt(EpicsSignal, ':BPM0:PosY_Std')\n    int_mean  = Cpt(EpicsSignal, ':BPM0:Int_Mean')\n    int_std = Cpt(EpicsSignal, ':BPM0:Int_Std')\n    ch1 = Cpt(EpicsSignal, ':TetrAMM0:Ch1')\n    ch2 = Cpt(EpicsSignal, ':TetrAMM0:Ch2')\n    ch3 = Cpt(EpicsSignal, ':TetrAMM0:Ch3')\n    ch4 = Cpt(EpicsSignal, ':TetrAMM0:Ch4')\n    acquire_time = Cpt(Signal, name='time', value=1)\n\n    def trigger(self):\n        #TODO: modify settle_time to be from a acquiretime pv\n        acq_time = self.acquire_time.get()\n        _status = DeviceStatus(self, settle_time=acq_time)\n        _status._finished(success=True)\n        return _status"
  },
  {
    "class_name": "TimeSeries",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/20-bpm.py",
    "source": "class TimeSeries(Device):\n    SumAll = ADCpt(EpicsSignalRO, \"SumAll:TimeSeries\", kind='normal')\n    current1 = ADCpt(EpicsSignalRO, \"Current1:TimeSeries\", kind='normal')\n    current2 = ADCpt(EpicsSignalRO, \"Current2:TimeSeries\", kind='normal')\n    current3 = ADCpt(EpicsSignalRO, \"Current3:TimeSeries\", kind='normal')\n    current4 = ADCpt(EpicsSignalRO, \"Current4:TimeSeries\", kind='normal')\n\n    acquire = ADCpt(EpicsSignal, \"TSAcquire\", kind='omitted')\n    acquire_mode = ADCpt(EpicsSignal, \"TSAcquireMode\", string=True, kind='config')\n    acquiring = ADCpt(EpicsSignalRO, \"TSAcquiring\", kind='omitted')\n\n    time_axis = ADCpt(EpicsSignalRO, \"TSTimeAxis\", kind='config')\n    read_rate = ADCpt(EpicsSignal, \"TSRead.SCAN\", string=True, kind='config')\n    num_points = ADCpt(EpicsSignal, \"TSNumPoints\", kind='config')\n    averaging_time = ADCpt(EpicsSignalWithRBV, \"TSAveragingTime\", kind=\"config\")\n    current_point = ADCpt(EpicsSignalRO, \"TSCurrentPoint\", kind=\"omitted\")"
  },
  {
    "class_name": "Bimorph",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/11-bimorph.py",
    "source": "class Bimorph(Device):\n    '''Bimorph HV Power Source'''\n\n    bank_no = C(EpicsSignal, ':BANK_NO_32.VAL')\n    step_size = C(EpicsSignal, ':U_STEP.VAL')\n    inc_bank = C(EpicsSignal, ':INCR_U_BANK_CMD.PROC')\n    dec_bank = C(EpicsSignal, ':DECR_U_BANK_CMD.PROC')\n    stop_ramp = C(EpicsSignal, ':STOP_RAMPS_BANK.PROC')\n    start_ramp = C(EpicsSignal, ':START_RAMPS_CMD.PROC')\n\n    format_number = C(EpicsSignal, ':FORMAT_NO_SP.VAL')\n    load_format = C(EpicsSignal, ':FORMAT_ACTIVE_SP.PROC')\n\n    all_target_voltages = C(EpicsSignalRO, ':U_ALL_TARGET_MON.VAL')\n    all_current_voltages = C(EpicsSignalRO, ':U_ALL_CURRENT_MON.VAL')\n\n    unit_status = C(EpicsSignalRO, ':UNIT_STATUS_MON.A')\n\n    channels = DDC(add_channels(range(0, 32)))\n\n    def step(self, bank, size, direction, start=False, wait=False):\n        self.bank_no.put(bank)\n        self.step_size.put(size)\n\n        if(direction == \"inc\"):\n            self.inc_bank.put(1)\n        else:\n            self.dec_bank.put(1)\n\n        if(start):\n            self.start()\n\n        if(wait):\n            self.wait()\n\n    def increment_bank(self, bank, size, start=False, wait=False):\n        ''' Increments the target voltage in `size` Volts in the specified `bank`\n\n        Parameters:\n        -----------\n        bank : int\n            The number of the bank to be incremented\n        size : float\n            The amount of Volts to increment from the bank target value\n        start : bool\n            Determines if the ramp must start right after the increment. Defaults to False.\n        wait : bool\n            Determines if the code must wait until the ramp process finishes. Defaults to False.\n        '''\n        self.step(bank, size, \"inc\", start)\n\n    def decrement_bank(self, bank, size, start=False, wait=False):\n        ''' Decrements the target voltage in `size` Volts in the specified `bank`\n\n        Parameters:\n        -----------\n        bank : int\n            The number of the bank to be decremented\n        size : float\n            The amount of Volts to decrement from the bank target value\n        start : bool\n            Determines if the ramp must start right after the decrement. Defaults to False.\n        wait : bool\n            Determines if the code must wait until the ramp process finishes. Defaults to False.\n        '''\n        self.step(bank, size, \"dec\", start)\n\n    def start(self):\n        ''' Start the Ramping process on all channels '''\n        self.start_ramp.put(1)\n\n    def stop(self):\n        ''' Stops the Ramping process on all channels '''\n        self.stop_ramp.put(1)\n\n    def start_plan(self):\n        yield from bps.mv(self.start_ramp, 1)\n\n    def is_ramping(self):\n        ''' Returns wether the power supply is ramping or not '''\n        return (int(self.unit_status.get()) >> 30) == 1\n\n    def is_interlock_ok(self):\n        ''' Returns the interlock state '''\n        st = int(self.unit_status.get())\n        return (st & 1) & ((st >> 1) & 1) == 1\n\n    def is_on(self):\n        ''' Returns wether the Channels are ON or OFF '''\n        return (int(self.unit_status.get()) >> 29) == 1          \n\n    def wait(self):\n        while self.is_ramping():\n          sleep(0.1)\n\n    def all_armed_voltages(self):\n        return np.array([getattr(self, f\"channels.channel{i}.armed_voltage\").get() for i in range(32)], dtype=np.float32).ravel()\n\n    def all_setpoint_voltages(self):\n        return np.array([getattr(self, f\"channels.channel{i}.setpoint\").get() for i in range(32)], dtype=np.float32).ravel()"
  },
  {
    "class_name": "trajControl",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/lix-profile-collection/startup/components/30-traj.py",
    "source": "class trajControl(Device):\n    def __init__(self, *args, **kwargs):\n        \n        super().__init__(*args, **kwargs)\n        \n        self.traj_par = {'run_forward_traj': True, \n                         'no_of_segments': 0, \n                         'no_of_rampup_points': 0,\n                         'segment_displacement': 0,\n                         'segment_duration': 0,\n                         'motor': None,\n                         'rampup_distance': 0\n                        }\n        self.time_modified = time.time()\n        self.start_time = 0\n        self._traj_status = None\n        self.flying_motor = None\n        \n        \n    def stage(self):\n        self.aborted = False\n        self.clear_readback()\n\n    def unstage(self):\n        \"\"\" abort whatever is still going on??\n        \"\"\"\n        #self.abort_traj()\n        while self.moving():\n            time.sleep(0.2)\n        self._traj_status = None\n        \n    def read_configuration(self):\n        ret = [(k, {'value': val, \n                    'timestamp': self.time_modified}) for k, val in self.traj_par.items() if val is not None]\n        return OrderedDict(ret)\n        \n    def describe_configuration(self):\n        return {\n          k: {\"source\": \"trajectory_state\", \"dtype\": data_type(val), \"shape\": data_shape(val)}\n          for k, val\n          in self.traj_par.items()\n          if val is not None\n        }\n    \n    def setup_traj(self, fast_axis, f_start, f_end, Nfast, step_size, dt, slow_axis=None, Nslow=1):\n        \"\"\" Nfast triggers, Nfast-1 segments \n            f_start and f_end are absolute positions\n        \"\"\"\n        self.define_traj(fast_axis, Nfast-1, step_size, dt)\n        \n        if isinstance(fast_axis, EpicsMotor):  # trajectory is based on user/Ophyd position\n            # motor_pos_sign = (-1 if fast_axis.user_offset_dir.get() else 1)\n            motor_pos_sign = 1   # Ophyd use user position   \n            p0_fast = fast_axis.position\n        elif isinstance(fast_axis, XPSmotor): # trajectory is based on dial/controller position\n            motor_pos_sign = fast_axis.user_offset_dir.get()\n            p0_fast = fast_axis.position\n        else:\n            raise Exception(\"unkown motor type: \", fast_axis)\n            \n        # forward/back trajectory = fast axis motor postion increasing/decreasing\n        # rampup_distance and step_size are both positive\n        # ready positions are dial positions\n        # To-do: verify that this also works for EPICS motors (originally coded for XPS motors) \n        ready_pos_FW = np.min(np.array([f_start, f_end])*motor_pos_sign)-(self.traj_par['rampup_distance']+step_size/2)\n        ready_pos_BK = np.max(np.array([f_start, f_end])*motor_pos_sign)+(self.traj_par['rampup_distance']+step_size/2)\n        if isinstance(fast_axis, EpicsMotor):  # trajectory is based on user/Ophyd position\n            motor_pos_sign = 1   \n        \n        #self.traj_par['ready_pos'] = [p0_fast+ready_pos_FW, p0_fast+ready_pos_BK]\n        self.traj_par['ready_pos'] = [ready_pos_FW, ready_pos_BK]\n        self.traj_par['Nem2'] = Nfast*Nslow\n        self.traj_par['Nfast'] = Nfast\n        self.traj_par['run_forward_first'] = ((motor_pos_sign>0 and f_start<f_end) or (motor_pos_sign<0 and f_start>f_end))\n        self.traj_par['fast_axis'] = fast_axis.name\n        self.slow_axis = slow_axis\n        if slow_axis is not None:\n            self.traj_par['slow_axis'] = slow_axis.name  \n        else:\n            self.traj_par['slow_axis'] = None\n        \n    def select_forward_traj(self, op=True):\n        if op:\n            self.traj_par['run_forward_traj'] = True\n        else:\n            self.traj_par['run_forward_traj'] = False\n        \n    def moving(self):\n        if self.flying_motor is None:\n            return False\n        return self.flying_motor.moving\n    \n    def abort_traj(self):\n        if self.flying_motor is not None:\n            self.flying_motor.stop()\n        return\n        \n    def kickoff(self):\n        \"\"\"\n        run the trajectory\n        \"\"\"\n        print(\"kicking off traj ...\")\n        if self.verified==False:\n            raise Exception(\"trajectory not defined/verified.\")\n        \n        self._traj_status = DeviceStatus(self)\n      \n        th = threading.Thread(target=self.exec_traj, args=(self.traj_par['run_forward_traj'], ) )\n        th.start() \n        \n        print(\"traj kicked off ...\")\n        return self._traj_status\n        \n    def complete(self):\n        \"\"\"\n            according to run_engine.py: Tell a flyer, 'stop collecting, whenever you are ready'.\n            Return a status object tied to 'done'.\n        \"\"\"\n        print(\"completing traj ...\")\n        if self._traj_status is None:\n            raise RuntimeError(\"must call kickoff() before complete()\")\n        while not self._traj_status.done:\n            print(f\"{time.asctime()}: waiting for the trajectory to finish ...   \\r\", end='')\n            time.sleep(1)\n        if self.aborted:\n            raise Exception(\"unable to complete the scan due to hardware issues ...\")\n        print(\"traj completed ...\")\n             \n        return self._traj_status\n        \n    def collect(self):\n        \"\"\"\n        this is the \"event\"???\n        save position data, called at the end of a scan (not at the end of a trajectory)\n        this is now recorded in self.readback, as accumulated by self.update_readback()\n        also include the detector image info\n        \"\"\"\n        print(\"in traj collect ...\")\n        now = time.time()\n        data = {}\n        ts = {}\n\n        data[self.traj_par['fast_axis']] = self.read_back['fast_axis']\n        ts[self.traj_par['fast_axis']] = self.read_back['timestamp']  # timestamps\n        if self.slow_axis is not None:\n            data[self.traj_par['slow_axis']] = self.read_back['slow_axis']\n            ts[self.traj_par['slow_axis']] = self.read_back['timestamp2']\n                \n        ret = {'time': time.time(),\n               'data': data,\n               'timestamps': ts,\n              }\n        print(\"done collecting traj\")\n        yield ret\n\n    def describe_collect(self):\n        '''Describe details for the flyer collect() method'''\n        print(\"in traj describe_collect ...\")\n        ret = {}\n        ret[self.traj_par['fast_axis']] = {'dtype': 'number',\n                                           'shape': (len(self.read_back['fast_axis']),),\n                                           'source': 'PVT trajectory readback position'}\n        if self.slow_axis is not None:\n            ret[self.traj_par['slow_axis']] = {'dtype': 'number',\n                                               'shape': (len(self.read_back['slow_axis']),),\n                                               'source': 'motor position readback'}\n                \n        return {self.name: ret}\n    \n    def define_traj(self, motor, N, dx, dt, Nr=2):\n        raise Exception(\"this function is not implemented.\")\n\n    def exec_traj(self, forward=True, **kwargs):\n        raise Exception(\"this function is not implemented.\")\n\n    def readback_traj(self):\n        raise Exception(\"this function is not implemented.\")\n\n    def clear_readback(self):\n        self.read_back = {}\n        self.read_back['fast_axis'] = []\n        self.read_back['timestamp'] = []\n        if self.slow_axis is not None:\n            self.read_back['slow_axis'] = []\n            self.read_back['timestamp2'] = []\n        \n    def update_readback(self):\n        pos = self.readback_traj()\n        # start_time is the beginning of the execution\n        # pulse is generated when the positioner enters the segment ??\n        # timestamp correspond to the middle of the segment\n        N = self.traj_par['no_of_segments']\n        Nr = self.traj_par['no_of_rampup_points']\n        dt = self.traj_par['segment_duration']\n        ts = self.start_time + (0.5 + Nr + np.arange(N+1))*dt\n        if len(pos)!=N+1:\n            print(f\"Warning: incorrect readback length {len(pos)}, expecting {N+1}\")\n            print(pos)\n        self.read_back['fast_axis'] += list(pos)\n        self.read_back['timestamp'] += list(ts)\n\n        if self.slow_axis is not None:\n            self.read_back['slow_axis'].append(self.slow_axis.position)\n            self.read_back['timestamp2'].append(time.time())\n\n        print(\"traj data updated ..\")"
  },
  {
    "class_name": "FastShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/esm.py",
    "source": "class FastShutter(Device):\n    OPEN_SHUTTER = \"open\"\n    CLOSE_SHUTTER = \"closed\"\n    SETTLE_TIME = 0.1  # seconds\n    output = Cpt(EpicsSignal,'{shutter:1}sts', string=True, put_complete=True)\n\n    def open(self):\n        self.output.set(FastShutter.OPEN_SHUTTER, settle_time=FastShutter.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(FastShutter.CLOSE_SHUTTER, settle_time=FastShutter.SETTLE_TIME)"
  },
  {
    "class_name": "Scintillator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/esm.py",
    "source": "class Scintillator(Device):\n    OPEN_SHUTTER = \"open\"\n    CLOSE_SHUTTER = \"closed\"\n    SETTLE_TIME = 0.1  # seconds\n    output = Cpt(EpicsSignal,'{shutter:2}sts', string=True, put_complete=True)\n\n    def open(self):\n        self.output.set(Scintillator.OPEN_SHUTTER, settle_time=Scintillator.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(Scintillator.CLOSE_SHUTTER, settle_time=Scintillator.SETTLE_TIME)"
  },
  {
    "class_name": "PhotonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/esm.py",
    "source": "class PhotonShutter(Device):\n    OPEN_SHUTTER = \"Open\"\n    CLOSE_SHUTTER = \"Not Open\"\n    output = Cpt(EpicsSignal, '{PSh}Pos-Sts', string=True, put_complete=True)\n    \n    def open(self):\n        self.output.set(Scintillator.OPEN_SHUTTER)\n        \n    def close(self):\n        self.output.set(Scintillator.CLOSE_SHUTTER)"
  },
  {
    "class_name": "FastShutter2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/esm.py",
    "source": "class FastShutter2(Device):\n    OPEN_SHUTTER = \"Force High\"\n    CLOSE_SHUTTER = \"Force Low\"\n    SETTLE_TIME = 0.1  # seconds\n    delay = Cpt(EpicsSignal, '-DlyGen:0}Delay-SP')\n    width = Cpt(EpicsSignal, '-DlyGen:0}Width-SP')\n    output = Cpt(EpicsSignal,'-Out:FP0}Src:Scale-SP', string=True, put_complete=True)\n\n    \n    def open(self):\n        self.output.set(FastShutter2.OPEN_SHUTTER, settle_time=FastShutter2.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(FastShutter2.CLOSE_SHUTTER, settle_time=FastShutter2.SETTLE_TIME)"
  },
  {
    "class_name": "FastShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/40-ESM_plans_elio.py",
    "source": "class FastShutter(Device):\n    OPEN_SHUTTER = \"open\"\n    CLOSE_SHUTTER = \"closed\"\n    SETTLE_TIME = 0.1  # seconds\n    output = Cpt(EpicsSignal,'{shutter:1}sts', string=True, put_complete=True)\n\n    def open(self):\n        self.output.set(FastShutter.OPEN_SHUTTER, settle_time=FastShutter.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(FastShutter.CLOSE_SHUTTER, settle_time=FastShutter.SETTLE_TIME)"
  },
  {
    "class_name": "Scintillator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/40-ESM_plans_elio.py",
    "source": "class Scintillator(Device):\n    OPEN_SHUTTER = \"open\"\n    CLOSE_SHUTTER = \"closed\"\n    SETTLE_TIME = 0.1  # seconds\n    output = Cpt(EpicsSignal,'{shutter:2}sts', string=True, put_complete=True)\n\n    def open(self):\n        self.output.set(Scintillator.OPEN_SHUTTER, settle_time=Scintillator.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(Scintillator.CLOSE_SHUTTER, settle_time=Scintillator.SETTLE_TIME)"
  },
  {
    "class_name": "PhotonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/40-ESM_plans_elio.py",
    "source": "class PhotonShutter(Device):\n    OPEN_SHUTTER = \"Open\"\n    CLOSE_SHUTTER = \"Not Open\"\n    output = Cpt(EpicsSignal, '{PSh}Pos-Sts', string=True, put_complete=True)\n    \n    def open(self):\n        self.output.set(Scintillator.OPEN_SHUTTER)\n        \n    def close(self):\n        self.output.set(Scintillator.CLOSE_SHUTTER)"
  },
  {
    "class_name": "FastShutter2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/40-ESM_plans_elio.py",
    "source": "class FastShutter2(Device):\n    OPEN_SHUTTER = \"Force High\"\n    CLOSE_SHUTTER = \"Force Low\"\n    SETTLE_TIME = 0.1  # seconds\n    delay = Cpt(EpicsSignal, '-DlyGen:0}Delay-SP')\n    width = Cpt(EpicsSignal, '-DlyGen:0}Width-SP')\n    output = Cpt(EpicsSignal,'-Out:FP0}Src:Scale-SP', string=True, put_complete=True)\n\n    \n    def open(self):\n        self.output.set(FastShutter2.OPEN_SHUTTER, settle_time=FastShutter2.SETTLE_TIME)\n\n    def close(self):\n        self.output.set(FastShutter2.CLOSE_SHUTTER, settle_time=FastShutter2.SETTLE_TIME)"
  },
  {
    "class_name": "SES",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/31-ses.py",
    "source": "class SES(Device):\n    \"\"\"\n    Scienta SES control\n    \"\"\"\n\n    center_en_sp = Component(EpicsSignal, ':center_en_SP')\n    width_en_sp = Component(EpicsSignal, ':width_en_SP')\n    set_start = Component(EpicsSignal, ':request')\n    done = Component(EpicsSignalRO, ':done')\n    iterations = Component(EpicsSignal, ':iterations_SP')\n    excitation_en = Component(EpicsSignal, ':excitation_en_SP')\n    steptime = Component(EpicsSignal, ':steptime_SP')\n    acq_mode = Component(EpicsSignal, ':acq_mode_SP')\n    pass_en = Component(EpicsSignal, ':pass_en_SP')\n    lens_mode  = Component(EpicsSignal, ':lens_mode_SP')\n    en_step = Component(EpicsSignal, ':en_step_SP')\n    write_mode = Component(EpicsSignal, ':write_mode')\n\n\n    def trigger(self):\n        \"\"\"\n        Trigger the detector and return a Status object.\n        \"\"\"\n        status = DeviceStatus(self)\n        # Wire up a callback that will mark the status object as finished\n        # when we see the state flip from \"acquiring\" to \"not acquiring\"---\n        # that is, a negative edge.\n        def callback(old_value, value, **kwargs):\n            if old_value == 0 and value == 1:\n                status._finished()\n                self.done.clear_sub(callback)\n\n        self.done.subscribe(callback, run=False)\n        self.set_start.put(1)        \n        # And return the Status object, which the caller can use to\n        # tell when the action is complete.\n        return status\n\n    def read_params(self):\n        \"\"\"\n        Read the existing parameters in SES into PVs\n        \"\"\"\n        status = DeviceStatus(self)\n        # Wire up a callback that will mark the status object as finished\n        # when we see the state flip from \"acquiring\" to \"not acquiring\"---\n        # that is, a negative edge.\n        def callback(old_value, value, **kwargs):\n            if old_value == 0 and value == 1:\n                status._finished()\n                self.done.clear_sub(callback)\n\n        self.done.subscribe(callback, run=False)\n        self.set_start.put(2)\n        # And return the Status object, which the caller can use to\n        # tell when the action is complete.\n        return status"
  },
  {
    "class_name": "Pol_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class Pol_mtr(Device):\n    Rz = Comp(EpicsMotor,'Mtr', kind='hinted')"
  },
  {
    "class_name": "LL_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class LL_mtr(Device):\n    Claw_Trans = Comp(EpicsMotor,'2-Claw:EA3_1-Ax:T}Mtr', kind='hinted')\n    Claw_Rotate = Comp(EpicsMotor,'2-Claw:EA3_1-Ax:R}Mtr', kind='hinted')\n    Claw_Grab = Comp(EpicsMotor,'2-Claw:EA3_1-Ax:C}Mtr', kind='hinted')\n    Dock_Trans = Comp(EpicsMotor,'1-Dock:EA4_1-Ax:F}Mtr', kind='hinted')"
  },
  {
    "class_name": "LT_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class LT_mtr(Device):\n   X = Comp(EpicsMotor,\"-Ax:X}Mtr\", kind='hinted')\n   Y = Comp(EpicsMotor,\"-Ax:Y}Mtr\", kind='hinted')\n   Z = Comp(EpicsMotor,\"-Ax:Z}Mtr\", kind='hinted')\n   Ry =  Comp(EpicsMotor,\"-Ax:R1}Mtr\", kind='hinted')\n   Rz =  Comp(EpicsMotor,\"-Ax:R2}Mtr\", kind='hinted')\n   Rx =  Comp(EpicsMotor,\"-Ax:R3}Mtr\", kind='hinted')"
  },
  {
    "class_name": "SP_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class SP_mtr(Device):\n    X = Comp(EpicsMotor,\"-Ax:X}Mtr\", kind='hinted')\n    Y = Comp(EpicsMotor,\"-Ax:Y}Mtr\", kind='hinted')\n    Z = Comp(EpicsMotor,\"-Ax:Z}Mtr\", kind='hinted')\n    Rx = Comp(EpicsMotor,\"-Ax:Rx}Mtr\", kind='hinted')"
  },
  {
    "class_name": "An_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class An_mtr(Device):\n\n    #Add micro-scanning stage motors here when done\n    Claw_Trans = Comp(EpicsMotor,\"{ST:1-Claw:EA1_1-Ax:T}Mtr\", kind='hinted')\n    Claw_Grab = Comp(EpicsMotor,\"{ST:1-Claw:EA1_1-Ax:C}Mtr\", kind='hinted')"
  },
  {
    "class_name": "Analyzer_mtr",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class Analyzer_mtr(Device):\n    Rz = Comp(EpicsMotor,\"{SA:1-DPRF:EA1_1-Ax:1}Mtr\", kind='hinted')"
  },
  {
    "class_name": "M1_mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class M1_mirror(Device):\n    X = Comp(EpicsMotor,\"Trans}Mtr\", kind='hinted')\n#    Mirror_Trans = Comp(EpicsMotor,\"Trans}Mtr\")\n    Mirror_InOut = Comp(EpicsMotor,\"Trans}Mtr\")\n    Ry = Comp(EpicsMotor,\"Pitch}Mtr\", kind='hinted')\n    Mirror_Pitch = Comp(EpicsMotor,\"Pitch}Mtr\")\n    Rz = Comp(EpicsMotor,\"Roll}Mtr\", kind='hinted')\n    Mirror_Roll = Comp(EpicsMotor,\"Roll}Mtr\")"
  },
  {
    "class_name": "Hexapod_Mir",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class Hexapod_Mir(Device):\n    X = Comp(EpicsMotor,\"_X}Mtr\", kind='hinted')\n#    Mirror_Trans = Comp(EpicsMotor,\"_X}Mtr\")\n    Mirror_InOut = Comp(EpicsMotor,\"_X}Mtr\")\n    Y = Comp(EpicsMotor,\"_Y}Mtr\", kind='hinted')\n    Mirror_Stripe = Comp(EpicsMotor,\"_Y}Mtr\")\n    Mirror_Exchange = Comp(EpicsMotor,\"_Y}Mtr\")\n    Z = Comp(EpicsMotor,\"_Z}Mtr\", kind='hinted')\n    Rx = Comp(EpicsMotor,\"_Rx}Mtr\", kind='hinted')\n    Mirror_Roll = Comp(EpicsMotor,\"_Rz}Mtr\")\n    Ry = Comp(EpicsMotor,\"_Ry}Mtr\", kind='hinted')\n    Mirror_Pitch = Comp(EpicsMotor,\"_Ry}Mtr\")\n    Rz = Comp(EpicsMotor,\"_Rz}Mtr\", kind='hinted')\n    Mirror_Yaw = Comp(EpicsMotor,\"_Rx}Mtr\")"
  },
  {
    "class_name": "Monochromator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class Monochromator(Device):\n    Focus_Const = Comp(EpicsMotor,\"-Ax:8_Cff}Mtr\", kind='hinted')\n    Energy = Comp(EpicsMotor,\"-Ax:8_Eng}Mtr\", kind='hinted')\n    Grating_Trans = Comp(EpicsMotor,\"-Ax:8_GT}Mtr\")\n    Mirror_Pitch = Comp(EpicsMotor,\"-Ax:8_MP}Mtr\")\n    Mirror_Pitch_off = Comp(EpicsSignal,\"-Ax:8_MP}Mtr.OFF\")\n    Mirror_Pitch_set = Comp(EpicsSignal,\"-Ax:8_MP}Mtr.SET\")\n    Mirror_Pitch_kill = Comp(EpicsSignal, \"-Ax:8_MP}Cmd:Kill-Cmd\")\n    Grating_Pitch = Comp(EpicsMotor,\"-Ax:8_GP}Mtr\")\n    Grating_Pitch_off = Comp(EpicsSignal,\"-Ax:8_GP}Mtr.OFF\")\n    Grating_Pitch_set = Comp(EpicsSignal,\"-Ax:8_GP}Mtr.SET\")\n    Grating_Pitch_kill = Comp(EpicsSignal, \"-Ax:8_GP}Cmd:Kill-Cmd\")\n    Grating_lines = Comp(EpicsSignal,\"}:LINES:RBV\",write_pv=\"}:LINES:SET\",put_complete=False, kind='hinted')"
  },
  {
    "class_name": "EpicsSignalLastElement",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class EpicsSignalLastElement(EpicsSignal):\n    def get(self):\n        return float(super().get()[-1])"
  },
  {
    "class_name": "BEST_Xaxis",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class BEST_Xaxis(Device):\n    def __init__(self,*args,**kwargs):\n        super().__init__(*args,**kwargs)\n        self.readback.name = self.name\n\n    readback = Comp(EpicsSignalLastElement,\"FM}:BPM0:PosX\", kind='hinted')  # Make these EpicsSignal, 'PV:...'\n    setpoint = Comp(EpicsSignal,\"FM}:PID:SetpointX\")\n    tolerance = 0.1\n\n        \n    # Define the class properties here\n    @property\n    def read_val(self):\n        return self.get()\n\n    @property\n    def hints(self):\n        return{'fields':[self.readback.name]}\n\n    \n    def set(self, value):\n        desired_value = value\n        status = DeviceStatus(self)\n\n        def are_we_there_yet(value, *args, **kwargs):\n            if abs(value[-1] - desired_value) < self.tolerance:\n                # This alerts the RunEngine that it can move on.\n                status._finished()\n\n        # Start us moving.\n        self.setpoint.put(desired_value)\n        # The function are_we_there_yet will receive\n        # updates from pyepics as the readback changes.\n        self.readback.subscribe(are_we_there_yet)\n        # Hand this back the RunEngine immediately.\n        return status"
  },
  {
    "class_name": "BEST_Yaxis",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class BEST_Yaxis(Device):\n    def __init__(self,*args,**kwargs):\n        super().__init__(*args,**kwargs)\n        self.readback.name = self.name\n\n    readback = Comp(EpicsSignalLastElement,\"FM}:BPM0:PosY\", kind='hinted')  # Make these EpicsSignal, 'PV:...'\n    setpoint = Comp(EpicsSignal,\"FM}:PID:SetpointY\")\n    tolerance = 0.1\n\n    def set(self, value):\n        desired_value = value\n        status = DeviceStatus(self)\n\n        def are_we_there_yet(value, *args, **kwargs):\n            if abs(value[-1] - desired_value) < self.tolerance:\n                # This alerts the RunEngine that it can move on.\n                status._finished()\n\n        # Start us moving.\n        self.setpoint.put(desired_value)\n        # The function are_we_there_yet will receive\n        # updates from pyepics as the readback changes.\n        self.readback.subscribe(are_we_there_yet)\n        # Hand this back the RunEngine immediately.\n        return status"
  },
  {
    "class_name": "KB_pair",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class KB_pair(Device):\n    VFM_Y = Comp(EpicsMotor,\"Ax:A4_VFMTy}Mtr\", kind='hinted')\n    VFM_Mirror_InOut = Comp(EpicsMotor,\"Ax:A4_VFMTy}Mtr\")\n    VFM_Mirror_Trans = Comp(EpicsMotor,\"Ax:A4_VFMTy}Mtr\")\n    VFM_Z = Comp(EpicsMotor,\"Ax:A4_VFMTz}Mtr\", kind='hinted')\n    VFM_Mirror_Astig = Comp(EpicsMotor,\"Ax:A4_VFMTz}Mtr\")\n    VFM_Mirror_Horizontal = Comp(EpicsMotor,\"Ax:A4_VFM_Astig}Mtr\")\n    VFM_Mirror_Incline = Comp(EpicsMotor,\"Ax:A4_VFM_IO}Mtr\")\n\n    HFM_Z = Comp(EpicsMotor,\"Ax:A4_HFM_Astig}Mtr\", kind='hinted')\n    HFM_X = Comp(EpicsMotor,\"Ax:A4_HFM_IO}Mtr\", kind='hinted')\n    HFM_Mirror_Astig = Comp(EpicsMotor,\"Ax:A4_HFM_Astig}Mtr\")\n    HFM_Mirror_InOut = Comp(EpicsMotor,\"Ax:A4_HFM_IO}Mtr\")\n    HFM_Mirror_Trans = Comp(EpicsMotor,\"Ax:A4_HFM_IO}Mtr\")\n\n    HFM_Au_Mesh = Comp(EpicsMotor,\"Ax:A4_HGM}Mtr\")\n    VFM_Au_Mesh = Comp(EpicsMotor,\"Ax:A4_VGM}Mtr\")\n\n    VFM_Rx = Comp(BEST_Xaxis,\"\", kind='hinted')\n    VFM_Pitch = Comp(BEST_Xaxis,\"\")\n    HFM_Ry = Comp(BEST_Yaxis,\"\", kind='hinted')\n    HFM_Pitch = Comp(BEST_Yaxis,\"\")"
  },
  {
    "class_name": "ESM_Diagon",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class ESM_Diagon(Device):\n    H_mirror = Comp(EpicsMotor,\"-Ax:3_HLPM}Mtr\", kind='hinted')\n    H_Yag = Comp(EpicsMotor,\"-Ax:3_HLPF}Mtr\", kind='hinted')\n    V_mirror = Comp(EpicsMotor,\"-Ax:3_VLPM}Mtr\", kind='hinted')\n    V_Yag = Comp(EpicsMotor,\"-Ax:3_VLPF}Mtr\", kind='hinted')"
  },
  {
    "class_name": "ESMSlit_type1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class ESMSlit_type1(Device):\n    inboard = Comp(EpicsMotor,\"-Ax:I}Mtr\")\n    outboard = Comp(EpicsMotor,\"-Ax:O}Mtr\")\n    bottom = Comp(EpicsMotor,\"-Ax:B}Mtr\")\n    top = Comp(EpicsMotor,\"-Ax:T}Mtr\")\n    h_gap = Comp(EpicsMotor,\"-Ax:HG}Mtr\", kind='hinted')\n    h_center = Comp(EpicsMotor,\"-Ax:HC}Mtr\", kind='hinted')\n    v_gap = Comp(EpicsMotor,\"-Ax:VG}Mtr\", kind='hinted')\n    v_center = Comp(EpicsMotor,\"-Ax:VC}Mtr\", kind='hinted')"
  },
  {
    "class_name": "ESMSlit_type2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class ESMSlit_type2(Device):\n    h_scan = Comp(EpicsMotor,\"-Ax:HS}Mtr\")\n    h_apperture = Comp(EpicsMotor,\"-Ax:HA}Mtr\")\n    v_scan = Comp(EpicsMotor,\"-Ax:VS}Mtr\")\n    v_apperture = Comp(EpicsMotor,\"-Ax:VA}Mtr\")\n    h_gap = Comp(EpicsMotor,\"-Ax:HG}Mtr\", kind='hinted')\n    h_center = Comp(EpicsMotor,\"-Ax:HC}Mtr\", kind='hinted')\n    v_gap = Comp(EpicsMotor,\"-Ax:VG}Mtr\", kind='hinted')\n    v_center = Comp(EpicsMotor,\"-Ax:VC}Mtr\", kind='hinted')"
  },
  {
    "class_name": "ExitSlit",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class ExitSlit(Device):\n    v_gap = Comp(EpicsMotor,\"_VG}Mtr\")\n    h_gap = Comp(EpicsMotor,\"_HG}Mtr\", kind='hinted')\n    h_def = Comp(EpicsMotor,\"_HDS}Mtr\")\n    v_def = Comp(EpicsMotor,\"_VDS}Mtr\", kind='hinted')"
  },
  {
    "class_name": "DIAG",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class DIAG(Device):\n    trans = Comp(EpicsMotor,\"}Mtr\", kind='hinted')"
  },
  {
    "class_name": "Virtual_Motor_Center_And_Gap",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class Virtual_Motor_Center_And_Gap(Device):\n#This is used to combine the gap centre and size classes from above into a single class object\n    h_gap = Comp(Virtual_Size,'12-Ax:X}', kind='hinted')\n    h_center = Comp(Virtual_Center,'12-Ax:X}', kind='hinted')\n    v_gap = Comp(Virtual_Size,'12-Ax:Y}', kind='hinted')\n    v_center = Comp(Virtual_Center,'12-Ax:Y}', kind='hinted')"
  },
  {
    "class_name": "Blades",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/10-machine.py",
    "source": "class Blades(Device):\n#This creates a class for the independent motion of each of the front end slit \"blades\"\n    outboard = Comp(EpicsMotor, \"1-Ax:O}Mtr\")\n    inboard = Comp(EpicsMotor, \"2-Ax:I}Mtr\")\n    top = Comp(EpicsMotor, \"1-Ax:T}Mtr\")\n    bottom = Comp(EpicsMotor, \"2-Ax:B}Mtr\")"
  },
  {
    "class_name": "EPU",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/11-undulator.py",
    "source": "class EPU(Device):\n    gap = Cpt(UgapPositioner, '', settle_time=0, kind='hinted')\n    phase = Cpt(UphasePositioner, '', settle_time=0, kind='hinted')"
  },
  {
    "class_name": "Source",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/11-undulator.py",
    "source": "class Source(Device):\n    #This is a class to be used to define the readback values of the beam source front the\n    #front end.\n\n        #define the channels in the readback device.\n        Current=Comp(EpicsSignalRO,'OPS-BI{DCCT:1}I:Real-I', kind='hinted')\n        Xoffset=Comp(EpicsSignalRO,'C31-{AI}Aie21:Offset-x-Cal', kind='hinted')\n        Xangle=Comp(EpicsSignalRO,'C31-{AI}Aie21:Angle-x-Cal', kind='hinted')\n        Yoffset=Comp(EpicsSignalRO,'C31-{AI}Aie21:Offset-y-Cal', kind='hinted')\n        Yangle=Comp(EpicsSignalRO,'C31-{AI}Aie21:Angle-y-Cal', kind='hinted')\n\n        def status(self, output='string'):\n            '''\n            Reads the status of every axis defined for the device and outputs the result as a dictioanry or a\n            formatted string.\n\n            Reads the position of every axis for the device and returns a dictionary, returns a formatted string\n            or appends to a file.\n\n            PARAMETERS\n            ----------\n\n            output : str, optional\n                Indicates what to do with the output, default is to return a formatted string. Can take the values:\n                    - 'string', indicates the routine should return a formatted string.\n                    - 'string_and_file', indicates the routine should return a formatted string and append to a\n                       status file for the device.\n                    - 'dict', indicates the routine should return a dictionary of positions.\n\n            f_string : str\n                Possible output string for formatting.\n\n            status_dict : dict\n                Possible outputted dictionary, which has keywords for each motor in the axis list and contains\n                a dictionary of axes names and positions.\n\n            '''\n            #Define the list of EPICS signal status values.\n            det_status_dict={}\n            det_status_dict[self.name]={self.name+'_Current':self.Current.get(),\n                                        self.name+'_Xoffset':self.Xoffset.get(),\n                                        self.name+'_Xangle':self.Xangle.get(),\n                                        self.name+'_Yoffset':self.Yoffset.get(),\n                                        self.name+'_Yangle':self.Yangle.get()}\n\n            #Define the list of EPICS motor status values.\n            status_dict={}\n            status_dict['EPU_105']={'EPU105_gap':EPU105.gap.position,\n                                    'EPU105_phase':EPU105.phase.position}\n\n            status_dict['EPU57']={'EPU57_gap':EPU57.gap.position,\n                                  'EPU57_phase':EPU57.phase.position}\n\n            status_dict['FEslit']={'FEslit_h_center':FEslit.h_center.position,\n                                 'FEslit_h_gap':FEslit.h_gap.position,\n                                 'FEslit_v_center':FEslit.v_center.position,\n                                 'FEslit_v_gap':FEslit.v_gap.position}\n\n            f_string='************************************************************\\n'\n            f_string+=self.name+' STATUS:  '+time.strftime(\"%c\") + '\\n'\n            f_string+='************************************************************\\n\\n'\n\n            #step through the detectors and read the values.\n            f_string+='EPICS SIGNAL COMPONENTS\\n'\n            f_string+='-----------------------\\n'\n            for key in list(det_status_dict.keys()):\n                f_string+='    '+key+':\\n'\n                key_dict = det_status_dict[key]\n                for det in key_dict:\n                    obj,_,attr = det.partition('_')\n                    f_string+='\\t '+det+' -->  %f\\n' % getattr(ip.user_ns[obj],attr).value\n                f_string+='\\n'\n\n            # step through the motors and read the values\n            f_string+='EPICS MOTOR COMPONENTS\\n'\n            f_string+='-----------------------\\n'\n            for key in list(status_dict.keys()):\n                f_string+='    '+key+':\\n'\n                key_dict = status_dict[key]\n                for axis in key_dict:\n                    obj,_,attr = axis.partition('_')\n                    f_string+='\\t '+axis+' -->  %f\\n' % getattr(ip.user_ns[obj],attr).position\n                    f_string+='\\n'\n\n            if output.startswith('string'):\n                print (f_string)\n\n            if output.endswith('file'):\n                fl=\"/direct/XF21ID1/status_files/\"\n                fl+=self.name+'_status'\n                f = open(fl, \"a\")\n                f.write(f_string)\n                f.close()\n\n            if output == 'dict':\n                return status_dict"
  },
  {
    "class_name": "SpectrumAnalyzer",
    "bases": [
      "Device",
      "WritesStreamAssets",
      "Readable"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/30-detectors.py",
    "source": "class SpectrumAnalyzer(Device, WritesStreamAssets, Readable):\n    # Acquisition control\n    acquire = Cpt(EpicsSignal, \"ACQUIRE\")\n    acquisition_status = Cpt(EpicsSignalRO, \"ACQ:STATUS\")\n\n    # Detector control\n    det_off = Cpt(EpicsSignal, \"DET:OFF\")\n    det_max_count = Cpt(EpicsSignalRO, \"DET:MAX_COUNT\")\n    det_max_count_threshold = Cpt(EpicsSignal, \"DET:MAX_COUNT_THRESH\")\n    det_max_count_exceeded = Cpt(EpicsSignal, \"DET:MAX_COUNT_EXCEEDED\")\n\n    # Status and info\n    connection_status = Cpt(EpicsSignalRO, \"SYS:CONNECTED\")\n    last_sync = Cpt(EpicsSignalRO, \"SYS:LAST_SYNC\")\n    sync = Cpt(EpicsSignal, \"SYS:SYNC\")\n\n    # File writing\n    file_capture = Cpt(EpicsSignal, \"FILE:CAPTURE\")\n    file_name = Cpt(EpicsSignal, \"FILE:NAME\", string=True)\n    file_path = Cpt(EpicsSignal, \"FILE:PATH\", string=True)\n    file_status = Cpt(EpicsSignalRO, \"FILE:STATUS\")\n    num_captured = Cpt(EpicsSignalRO, \"FILE:NUM_CAPTURED\")\n    num_processed = Cpt(EpicsSignalRO, \"FILE:NUM_PROCESSED\")\n\n    # Detector parameters\n    state = Cpt(EpicsSignalRO, \"STATE\", string=True)\n    endX = Cpt(EpicsSignal, \"ENDX\")\n    startY = Cpt(EpicsSignal, \"STARTY\")\n    num_slice = Cpt(EpicsSignal, \"NUM_SLICE\")\n    endY = Cpt(EpicsSignal, \"ENDY\")\n    startX = Cpt(EpicsSignal, \"STARTX\")\n    frames = Cpt(EpicsSignal, \"FRAMES\")\n    num_steps = Cpt(EpicsSignal, \"NUM_STEPS\")\n    pass_energy = Cpt(EpicsSignal, \"PASS_ENERGY\")\n    lens_mode = Cpt(EpicsSignal, \"LENS_MODE\")\n    num_scans = Cpt(EpicsSignal, \"NUM_SCANS\")\n    reg_num = Cpt(EpicsSignal, \"REG_NUM\")\n    tot_steps = Cpt(EpicsSignal, \"TOT_STEPS\")\n    add_fms = Cpt(EpicsSignal, \"ADD_FMS\")\n    act_scans = Cpt(EpicsSignalRO, \"ACT_SCANS\")\n    dith_steps = Cpt(EpicsSignal, \"DITH_STEPS\")\n    start_ke = Cpt(EpicsSignal, \"START_KE\")\n    step_size = Cpt(EpicsSignal, \"STEP_SIZE\")\n    end_ke = Cpt(EpicsSignal, \"END_KE\")\n    spin_offs = Cpt(EpicsSignal, \"SPIN_OFFS\")\n    width = Cpt(EpicsSignal, \"WIDTH\")\n    center_ke = Cpt(EpicsSignal, \"CENTER_KE\")\n    first_energy = Cpt(EpicsSignal, \"FIRST_ENERGY\")\n    deflX = Cpt(EpicsSignal, \"DEFLX\")\n    deflY = Cpt(EpicsSignal, \"DEFLY\")\n    dbl10 = Cpt(EpicsSignal, \"DBL10\")\n    acq_mode = Cpt(EpicsSignal, \"ACQ_MODE\")\n    date_number = Cpt(EpicsSignal, \"DATE_NUMBER\")\n    loc_det = Cpt(EpicsSignal, \"LOC_DET\")\n    xtab = Cpt(EpicsSignal, \"XTAB\")\n    spin = Cpt(EpicsSignal, \"SPIN\")\n    reg_name = Cpt(EpicsSignal, \"REG_NAME\")\n    name_string = Cpt(EpicsSignal, \"NAME_STRING\")\n    generated_name = Cpt(EpicsSignal, \"GENERATED_NAME\")\n    comment1 = Cpt(EpicsSignal, \"COMMENT1\")\n    start_time = Cpt(EpicsSignal, \"START_TIME\")\n    discr = Cpt(EpicsSignal, \"DISCR\")\n    adc_mask = Cpt(EpicsSignal, \"ADC_MASK\")\n    adc_offset = Cpt(EpicsSignal, \"ADC_OFFSET\")\n    p_cnt_type = Cpt(EpicsSignal, \"P_CNT_TYPE\")\n    pc_mask = Cpt(EpicsSignal, \"PC_MASK\")\n    soft_bin_x = Cpt(EpicsSignal, \"SOFT_BIN_X\")\n    soft_bin_y = Cpt(EpicsSignal, \"SOFT_BIN_Y\")\n    escale_mult = Cpt(EpicsSignal, \"ESCALE_MULT\")\n    escale_max = Cpt(EpicsSignal, \"ESCALE_MAX\")\n    escale_min = Cpt(EpicsSignal, \"ESCALE_MIN\")\n    yscale_mult = Cpt(EpicsSignal, \"YSCALE_MULT\")\n    yscale_max = Cpt(EpicsSignal, \"YSCALE_MAX\")\n    yscale_min = Cpt(EpicsSignal, \"YSCALE_MIN\")\n    yscale_name = Cpt(EpicsSignal, \"YSCALE_NAME\")\n    xscale_mult = Cpt(EpicsSignal, \"XSCALE_MULT\")\n    xscale_max = Cpt(EpicsSignal, \"XSCALE_MAX\")\n    xscale_min = Cpt(EpicsSignal, \"XSCALE_MIN\")\n    xscale_name = Cpt(EpicsSignal, \"XSCALE_NAME\")\n    psu_mode = Cpt(EpicsSignal, \"PSU_MODE\")\n    over_r_arr = Cpt(EpicsSignal, \"OVER_R_ARR\")\n    over_range = Cpt(EpicsSignal, \"OVER_RANGE\")\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._status = None\n        self._index = 0\n        self._last_emitted_index = 0\n        self._composer = None\n        self._full_path = None\n\n    def stage(self):\n        if self.file_capture.get(as_string=True) == \"On\":\n            raise RuntimeError(\n                \"File capture must be off to stage the detector, otherwise the file will be corrupted\"\n            )\n        if self.state.get(as_string=True) == \"RUNNING\":\n            self.acquire.set(0).wait(3.0)\n        self.stage_sigs.update(\n            [\n                (self.file_capture, 1),\n            ]\n        )\n\n        path = _convert_path_to_posix(Path(self.file_path.get()))\n        file_name = Path(self.file_name.get())\n        self._full_path = str(path / file_name)\n        self._index = 0\n        self._last_emitted_index = 0\n\n        self.state.subscribe(self._stage_changed, run=False)\n        return super().stage()\n\n    def _stage_changed(self, value=None, old_value=None, **kwargs):\n        if self._status is None:\n            return\n        if value == \"STANDBY\" and old_value == \"RUNNING\":\n            # Settle time for the detector to transition properly\n            ttime.sleep(1.0)\n            if self.det_max_count_exceeded.get():\n                max_count = self.det_max_count.get()\n                max_count_threshold = self.det_max_count_threshold.get()\n                self._status.set_exception(\n                    RuntimeError(\n                        f\"Max count safety limit exceeded: {max_count} > {max_count_threshold}\"\n                    )\n                )\n            else:\n                self._status.set_finished()\n                self._index += 1\n            self._status = None\n\n    def trigger(self):\n        if self._staged != Staged.yes:\n            raise RuntimeError(\n                \"This detector is not ready to trigger.\"\n                \"Call the stage() method before triggering.\"\n            )\n\n        self._status = Status()\n        self.acquire.set(1).wait(1.0)\n        return self._status\n\n    def describe(self) -> dict[str, DataKey]:\n        describe = super().describe()\n        describe.update(\n            {\n                f\"{self.name}_image\": DataKey(\n                    source=f\"{self._full_path}\",\n                    shape=(1, 1080, self.num_steps.get()),\n                    dtype=\"array\",\n                    dtype_numpy=np.dtype(np.uint32).str,\n                    external=\"STREAM:\",\n                ),\n            }\n        )\n        return describe\n\n    def get_index(self) -> int:\n        return self._index\n\n    def collect_asset_docs(\n        self, index: Optional[int] = None\n    ) -> SyncOrAsyncIterator[StreamAsset]:\n        if index is not None:\n            msg = f\"Indexing is not supported for this detector, got: {index}, current index: {self.get_index()}\"\n            raise NotImplementedError(msg)\n\n        index = self.get_index()\n        if index:\n            if not self._composer:\n                self._composer = compose_stream_resource(\n                    data_key=f\"{self.name}_image\",\n                    mimetype=\"application/x-hdf5\",\n                    uri=f\"file://{self._full_path}\",\n                    parameters={\"dataset\": \"entry1/analyzer/data\"},\n                )\n                yield \"stream_resource\", self._composer.stream_resource_doc\n\n            if index >= self._last_emitted_index:\n                indices = {\n                    \"start\": self._last_emitted_index,\n                    \"stop\": index,\n                }\n                self._last_emitted_index = index\n                yield \"stream_datum\", self._composer.compose_stream_datum(indices)\n\n    def unstage(self):\n        if self.state.get(as_string=True) == \"RUNNING\":\n            self.acquire.set(0).wait(3.0)\n        self.det_off.set(1).wait(3.0)\n        super().unstage()\n        self.state.unsubscribe(self._stage_changed)\n        self._composer = None"
  },
  {
    "class_name": "flowmeter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/30-detectors.py",
    "source": "class flowmeter(Device):\n\tvalue = Cpt(EpicsSignal, 'XF:21ID1-ES{IOLogik:1}AI:1-I')"
  },
  {
    "class_name": "Lakeshore336Channel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/48-lakeshore.py",
    "source": "class Lakeshore336Channel(Device):\n    T = Cpt(EpicsSignalRO, 'T-I')\n    V = Cpt(EpicsSignalRO, 'Val:Sens-I')\n    status = Cpt(EpicsSignalRO, 'T-Sts')"
  },
  {
    "class_name": "Lakeshore336",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/48-lakeshore.py",
    "source": "class Lakeshore336(Device):\n    temp = DDC(_temp_fields(['A','B','C','D']))\n    ctrl1 = Cpt(Lakeshore336Setpoint, '-Out:1}')\n    ctrl2 = Cpt(Lakeshore336Setpoint, '-Out:2}')"
  },
  {
    "class_name": "Lakeshore336Picky",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/48-lakeshore.py",
    "source": "class Lakeshore336Picky(Device):\n    setpoint = Cpt(EpicsSignal, read_pv='-Out:1}T-RB', write_pv='-Out:1}T-SP',\n                   add_prefix=('read_pv', 'write_pv'))\n    # TODO expose ramp rate\n    ramp_done = Cpt(EpicsSignalRO, '-Out:1}Sts:Ramp-Sts')\n    ramp_enabled = Cpt(EpicsSignal, '-Out:1}Enbl:Ramp-Sel')\n    ramp_rate = Cpt(EpicsSignal, read_pv='-Out:1}Val:Ramp-RB',\n                    write_pv='-Out:1}Val:Ramp-SP',\n                    add_prefix=('read_pv', 'write_pv'))\n\n    chanA = Cpt(Lakeshore336Channel, '-Chan:A}')\n    chanB = Cpt(Lakeshore336Channel, '-Chan:B}')\n\n    def __init__(self, *args, timeout=60*60*30, target='chanA', **kwargs):\n        # do the base stuff\n        super().__init__(*args, **kwargs)\n        # status object for communication\n        self._done_sts = None\n\n        # state for deciding if we are done or not\n        self._cache = deque()\n        self._start_time = 0\n        self._setpoint = None\n        self._count = -1\n\n        # longest we can wait before giving up\n        self._timeout = timeout\n        self._lagtime = 120\n\n        # the channel to watch to see if we are done\n        self._target_channel = target\n\n        # parameters for done testing\n        self.mean_thresh = .01\n        self.ptp_thresh = .1\n\n    def _value_cb(self, value, timestamp, **kwargs):\n        self._cache.append((value, timestamp))\n\n        if (timestamp - self._cache[0][1]) < self._lagtime / 2:\n            return\n\n        while (timestamp - self._cache[0][1]) > self._lagtime:\n            self._cache.popleft()\n\n        buff = np.array([v[0] for v in self._cache])\n        if self._done_test(self._setpoint, buff):\n            self._done_sts._finished()\n            self._reset()\n\n    def _setpoint_cb(value, **kwargs):\n        print('in cb', value)\n        if value == self._setpoint:\n            self._done_sts._finished()\n            self.setpoint.clear_sub(self._setpoint_cb, 'value')\n\n    def _reset(self):\n        if self._target_channel == 'setpoint':\n            target = self.setpoint\n            target.clear_sub(self._setpoint_cb, 'value')\n        else:\n            target = getattr(self, self._target_channel).T\n            target.clear_sub(self._value_cb, 'value')\n        self._done_sts = None\n        self._setpoint = None\n        self._cache.clear()\n\n    def _done_test(self, target, buff):\n        mn = np.mean(np.abs(buff - target))\n\n        if mn > self.mean_thresh:\n            return False\n\n        if np.ptp(buff) > self.ptp_thresh:\n            return False\n\n        return True\n\n\n    def set(self, new_position, *, timeout=None):\n        # to be subscribed to 'value' cb on readback\n        sts = self._done_sts = DeviceStatus(self, timeout=timeout)\n        if self.setpoint.get() == new_position:\n            self._done_sts._finished()\n            self._done_sts = None\n            return sts\n\n        self._setpoint = new_position\n\n        self.setpoint.set(self._setpoint)\n\n        # todo, set up subscription forwarding\n        if self._target_channel == 'setpoint':\n            self.setpoint.subscribe(local_cb, 'value')\n        else:\n            target = getattr(self, self._target_channel).T\n            target.subscribe(self._value_cb, 'value')\n\n        return self._done_sts"
  },
  {
    "class_name": "DelayGeneratorChan",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/48-lakeshore.py",
    "source": "class DelayGeneratorChan(EpicsSignal):\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix + '-RB', write_pv=prefix + '-SP', **kwargs)"
  },
  {
    "class_name": "DelayGenerator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/48-lakeshore.py",
    "source": "class DelayGenerator(Device):\n    A = Cpt(DelayGeneratorChan, '-Chan:A}DO:Dly')\n    B = Cpt(DelayGeneratorChan, '-Chan:B}DO:Dly')\n    C = Cpt(DelayGeneratorChan, '-Chan:C}DO:Dly')\n    D = Cpt(DelayGeneratorChan, '-Chan:D}DO:Dly')\n    E = Cpt(DelayGeneratorChan, '-Chan:E}DO:Dly')\n    F = Cpt(DelayGeneratorChan, '-Chan:F}DO:Dly')\n    G = Cpt(DelayGeneratorChan, '-Chan:G}DO:Dly')\n    H = Cpt(DelayGeneratorChan, '-Chan:H}DO:Dly')"
  },
  {
    "class_name": "LEEMDetector",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/esm-arpes-profile-collection/startup/46-ESM_LEEM.py",
    "source": "class LEEMDetector(Device):\n    acquire = Cpt(EpicsSignal, 'start_acq')\n    fileinc = Cpt(EpicsSignal, 'fileinc')\n    filepath = Cpt(EpicsSignal, 'filepath')\n    filename = Cpt(EpicsSignal, 'filename')\n\n#    def __init__(self, *args, **kwargs):\n#        super().__init__(*args, **kwargs)\n        # On a background thread, listen for the server's response.\n#        self.st = None\n\n    def trigger(self):\n        init = 0\n        status = DeviceStatus(self)\n        # Write to server.\n        def check_if_done(old_value, value, **kwargs):\n            if init == 1:\n                if value == 0 and old_value == 1:\n                    status._finished()\n                    self.acquire.clear_sub(check_if_done)\n\n        self.acquire.subscribe(check_if_done)\n        self.acquire.set(1)\n        init = 1\n        return status"
  },
  {
    "class_name": "TimeSeries",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/15-electrometer.py",
    "source": "class TimeSeries(Device):\n    current1 = ADCpt(EpicsSignalRO, \"Current1:TimeSeries\", kind='normal')\n    current2 = ADCpt(EpicsSignalRO, \"Current2:TimeSeries\", kind='normal')\n    current3 = ADCpt(EpicsSignalRO, \"Current3:TimeSeries\", kind='normal')\n    current4 = ADCpt(EpicsSignalRO, \"Current4:TimeSeries\", kind='normal')\n\n    acquire = ADCpt(EpicsSignal, \"TSAcquire\", kind='omitted')\n    acquire_mode = ADCpt(EpicsSignal, \"TSAcquireMode\", string=True, kind='config')\n    acquiring = ADCpt(EpicsSignalRO, \"TSAcquiring\", kind='omitted')\n\n    time_axis = ADCpt(EpicsSignalRO, \"TSTimeAxis\", kind='config')\n    read_rate = ADCpt(EpicsSignal, \"TSRead.SCAN\", string=True, kind='config')\n    num_points = ADCpt(EpicsSignal, \"TSNumPoints\", kind='config')\n    averaging_time = ADCpt(EpicsSignalWithRBV, \"TSAveragingTime\", kind=\"config\")\n    current_point = ADCpt(EpicsSignalRO, \"TSCurrentPoint\", kind=\"omitted\")"
  },
  {
    "class_name": "XFP_qem2",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/15-electrometer.py",
    "source": "class XFP_qem2(Device):\n    ch1 = Cpt(EpicsSignalRO, 'Current1:MeanValue_RBV', kind='normal')\n    ch2 = Cpt(EpicsSignalRO, 'Current2:MeanValue_RBV', kind='normal')\n    ch3 = Cpt(EpicsSignalRO, 'Current3:MeanValue_RBV', kind='normal')\n    ch4 = Cpt(EpicsSignalRO, 'Current4:MeanValue_RBV', kind='normal')"
  },
  {
    "class_name": "DiodeShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/11-shutters.py",
    "source": "class DiodeShutter(Device):\n    open_close_cmd = Cpt(EpicsSignal, '1}OutPt00:Data-Sel')\n    status_open = Cpt(EpicsSignalRO, '2}InPt00:Data-Sts')\n    status_closed = Cpt(EpicsSignalRO, '2}InPt01:Data-Sts')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.allowed_values = {'Open': 1, 'Close': 0}\n\n    def set(self, value):\n        assert value in self.allowed_values.keys(), \\\n                f'The value \"{value}\" is not allowed. Allowed ones are {self.allowed_values.keys()}'\n\n        def callback(value, old_value, **kwargs):\n            # print(f'old value {old_value} --> new value {value}')\n            # print(f'status_open: {self.status_open.get()}')\n            # print(f'status_closed: {self.status_closed.get()}')\n            if old_value != value:\n                return True\n            return False\n\n        if self.status_open.get() != self.allowed_values[value]:\n            _st_open = SubscriptionStatus(self.status_open, callback, run=False)\n        else:\n            _st_open = NullStatus()\n\n        if self.status_closed.get() == self.allowed_values[value]:\n            _st_closed = SubscriptionStatus(self.status_closed, callback, run=False)\n        else:\n            _st_closed = NullStatus()\n\n        self.open_close_cmd.put(self.allowed_values[value])\n\n        return _st_open & _st_closed"
  },
  {
    "class_name": "FE_WhiteBeam_Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-fe.py",
    "source": "class FE_WhiteBeam_Slits(Device):\n    top = Cpt(EpicsMotor, '1-Ax:T}Mtr', labels=('FE Slits',))\n    bot = Cpt(EpicsMotor, '2-Ax:B}Mtr', labels=('FE Slits',))\n    inb = Cpt(EpicsMotor, '2-Ax:I}Mtr', labels=('FE Slits',))\n    outb = Cpt(EpicsMotor, '1-Ax:O}Mtr', labels=('FE Slits',))"
  },
  {
    "class_name": "XFP_FE_Mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-fe.py",
    "source": "class XFP_FE_Mirror(Device):\n    hor_up = Cpt(EpicsMotor, '-Ax:XU}Mtr', labels=('FE Mirror',))\n    hor_down = Cpt(EpicsMotor, '-Ax:XD}Mtr', labels=('FE Mirror',))\n    lift_up = Cpt(EpicsMotor, '-Ax:YUI}Mtr', labels=('FE Mirror',))\n    lift_ctr = Cpt(EpicsMotor, '-Ax:YO}Mtr', labels=('FE Mirror',))\n    lift_down = Cpt(EpicsMotor, '-Ax:YDI}Mtr', labels=('FE Mirror',))\n    focus = Cpt(EpicsMotor, '-Ax:Bend}Mtr', labels=('FE Mirror',))\n    X = Cpt(EpicsMotor, '-Ax:X}Mtr', labels=('FE Mirror',))\n    Y = Cpt(EpicsMotor, '-Ax:Y}Mtr', labels=('FE Mirror',))\n    pitch = Cpt(EpicsMotor, '-Ax:P}Mtr', labels=('FE Mirror',))\n    yaw = Cpt(EpicsMotor, '-Ax:Yaw}Mtr', labels=('FE Mirror',))\n    roll = Cpt(EpicsMotor, '-Ax:R}Mtr', labels=('FE Mirror',))\n    temp1 = Cpt(EpicsSignalRO, '}T:1-I', labels=('FE Mirror',))\n    temp2 = Cpt(EpicsSignalRO, '}T:2-I', labels=('FE Mirror',))"
  },
  {
    "class_name": "DIODE_PDM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/14-diode.py",
    "source": "class DIODE_PDM(Device):\n    array1 = Cpt(EpicsSignalRO, 'ValuesArray:1-Wf')\n    array2 = Cpt(EpicsSignalRO, 'ValuesArray:2-Wf')\n    array3 = Cpt(EpicsSignalRO, 'ValuesArray:3-Wf')\n    array4 = Cpt(EpicsSignalRO, 'ValuesArray:4-Wf')\n    array5 = Cpt(EpicsSignalRO, 'ValuesArray:5-Wf')\n    value_index_curr = Cpt(EpicsSignalRO, 'ValuesArray:NextIndex-I')\n    value_index_last = Cpt(EpicsSignalRO, 'ValuesArray:LastIndex-I')\n    array_index_curr = Cpt(EpicsSignalRO, 'StorageArray:NextIndex-I')\n    array_index_last = Cpt(EpicsSignalRO, 'StorageArray:LastIndex-I')\n    value_index_set = Cpt(EpicsSignal, 'ValuesArray:NextIndex-Sel', kind='config')\n    array_index_set = Cpt(EpicsSignal, 'StorageArray:NextIndex-Sel', kind='config')\n    clear_arrays = Cpt(EpicsSignal, 'StorageArray:Reset-Cmd')"
  },
  {
    "class_name": "AgressiveSignal",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/09-ophyd_hack.py",
    "source": "class AgressiveSignal(ophyd.EpicsSignal):\n    def set(self, value, *, timeout=None, settle_time=None):\n        '''Set is like `put`, but is here for bluesky compatibility\n\n        Returns\n        -------\n        st : Status\n            This status object will be finished upon return in the\n            case of basic soft Signals\n        '''\n        def set_thread():\n            nonlocal timeout\n            success = False\n            if timeout is None:\n                timeout = 10\n                # TODO set_and_wait does not support a timeout of None\n                #      and 10 is its default timeout\n\n            try:\n                local_set_and_wait(self, value, timeout=timeout, atol=self.tolerance,\n                                   rtol=self.rtolerance, poll_time=.001, log_backoff=1.1)\n            except TimeoutError:\n                success = False\n            except Exception as ex:\n                success = False\n            else:\n                success = True\n                if settle_time is not None:\n                    time.sleep(settle_time)\n            finally:\n                st._finished(success=success)\n                self._set_thread = None\n\n        if self._set_thread is not None:\n            raise RuntimeError('Another set() call is still in progress')\n\n        st = Status(self)\n        self._status = st\n        self._set_thread = epics.ca.CAThread(target=set_thread)\n        self._set_thread.daemon = True\n        self._set_thread.start()\n        return self._status"
  },
  {
    "class_name": "ModXY_CF",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class ModXY_CF(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', labels=('FP ES:1',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', labels=('FP ES:1',))"
  },
  {
    "class_name": "BeamPipeStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class BeamPipeStage(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', labels=('FP PDS',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', labels=('FP PDS',))"
  },
  {
    "class_name": "Table1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class Table1(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', labels=('FP ES:1',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', labels=('FP ES:1',))\n    z = Cpt(EpicsMotor, 'Z}Mtr', labels=('FP ES:1',))"
  },
  {
    "class_name": "HT",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class HT(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', labels=('FP ES:2',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', labels=('FP ES:2',))"
  },
  {
    "class_name": "HTFly",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class HTFly(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', labels=('FP ES:2',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', labels=('FP ES:2',))"
  },
  {
    "class_name": "CVDViewer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class CVDViewer(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', labels=('greenfield ES:2',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', labels=('greenfield ES:2',))"
  },
  {
    "class_name": "CFSample",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class CFSample(Device):\n    z = Cpt(EpicsMotor, 'Z}Mtr', labels=('greenfield ES:2',))"
  },
  {
    "class_name": "PBSlits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class PBSlits(Device):\n    top = Cpt(EpicsMotor, 'T}Mtr', labels=('FP PDS',))\n    bot = Cpt(EpicsMotor, 'B}Mtr', labels=('FP PDS',))\n    inb = Cpt(EpicsMotor, 'I}Mtr', labels=('FP PDS',))\n    outb = Cpt(EpicsMotor, 'O}Mtr', labels=('FP PDS',))\n    xgap = Cpt(EpicsMotor, 'XGap}Mtr', labels=('FP PDS',))\n    xctr = Cpt(EpicsMotor, 'XCtr}Mtr', labels=('FP PDS',))\n    ygap = Cpt(EpicsMotor, 'YGap}Mtr', labels=('FP PDS',))\n    yctr = Cpt(EpicsMotor, 'YCtr}Mtr', labels=('FP PDS',))"
  },
  {
    "class_name": "ADCSlits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class ADCSlits(Device):\n    top = Cpt(EpicsMotor, 'T}Mtr', labels=('FP ES:2','monochromatic ES',))\n    bot = Cpt(EpicsMotor, 'B}Mtr', labels=('FP ES:2','monochromatic ES',))\n    inb = Cpt(EpicsMotor, 'I}Mtr', labels=('FP ES:2','monochromatic ES',))\n    outb = Cpt(EpicsMotor, 'O}Mtr', labels=('FP ES:2','monochromatic ES',))\n    xgap = Cpt(EpicsMotor, 'XGap}Mtr', labels=('FP ES:2','monochromatic ES',))\n    xctr = Cpt(EpicsMotor, 'XCtr}Mtr', labels=('FP ES:2','monochromatic ES',))\n    ygap = Cpt(EpicsMotor, 'YGap}Mtr', labels=('FP ES:2','monochromatic ES',))\n    yctr = Cpt(EpicsMotor, 'YCtr}Mtr', labels=('FP ES:2','monochromatic ES',))"
  },
  {
    "class_name": "XASMono",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class XASMono(Device):\n    en = Cpt(EpicsMotor, 'En}Mtr', settle_time=0.5, labels=('monochromatic ES',))\n    theta = Cpt(EpicsMotor, 'Theta}Mtr', settle_time=0.5, labels=('monochromatic ES',))"
  },
  {
    "class_name": "Sample_Cryo",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class Sample_Cryo(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', labels=('monochromatic ES',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', labels=('monochromatic ES',))\n    z = Cpt(EpicsMotor, 'Z}Mtr', labels=('monochromatic ES',))"
  },
  {
    "class_name": "PreMonoSlits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class PreMonoSlits(Device):\n    top = Cpt(EpicsMotor, 'T}Mtr', labels=('monochromatic ES',))\n    bot = Cpt(EpicsMotor, 'B}Mtr', labels=('monochromatic ES',))\n    inb = Cpt(EpicsMotor, 'I}Mtr', labels=('monochromatic ES',))\n    outb = Cpt(EpicsMotor, 'O}Mtr', labels=('monochromatic ES',))\n    xgap = Cpt(EpicsMotor, 'XGap}Mtr', labels=('monochromatic ES',))\n    xctr = Cpt(EpicsMotor, 'XCtr}Mtr', labels=('monochromatic ES',))\n    ygap = Cpt(EpicsMotor, 'YGap}Mtr', labels=('monochromatic ES',))\n    yctr = Cpt(EpicsMotor, 'YCtr}Mtr', labels=('monochromatic ES',))"
  },
  {
    "class_name": "Table3",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class Table3(Device):\n    y = Cpt(EpicsMotor, 'Ye}Mtr', labels=('monochromatic ES',))"
  },
  {
    "class_name": "Mod12",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class Mod12(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', settle_time=2, labels=('greenfield ES:2',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', settle_time=2, labels=('greenfield ES:2',))"
  },
  {
    "class_name": "Mod34",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-motors-bl.py",
    "source": "class Mod34(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', labels=('greenfield ES:2',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', labels=('greenfield ES:2',))"
  },
  {
    "class_name": "SamplePump",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-fp-devs.py",
    "source": "class SamplePump(Device):\n    vel = Cpt(EpicsSignal, 'Val:Vel-SP')\n    vol = Cpt(EpicsSignal, 'Val:Vol-SP')\n\n    sts = Cpt(EpicsSignal, 'Sts:Flag-Sts')\n\n    slew_cmd = Cpt(EpicsSignal, 'Cmd:Slew-Cmd')\n    stop_cmd = Cpt(EpicsSignal, 'Cmd:Stop-Cmd')\n    movr_cmd = Cpt(EpicsSignal, 'Cmd:MOVR-Cmd')\n\n    sts = Cpt(EpicsSignal, 'Sts:Flag-Sts', string=True)\n\n    def kickoff(self):\n        # The timeout controls how long to wait for the pump\n        # to report it started working before assuming it is broken\n        st = DeviceStatus(self, timeout=1.5)\n        enums = self.sts.enum_strs\n        def inner_cb(value, old_value, **kwargs):\n\n            old_value, value = enums[int(old_value)], enums[int(value)]\n            # print('ko', old_value, value, time.time())\n            if value == 'Moving':\n                st._finished(success=True)\n                self.sts.clear_sub(inner_cb)\n\n        self.sts.subscribe(inner_cb)\n        self.slew_cmd.put(1)\n        return st\n\n    def complete(self):\n        st = DeviceStatus(self)\n        enums = self.sts.enum_strs\n        def inner_cb(value, old_value, **kwargs):\n            old_value, value = enums[int(old_value)], enums[int(value)]\n            # print('cp', kwargs['timestamp'], old_value, value, value == 'Stopped')\n            if value == 'Stopped':\n                st._finished(success=True)\n                self.sts.clear_sub(inner_cb)\n\n        self.sts.subscribe(inner_cb)\n\n        self.stop_cmd.put(1)\n        return st\n\n    def stop(self):\n        self.stop_cmd.put(1)"
  },
  {
    "class_name": "FractionCollector",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-fp-devs.py",
    "source": "class FractionCollector(Device):\n    run = Cpt(EpicsSignal, 'Run-Cmd')\n    end = Cpt(EpicsSignal, 'Stop-Cmd')\n    stp = Cpt(EpicsSignal, 'Pause-Cmd')\n    tube = Cpt(EpicsSignal, 'RTube-RB', write_pv='RTube-SP')\n    hm = Cpt(EpicsSignal, 'Home-Cmd')\n    ftime = Cpt(EpicsSignal, 'Time:FSize-RB', write_pv='Time:FSize-SP')\n    r1last = Cpt(EpicsSignal, 'Tube:R1Last-RB', write_pv='Tube:R1Last-SP')\n    r2last = Cpt(EpicsSignal, 'Tube:R2Last-RB', write_pv='Tube:R2Last-SP')\n    #pattern 1 = standard s-pattern; pattern 2 = left to right\n    pattern = Cpt(EpicsSignal, 'Type:Pattn-Sel', write_pv='Type:Pattn-Sel')\n    # valve 0 = waste, valve 1 = collect\n    valve = Cpt(EpicsSignal, 'Vlv-Sel', write_pv='Vlv-Sel')\n    # ftype 1 = time, ftype 2 = drops, ftype 3 = external counts\n    ftype = Cpt(EpicsSignal, 'Type:Fraction-Sel', write_pv='Type:Fraction-Sel')"
  },
  {
    "class_name": "Pump",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-fp-devs.py",
    "source": "class Pump(Device):\n    # This needs to be turned into a PV positioner\n    mode = Cpt(EpicsSignal, 'Mode', string=True)\n    direction = Cpt(EpicsSignal, 'Direction', string=True)\n\n    diameter = Cpt(EpicsSignal, 'Diameter_RBV', write_pv='Diameter')\n    infusion_rate = Cpt(AgressiveSignal, 'InfusionRate_RBV', write_pv='InfusionRate')\n    run = Cpt(EpicsSignal, 'Run', string=True)\n    state = Cpt(EpicsSignalRO, 'State_RBV', string=True)\n    infusion_volume = Cpt(AgressiveSignal, 'InfusionVolume_RBV', write_pv='InfusionVolume')\n\n    delivered = Cpt(EpicsSignalRO, 'Delivered_RBV')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._kickoff_st = None\n        self._complete_st = None\n        self.read_attrs = ['delivered']\n        self.configuration_attrs = ['diameter', 'infusion_rate', 'infusion_volume']\n    def clear_ko_cb(self):\n        if self._clear_ko_cb is not None:\n            try:\n                self._clear_ko_cb()\n            finally:\n                self._clear_ko_cb = None\n\n    def clear_cp_cb(self):\n        pass\n\n    def reset_state(self):\n        self._kickoff_st = None\n\n    def kickoff(self):\n        # house keeping to make sure this is a valid command\n        if self._kickoff_st is not None:\n            raise RuntimeError('trying to kickoff before previous kickoff done')\n\n        # set up local caches of pv information\n        enums = self.state.enum_strs\n        target = self.infusion_volume.get()\n\n        # status objects\n        self._complete_st = cp_st = DeviceStatus(self)\n        self._kickoff_st = ko_st = DeviceStatus(self)\n\n\n        def inner_cb_state(value, old_value, **kwargs):\n            '''state changed based callback to identify starting\n            '''\n            old_value, value = enums[int(old_value)], enums[int(value)]\n\n            if value == 'Interrupted':\n                ko_st._finished(success=False)\n                self.clear_ko_cb()\n\n            if value in {'Infusing', 'Withdrawing'}:\n                ko_st._finished(success=True)\n                self.clear_ko_cb()\n\n        def inner_complete_cb(value, old_value, **kwargs):\n            '''State based callback to identify finishing\n            '''\n            old_value, value = enums[int(old_value)], enums[int(value)]\n\n            if value == 'Idle' and old_value != 'Idle':\n                cp_st._finished(success=True)\n                self.clear_cp_cb()\n                self.reset_state()\n\n            if value == 'Interrupted':\n                cp_st._finished(success=False)\n                self.clear_cp_cb()\n                self.reset_state()\n\n        def inner_cb_delivered(value, **kwargs):\n            '''volume based call back as a backup'''\n            # TODO make this a smarter check!\n            if abs(value - target) < .015:\n                ko_st._finished(success=True)\n                cp_st._finished(success=True)\n                self.clear_ko_cb()\n                self.clear_cp_cb()\n                self.reset_state()\n\n        def _clear_ko_cb():\n            self.state.clear_sub(inner_cb_state)\n            self.delivered.clear_sub(inner_cb_delivered)\n\n        def _clear_cp_cb():\n            self.state.clear_sub(inner_complete_cb)\n\n        self._clear_ko_cb = _clear_ko_cb\n        self._clear_cp_cb = _clear_cp_cb\n\n\n        self.state.subscribe(inner_cb_state, run=False)\n        self.delivered.subscribe(inner_cb_delivered, run=False)\n        self.state.subscribe(inner_complete_cb, run=False)\n\n        self.run.set('Run')\n        return ko_st\n\n    def complete(self):\n        if self._complete_st is None:\n            raise RuntimeError('trying to complete before kickingoff '\n                               '(or you called complete twice)')\n        st = self._complete_st\n        self._complete_st = None\n        self._kickoff_st = None\n        return st\n\n    def stop(self, success=False):\n        if self._kickoff_st is not None:\n            self._kickoff_st._finished(success=success)\n\n        if self._complete_st is not None:\n            self._complete_st._finished(success=success)\n\n        self._complete_st = None\n        self._kickoff_st = None\n        self.run.set('Stop')"
  },
  {
    "class_name": "DelayGenerator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-fp-devs.py",
    "source": "class DelayGenerator(Device):\n    mode = Cpt(EpicsSignal, 'trigModeSetMO', write_pv='trigModeSetMO')\n    exp_time = Cpt(EpicsSignal, 'bDelaySetAO', write_pv='bDelaySetAO')\n\n    delay = Cpt(EpicsSignalRO, 'bDelayAI')\n    delay_status = Cpt(EpicsSignalRO, 'bDelayAI.STAT')\n    exp_time_status = Cpt(EpicsSignalRO, 'bDelaySetAO.STAT')\n    fire = Cpt(EpicsSignal, 'genSingleShotTrigBO', write_pv='genSingleShotTrigBO')\n\n    _complete_set = None\n    \n    def set(self, val, *, timeout=None, settle_time=None):\n        cp_st = DeviceStatus(self)\n        if val == self.delay.get():\n            cp_st._finished()\n            return cp_st\n        \n        self._complete_st = cp_st\n        rekicking = False\n        \n        def stat_monitor(value, **kwargs):\n            nonlocal rekicking\n            \n            if not rekicking and value:\n                print('err', value)\n                rekicking = True\n                print('wait, then set to 0')\n                sleep(5)\n                self.exp_time.set(0)\n                print('wait, then set to val')\n                sleep(5)\n                rekicking = False\n                self.exp_time.set(val)\n                print('rekicked')\n\n        def stat_write_monitor(value, **kwargs):\n            if value:\n                print('delay generator write failed')\n                sleep(5)\n                self.exp_time.set(self.exp_time.get())                          \n                \n        self.delay_status.subscribe(stat_monitor, run=False)\n        self.exp_time_status.subscribe(stat_write_monitor, run=False)\n        \n        def rb_monitor(value, **kwargs):\n            nonlocal rekicking\n            if rekicking:\n                print('bail')\n                return\n            \n            if np.isclose(value, val):\n                self._complete_st = None\n                self.delay_status.clear_sub(stat_monitor)\n                self.delay.clear_sub(rb_monitor)\n                self.exp_time_status.clear_sub(stat_write_monitor)\n                cp_st._finished()\n        self.delay.subscribe(rb_monitor, run=False)\n        self.exp_time.set(val)\n        \n        return cp_st\n\n    def stop(self, *, success):\n        # TODO make this less brute force\n        self.delay_status._reset_sub('value')\n        self.delay._reset_sub('value')\n        self.exp_time_status._reset_sub('value')"
  },
  {
    "class_name": "SR630",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-fp-devs.py",
    "source": "class SR630(Device):\n#Note: Channels start at 0 (i.e. setting channel to 0 is actually choosing Ch1)\n    channel = Cpt(EpicsSignal, 'rCurr_Chan', write_pv='wCurr_Chan')\n    val = Cpt(EpicsSignalRO, 'rCurr_Measure')\n    unit = Cpt(EpicsSignalRO, 'rCurr_Units', string=True)"
  },
  {
    "class_name": "QuadEM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/10-fp-devs.py",
    "source": "class QuadEM(Device):\n#    ch1 = Cpt(EpicsSignalRO, 'EM180:Current1:MeanValue_RBV')\n#    ch2 = Cpt(EpicsSignalRO, 'EM180:Current2:MeanValue_RBV')\n    ch3 = Cpt(EpicsSignalRO, 'EM180:Current3:MeanValue_RBV')"
  },
  {
    "class_name": "SydorBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/20-bpm.py",
    "source": "class SydorBPM(Device):\n    chan_a = Cpt(EpicsSignalRO, 'Current1:MeanValue_RBV', labels=('Sydor BPM',))\n    chan_b = Cpt(EpicsSignalRO, 'Current2:MeanValue_RBV', labels=('Sydor BPM',))\n    chan_c = Cpt(EpicsSignalRO, 'Current3:MeanValue_RBV', labels=('Sydor BPM',))\n    chan_d = Cpt(EpicsSignalRO, 'Current4:MeanValue_RBV', labels=('Sydor BPM',))\n    pos_X = Cpt(EpicsSignalRO, 'PosX:MeanValue_RBV', labels=('Sydor BPM',))\n    pos_Y = Cpt(EpicsSignalRO, 'PosY:MeanValue_RBV', labels=('Sydor BPM',))\n    sum_curr = Cpt(EpicsSignalRO, 'SumAll:MeanValue_RBV', labels=('Sydor BPM',))"
  },
  {
    "class_name": "DBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/20-bpm.py",
    "source": "class DBPM(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr', labels=('FP PDS', 'Sydor BPM',))\n    y = Cpt(EpicsMotor, 'Y}Mtr', labels=('FP PDS', 'Sydor BPM',))"
  },
  {
    "class_name": "SydorPBG",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfp-profile-collection/startup/20-bpm.py",
    "source": "class SydorPBG(Device):\n    temp_w = Cpt(EpicsSignalRO, 'ThermocoupleW', labels=('Sydor BPM',))\n    temp_x = Cpt(EpicsSignalRO, 'ThermocoupleX', labels=('Sydor BPM',))\n    temp_y = Cpt(EpicsSignalRO, 'ThermocoupleY', labels=('Sydor BPM',))\n    temp_z = Cpt(EpicsSignalRO, 'ThermocoupleZ', labels=('Sydor BPM',))\n    amp = Cpt(EpicsSignal, 'Amplitude', kind='config', labels=('Sydor BPM',))\n    mode = Cpt(EpicsSignal, 'Mode', kind='config', labels=('Sydor BPM',))\n    polarity = Cpt(EpicsSignal, 'Polarity', kind='config', labels=('Sydor BPM',))"
  },
  {
    "class_name": "XPDShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/80-areadetector.py",
    "source": "class XPDShutter(Device):\n    cmd = C(EpicsSignal, 'Cmd-Cmd')\n    close_sts = C(EpicsSignalRO, 'Sw:Cls1-Sts')\n    open_sts = C(EpicsSignalRO, 'Sw:Opn1-Sts')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._st = None\n        self._target = None\n        self.close_sts.subscribe(self._watcher_close,\n                                 self.close_sts.SUB_VALUE)\n\n        self.open_sts.subscribe(self._watcher_open,\n                                 self.open_sts.SUB_VALUE)\n\n    def set(self, value, *, wait=False, **kwargs):\n        if value not in ('Open', 'Close'):\n            raise ValueError(\n                \"must be 'Open' or 'Close', not {!r}\".format(value))\n        if wait:\n            raise RuntimeError()\n        if self._st is not None:\n            raise RuntimeError()\n        self._target = value\n        self._st = st = DeviceStatus(self, timeout=None)\n        self.cmd.put(value)\n\n        return st\n\n    def _watcher_open(self, *, old_value=None, value=None, **kwargs):\n        print(\"in open watcher\", old_value, value)\n        if self._target != 'Open':\n            return\n        if self._st is None:\n            return\n\n        if new_value:\n            self._st._finished()\n            self._target = None\n            self._st = None\n        print(\"in open watcher\")\n\n    def _watcher_close(self, *, old_value=None, value=None, **kwargs):\n        print(\"in close watcher\", old_value, value)\n        if self._target != 'Close':\n            return\n\n        if self._st is None:\n            return\n\n        if new_value:\n            self._st._finished()\n            self._target = None\n            self._st = None\n\n        pass"
  },
  {
    "class_name": "Control",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/02-adaptive.py",
    "source": "class Control(Device):\n    \"\"\"Soft device to inject computed pseudo positions.\"\"\"\n\n    Ti = Cpt(SignalWithUnits, value=0, units=\"percent TI\", kind=\"hinted\")\n    temp = Cpt(SignalWithUnits, value=0, units=\"degrees C\", kind=\"hinted\")\n    annealing_time = Cpt(SignalWithUnits, value=0, units=\"s\", kind=\"hinted\")\n    thickness = Cpt(SignalWithUnits, value=0, units=\"enum\", kind=\"hinted\")"
  },
  {
    "class_name": "FilterBank",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/10-motors.py",
    "source": "class FilterBank(ophyd.Device):\n    flt1 = ophyd.Component(EpicsSignal, '1-Cmd', string=True)\n    flt2 = ophyd.Component(EpicsSignal, '2-Cmd', string=True)\n    flt3 = ophyd.Component(EpicsSignal, '3-Cmd', string=True)\n    flt4 = ophyd.Component(EpicsSignal, '4-Cmd', string=True)"
  },
  {
    "class_name": "RGA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/12-rga.py",
    "source": "class RGA(Device):\n    startRGA = Cpt(EpicsSignal, 'Cmd:MID_Start-Cmd')\n    stopRGA = Cpt(EpicsSignal, 'Cmd:ScanAbort-Cmd')\n    mass1 = Cpt(EpicsSignalRO, 'P:MID1-I')\n    mass2 = Cpt(EpicsSignalRO, 'P:MID2-I')\n    mass3 = Cpt(EpicsSignalRO, 'P:MID3-I')\n    mass4 = Cpt(EpicsSignalRO, 'P:MID4-I')\n    mass5 = Cpt(EpicsSignalRO, 'P:MID5-I')\n    mass6 = Cpt(EpicsSignalRO, 'P:MID6-I')\n    mass7 = Cpt(EpicsSignalRO, 'P:MID7-I')\n    mass8 = Cpt(EpicsSignalRO, 'P:MID8-I')\n    mass9 = Cpt(EpicsSignalRO, 'P:MID9-I')"
  },
  {
    "class_name": "CurrentSetterEpicSignal",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/95-flash.py",
    "source": "class CurrentSetterEpicSignal(EpicsSignal):\n    def stop(self, success=False):\n        self.parent.enabled.put(0)"
  },
  {
    "class_name": "CurrentEnable",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/95-flash.py",
    "source": "class CurrentEnable(EpicsSignal):\n    def stop(self, success=False):\n        self.put(0)"
  },
  {
    "class_name": "FlashRampInternals",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/95-flash.py",
    "source": "class FlashRampInternals(Device):\n    next_sp = Cpt(EpicsSignalRO, 'I:Next-SP')\n    next_min = Cpt(EpicsSignalRO, 'I:Next-Min')\n    sp1 = Cpt(EpicsSignalRO, 'I:OutMain-SP1')\n    sp = Cpt(EpicsSignalRO, 'I:OutMain-SP')\n    scheduler = Cpt(EpicsSignalRO, 'I:Scheduler')"
  },
  {
    "class_name": "FlakySignal",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/95-flash.py",
    "source": "class FlakySignal(EpicsSignal):\n    def get(self, *args, **kwargs):\n        N = 5\n        for j in range(N):\n            v = super().get(*args, **kwargs)\n            if v is not None:\n                return v\n        else:\n            raise RuntimeError(\n                f\"{self}.get got {N} None readings?!?\")"
  },
  {
    "class_name": "FlashPower",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/95-flash.py",
    "source": "class FlashPower(Device):\n    # stuff from PSU sorensonxg850.template\n    current = Cpt(EpicsSignalRO, 'I-I', kind='hinted')\n    voltage = Cpt(EpicsSignalRO, 'E-I', kind='hinted')\n\n    current_sp = Cpt(CurrentSetterEpicSignal,\n                     'I-Lim',\n                     write_pv='I-Lim')\n    voltage_sp = Cpt(FlakySignal,\n                     'E:OutMain-RB',\n                     write_pv='E:OutMain-SP',\n                     tolerance=.01)\n\n    enabled = Cpt(CurrentEnable,\n                  'Enbl:OutMain-Sts',\n                  write_pv='Enbl:OutMain-Cmd',\n                  kind='omitted',\n                  string=True)\n\n    remote_lockout = Cpt(EpicsSignal,\n                         'Enbl:Lock-Sts',\n                         write_pv='Enbl:Lock-Cmd',\n                         string=True,\n                         kind='config')\n\n    foldback_mode = Cpt(EpicsSignal,\n                        'Mode:Fold-Sts',\n                        write_pv='Mode:Fold-Sel',\n                        string=True,\n                        kind='config')\n\n    over_volt_val = Cpt(EpicsSignal,\n                        'E:OverProt-RB',\n                        write_pv='E:OverProt-SP',\n                        kind='config')\n\n    protection_reset = Cpt(\n        EpicsSignal, 'Reset:FoldProt-Cmd',\n        kind='omitted')\n\n    status = Cpt(EpicsSignalRO, 'Sts:Opr-Sts')\n\n    # stuff from ramp_rate.db\n    ramp_rate = Cpt(EpicsSignal,\n                    'I-RampRate-RB',\n                    write_pv='I-RampRate-I',\n                    kind='config')\n\n    delta = Cpt(EpicsSignalRO,\n                'I-Delta',\n                kind='config')\n\n    mode = Cpt(EpicsSignal, 'UserMode-I',\n               string=True,\n               kind='config')\n\n    ramp_done = Cpt(EpicsSignalRO,\n                    'CurrRamp-Done',\n                    kind='omitted')\n\n    _internals = Cpt(FlashRampInternals, '', kind='omitted')\n\n    def unstage(self):\n        ret = super().unstage()\n        self.enabled.put(0)\n        return ret\n\n    def stop(self, success=False):\n        # for safety\n        self.enabled.put(0)"
  },
  {
    "class_name": "KeithlyMMChannel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/95-flash.py",
    "source": "class KeithlyMMChannel(Device):\n    chanafunc = Cpt(EpicsSignal, \"ChanAFunc\")\n    chanaresults = Cpt(EpicsSignal, \"ChanAResults\")\n    chanatimes = Cpt(EpicsSignal, \"ChanATimes\")\n    chanaenable = Cpt(EpicsSignal, \"ChanAEnable\")\n\n    chanbfunc = Cpt(EpicsSignal, \"ChanBFunc\")\n    chanbresults = Cpt(EpicsSignal, \"ChanBResults\")\n    chanbtimes = Cpt(EpicsSignal, \"ChanBTimes\")\n    chanbenable = Cpt(EpicsSignal, \"ChanBEnable\")"
  },
  {
    "class_name": "KeithlyMM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/95-flash.py",
    "source": "class KeithlyMM(Device):\n    # these are the ones documented in the readme\n    readtype = Cpt(EpicsSignal, \"ReadType\", kind='config',\n                   string=True)\n    # the readme says you get one or the other which seems odd?\n    readcurr = Cpt(EpicsSignal, \"ReadCurr\", kind='hinted')\n    readvolt = Cpt(EpicsSignal, \"ReadVolt\", kind='hinted')\n\n    synctype = Cpt(EpicsSignal, \"SyncType\", kind='config')\n\n    # other records in db file, not sure what to do with\n    test = Cpt(EpicsSignal, \"test\", kind='omitted')\n\n    timetotal = Cpt(EpicsSignal, \"TimeTotal\", kind='omitted')\n\n    # this looks like a way to buffer in device?\n    scaninterval = Cpt(EpicsSignal, \"ScanInterval\", kind='omitted')\n    numchannels = Cpt(EpicsSignal, \"NumChannels\", kind='omitted')\n    scancount = Cpt(EpicsSignal, \"ScanCount\", kind='omitted')\n\n    func = Cpt(EpicsSignal, \"Func\", kind='omitted')\n\n    # these seems important?\n    scanresults = Cpt(EpicsSignal, \"ScanResults\", kind='omitted')\n    timestamp = Cpt(EpicsSignal, \"Timestamp\", kind='omitted')\n    timestampfrac = Cpt(EpicsSignal, \"TimestampFrac\", kind='omitted')\n    timestampint = Cpt(EpicsSignal, \"TimestampInt\", kind='omitted')\n\n    readtypeseq = Cpt(EpicsSignal, \"ReadTypeSeq\", kind='omitted')"
  },
  {
    "class_name": "Robot",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/85-robot.py",
    "source": "class Robot(Device):\n    sample_number = Cpt(EpicsSignal, 'ID:Tgt-SP')\n    load_cmd = Cpt(EpicsSignal, 'Cmd:Load-Cmd.PROC')\n    unload_cmd = Cpt(EpicsSignal, 'Cmd:Unload-Cmd.PROC')\n    execute_cmd = Cpt(EpicsSignal, 'Cmd:Exec-Cmd')\n    status = Cpt(EpicsSignal, 'Sts-Sts')\n    current_sample_number = Cpt(EpicsSignalRO, 'Addr:CurrSmpl-I')\n\n    # Map sample types to their load position and measurement position.\n    TH_POS = {'capillary': {'load': None, 'measure': None},\n              'plate': {'load': 0, 'measure': 90},\n              None: {'load': None, 'measure': None}, }\n    REL_MOVES = ['plate']\n\n    DIFF_POS = {'capilary': (1, 2), }\n\n    def __init__(self, *args, theta, diff=None, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        theta : motor\n        diff : motor, optional [not currently used]\n        \"\"\"\n        self.theta = theta\n        self._current_sample_geometry = SAMPLE_GEOMETRY_NULL\n        super().__init__(*args, **kwargs)\n\n    def _poll_until_idle(self):\n        time.sleep(3)  # give it plenty of time to start\n        while self.status.get() != 'Idle':\n            time.sleep(.1)\n\n    def _poll_until_sample_cleared(self):\n        while self.current_sample_number.get() != 0:\n            time.sleep(.1)\n\n    def load_sample(self, sample_number, sample_geometry=None):\n        # If no sample is loaded, current_sample_number=0\n        # is reported by the robot.\n        if self.current_sample_number.get() != 0:\n            raise RuntimeError(\n                \"Sample %d is already loaded.\" % self.current_sample_number.get())\n\n        # Rotate theta into loading position if necessary (e.g. flat plate mode).\n        load_pos = self.TH_POS[sample_geometry]['load']\n        if load_pos is not None:\n            if sample_geometry not in self.REL_MOVES:\n                print('Moving theta to load position')\n                self.theta.move(load_pos, wait=True)\n\n        # Loading the sample is a three-step procedure:\n        # Set sample_number; issue load_cmd; issue execute_cmd.\n        set_and_wait(self.sample_number, sample_number)\n        set_and_wait(self.load_cmd, 1)\n        self.execute_cmd.put(1)\n        print('Loading...')\n        self._poll_until_idle()\n\n        # Rotate theta into measurement position if necessary (e.g. flat plate mode).\n        measure_pos = self.TH_POS[sample_geometry]['measure']\n        if measure_pos is not None:\n            print('Moving theta to measure position')\n            if sample_geometry not in self.REL_MOVES:\n                self.theta.move(measure_pos, wait=True)\n            else:\n                pos = self.theta.get().user_readback\n                self.theta.move(pos + measure_pos, wait=True)\n\n        # Stash the current sample geometry for reference when we unload.\n        self._current_sample_geometry = sample_geometry\n\n    def unload_sample(self):\n        if self.current_sample_number.get() == 0:\n            # there is nothing to do\n            return\n\n        # Rotate theta into loading position if necessary (e.g. flat plate mode)\n        if self._current_sample_geometry == SAMPLE_GEOMETRY_NULL:\n            raise RuntimeError(\"Unknown current sample geometry, can not unload\")\n        load_pos = self.TH_POS[self._current_sample_geometry]['load']\n        measure_pos = self.TH_POS[self._current_sample_geometry]['measure']\n        print(load_pos, measure_pos)\n        if load_pos is not None:\n            print('Moving theta to unload position')\n            if self._current_sample_geometry not in self.REL_MOVES:\n                self.theta.move(load_pos, wait=True)\n            else:\n                pos = self.theta.get().user_readback\n                self.theta.move(pos - measure_pos, wait=True)\n\n        set_and_wait(self.unload_cmd, 1)\n        self.execute_cmd.put(1)\n        print('Unloading...')\n        self._poll_until_idle()\n        self._poll_until_sample_cleared()\n        self._current_sample_geometry = SAMPLE_GEOMETRY_NULL\n\n    def stop(self):\n        self.theta.stop()\n        super().stop()"
  },
  {
    "class_name": "Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/15-optics.py",
    "source": "class Slits(Device):\n    t = Cpt(EpicsMotor, '-Ax:T}Mtr')\n    b = Cpt(EpicsMotor, '-Ax:B}Mtr')\n    i = Cpt(EpicsMotor, '-Ax:I}Mtr')\n    o = Cpt(EpicsMotor, '-Ax:O}Mtr')\n    xc = Cpt(EpicsMotor, '-Ax:XCtr}Mtr')\n    xg = Cpt(EpicsMotor, '-Ax:XGap}Mtr')\n    yc = Cpt(EpicsMotor, '-Ax:YCtr}Mtr')\n    yg = Cpt(EpicsMotor, '-Ax:YGap}Mtr')"
  },
  {
    "class_name": "Eurotherm",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/11-temperature-controller.py",
    "source": "class Eurotherm(Device):\n    temperature = Cpt(\n        EpicsSignalPositioner,\n        'T-I',\n        write_pv='T-SP',\n        tolerance=1,\n        #write_timeout=1000000\n    )\n    power = Cpt(\n        EpicsSignalPositioner,\n        'Out-I',\n        write_pv='Out-SP',\n        tolerance=1,\n        #write_timeout=1000\n    )\n    mode = Cpt(\n        EpicsSignal,\n        'Mode:Man-Sts',\n        write_pv='Mode:Man-Cmd',\n        kind='config',\n        string=True\n    )\n    ramprate = Cpt(\n        EpicsSignalPositioner,\n        'Rate:Ramp-RB',\n        write_pv='Rate:Ramp-SP',\n        tolerance=1\n    )\n    setread = Cpt(\n        EpicsSignalPositioner,\n        'Disp-Line2',\n        #write_pv='Rate:Ramp-SP',\n        tolerance=1\n    )"
  },
  {
    "class_name": "CryoStat",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/11-temperature-controller.py",
    "source": "class CryoStat(Device):\n    # readback\n    T = Cpt(EpicsSignalRO, ':IN1')\n    # setpoint\n    setpoint = Cpt(EpicsSignal, read_pv=\":OUT1:SP_RBV\",\n                   write_pv=\":OUT1:SP\",\n                   add_prefix=('suffix', 'read_pv', 'write_pv'))\n    # heater power level\n    heater = Cpt(EpicsSignal, ':HTR1')\n\n    # configuration\n    dead_band = Cpt(AttributeSignal, attr='_dead_band')\n    heater_range = Cpt(EpicsSignal, ':HTR1:Range', string=True)\n    scan = Cpt(EpicsSignal, ':read.SCAN', string=True)\n    mode = Cpt(EpicsSignal, ':OUT1:Mode', string=True)\n    cntrl = Cpt(EpicsSignal, ':OUT1:Cntrl', string=True)\n    # trigger signal\n    trig = Cpt(EpicsSignal, ':read.PROC')\n\n    def trigger(self):\n        self.trig.put(1, wait=True)\n        return DeviceStatus(self, done=True, success=True)\n\n    def __init__(self, *args, dead_band, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['T', 'setpoint']\n        if configuration_attrs is None:\n            configuration_attrs = ['heater_range', 'dead_band',\n                                   'mode', 'cntrl']\n        super().__init__(*args, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         **kwargs)\n        self._target = None\n        self._dead_band = dead_band\n        self._sts = None\n\n    def _sts_mon(self, value, **kwargs):\n        if (self._target is None or\n                 np.abs(self._target - value) < self._dead_band):\n            self.T.clear_sub(self._sts_mon)\n            self.scan.put('Passive', wait=True)\n            if self._sts is not None:\n                self._sts._finished()\n                self._sts = None\n            self._target = None\n\n    def set(self, val):\n        self._target = val\n        self.setpoint.put(val, wait=True)\n        sts = self._sts = DeviceStatus(self)\n        self.scan.put('.2 second')\n        self.T.subscribe(self._sts_mon)\n\n        return sts\n\n    def stop(self, *, success=False):\n        self.setpoint.put(self.T.get())\n        if self._sts is not None:\n            self._sts._finished(success=success)\n        self._sts = None\n        self._target = None\n        self.scan.put('Passive', wait=True)"
  },
  {
    "class_name": "XPDGasSwitcher",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xpd-profile-collection/startup/70-gas_switcher.py",
    "source": "class XPDGasSwitcher(Device):\n    # The values here are integer, so this tolerance is just made up.\n    current_pos = Cpt(EpicsSignal, 'Pos-I',\n                      write_pv='Pos-SP', tolerance=0.01 )\n    requested_pos = Cpt(EpicsSignal, 'Pos-SP')\n\n    current_gas = Cpt(GasSignal, parent_attr_name='current_pos')\n    requested_gas = Cpt(GasSignal, parent_attr_name='requested_pos')\n\n    def __init__(self, *args, gas_list=None, **kwargs):\n        if gas_list is None:\n            gas_list = []\n        self.gas_list = gas_list\n        super().__init__(*args, **kwargs)\n\n    def set(self, value):\n        \"\"\"value should be a string like 'Ni'\"\"\"\n        # This looks confusing, but it's correct and tested.\n        if value not in self.gas_list:\n            raise KeyError(\"There is no gas %s in gas_list. \"\n                           \"Update list or use one of these: %r\"\n                           % (value, self.gas_list))\n        return self.current_gas.set(value)"
  },
  {
    "class_name": "MaiaStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/xfm-maia-profile-collection/startup/11-stages.py",
    "source": "class MaiaStage(Device):\n    x    = Cpt(EpicsMotor, '{PI180:1-Ax:MaiaX}Mtr')\n    y    = Cpt(EpicsMotor, '{PI180:1-Ax:MaiaY}Mtr')\n    z    = Cpt(EpicsMotor, '{PI180:1-Ax:MaiaZ}Mtr')\n    r    = Cpt(EpicsMotor, '{SR50pp:1-Ax:MaiaR}Mtr')"
  },
  {
    "class_name": "Amptek",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/amptek.py",
    "source": "class Amptek(Device):\n    \"\"\"\n    Amptek detector device.\n    \"\"\"\n    mca = Cpt(AmptekMCA, \"mca1\")\n    dwell = Cpt(EpicsSignal, \"Dwell\")\n    energy_channels = Cpt(Signal, value=energy_channels)"
  },
  {
    "class_name": "AmptekPositions",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/amptek.py",
    "source": "class AmptekPositions(Device):\n    \"\"\"\n    Amptek motor positions.\n    \"\"\"\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")"
  },
  {
    "class_name": "SAXSBeamStops",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/beamstop.py",
    "source": "class SAXSBeamStops(Device):\n    x_rod = Cpt(EpicsMotor, \"IBB}Mtr\")\n    y_rod = Cpt(EpicsMotor, \"IBM}Mtr\")\n    x_pin = Cpt(EpicsMotor, \"OBB}Mtr\")\n    y_pin = Cpt(EpicsMotor, \"OBM}Mtr\")"
  },
  {
    "class_name": "FakeDetector",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/pilatus.py",
    "source": "class FakeDetector(Device):\n    acq_time = Cpt(Signal, value=10)\n\n    _default_configuration_attrs = (\"acq_time\",)\n    _default_read_attrs = ()\n\n    def trigger(self):\n        st = self.st = DeviceStatus(self)\n\n        from threading import Timer\n\n        self.t = Timer(self.acq_time.get(), st._finished)\n        self.t.start()\n        return st"
  },
  {
    "class_name": "SAXSPositions",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/pilatus.py",
    "source": "class SAXSPositions(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")"
  },
  {
    "class_name": "WAXS_Motors",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/pilatus.py",
    "source": "class WAXS_Motors(Device):\n    arc = Cpt(EpicsMotor, \"WAXS:1-Ax:Arc}Mtr\")\n    bs_x = Cpt(EpicsMotor, \"MCS:1-Ax:5}Mtr\")\n    bs_y = Cpt(EpicsMotor, \"BS:WAXS-Ax:y}Mtr\")\n    test = 5\n    bsx_offset = -54.8600000 \n                # offset from the beam center to the beamstop in mm\n                # this value should be reset in the motor offset - not here\n                # the procedure is to move the motor to the negative limit (outboard) and run home_forward.set(1) on the waxs beamstop x\n                # waxs.bs_x.home_forward.set(1).  this should reset position correctly\n                # if the beamstop mounting is changed or bent, this value may need to be tweaked\n    bsz_offset = 249.69871 \n                # distance from the center of arc rotation (sample position) to the beamstop\n                # in mm   \n                # if the beamstop mounting is changed or bent, this value may need to be tweaked\n    bsx_safe_pos = -100 \n                # x position of the beamstop when it IS NOT in the beam (out of the way direct beam and scattering)\n    \n    # when moving the waxs detector, the beamstop must be moved to a new position\n    # the beamstop is moved to a new position based on the angle of the waxs detector\n    def set(self, arc_value):\n        st_arc = self.arc.set(arc_value)\n        # start moving the arc stage and return the status\n\n        if self.arc.limits[0] <= arc_value <= 10.1:\n            calc_value = self.calc_waxs_bsx(arc_value)\n            # calculate the position of the beamstop based on the angle of the waxs detector\n        elif 10.1 < arc_value <= 13:\n            # the beamstop cannot be moved to block the beam\n            # this move is not safe\n            raise ValueError(\n                f\"The waxs detector cannot be moved to {arc_value} deg \\n\"\n                \"Do NOT take data between 10.1 and 13 degrees WAXS arc\"   \n            )\n        else:\n            calc_value = self.bsx_safe_pos # out of the path of the beam and scattering\n\n        st_x = self.bs_x.set(calc_value)\n        # move the beamstop to the new position\n        return st_arc & st_x # return both statuses\n    def stop(self, *args, **kwargs):\n        # stop the arc stage and the beamstop\n        st_arc = self.arc.stop()\n        st_x = self.bs_x.stop()\n        return st_arc & st_x\n    # calculate the position of the beamstop based on the angle of the waxs detector\n    # the beamstop is on the arc stage, so as the angle of the waxs detector changes, the position of the beamstop must also change\n    def calc_waxs_bsx(self, arc_value):\n        bsx_pos = ( \n            self.bsx_offset # offset from the beam center to the beamstop in mm\n            - (self.bsz_offset # distance from the center of arc rotation (sample position) to the beamstop\n            * np.tan( # beamstop movement is a linear movement on the arc stage\n                np.deg2rad(arc_value)))) # the angle of the waxs detector arc in degrees\n        # 2025 March 26\n        \n        return bsx_pos"
  },
  {
    "class_name": "DetMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/pilatus.py",
    "source": "class DetMotor(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")"
  },
  {
    "class_name": "MotorCenterAndGap",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/motors.py",
    "source": "class MotorCenterAndGap(Device):\n    \"Center and gap using Epics Motor records\"\n    xc = Cpt(EpicsMotor, \"-Ax:XC}Mtr\")\n    yc = Cpt(EpicsMotor, \"-Ax:YC}Mtr\")\n    xg = Cpt(EpicsMotor, \"-Ax:XG}Mtr\")\n    yg = Cpt(EpicsMotor, \"-Ax:YG}Mtr\")"
  },
  {
    "class_name": "Blades",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/motors.py",
    "source": "class Blades(Device):\n    \"Actual T/B/O/I and virtual center/gap using Epics Motor records\"\n    tp = Cpt(EpicsMotor, \"-Ax:T}Mtr\")\n    bt = Cpt(EpicsMotor, \"-Ax:B}Mtr\")\n    ob = Cpt(EpicsMotor, \"-Ax:O}Mtr\")\n    ib = Cpt(EpicsMotor, \"-Ax:I}Mtr\")\n    xc = Cpt(EpicsMotor, \"-Ax:XCtr}Mtr\")\n    yc = Cpt(EpicsMotor, \"-Ax:YCtr}Mtr\")\n    xg = Cpt(EpicsMotor, \"-Ax:XGap}Mtr\")\n    yg = Cpt(EpicsMotor, \"-Ax:YGap}Mtr\")"
  },
  {
    "class_name": "DetMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/motors.py",
    "source": "class DetMotor(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")"
  },
  {
    "class_name": "SAXSBeamStop",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/motors.py",
    "source": "class SAXSBeamStop(Device):\n    x = Cpt(EpicsMotor, \"IBB}Mtr\")\n    pad = Cpt(EpicsMotor, \"OBT}Mtr\")\n    y = Cpt(EpicsMotor, \"IBM}Mtr\")"
  },
  {
    "class_name": "SAXSPindiode",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/motors.py",
    "source": "class SAXSPindiode(Device):\n    x = Cpt(EpicsMotor, \"OBB}Mtr\")\n    y = Cpt(EpicsMotor, \"OBM}Mtr\")"
  },
  {
    "class_name": "MDriveMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/motors.py",
    "source": "class MDriveMotor(Device):\n    '''\n    Added by YZhang@2023Nov9\n    '''\n    m1 = Cpt(EpicsMotor, \"1}Mtr\")\n    m2 = Cpt(EpicsMotor, \"2}Mtr\")\n    m3 = Cpt(EpicsMotor, \"3}Mtr\")\n    m4 = Cpt(EpicsMotor, \"4}Mtr\")\n    m5 = Cpt(EpicsMotor, \"5}Mtr\")\n    m6 = Cpt(EpicsMotor, \"6}Mtr\")\n    m7 = Cpt(EpicsMotor, \"7}Mtr\")\n    m8 = Cpt(EpicsMotor, \"8}Mtr\")"
  },
  {
    "class_name": "sample_chamber_pressure",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/waxschamber.py",
    "source": "class sample_chamber_pressure(Device):\n    waxs = Cpt(EpicsSignal, \"{Det:300KW-TCG:7}P:Raw-I\")  # Change PVs\n    maxs = Cpt(EpicsSignal, \"{B1:WAXS-TCG:9}P:Raw-I\")"
  },
  {
    "class_name": "LinkamThermal",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/linkam.py",
    "source": "class LinkamThermal(Device):\n    # Set-and-read signals\n    cmd = Cpt(EpicsSignal, \"STARTHEAT\")\n    temperature_setpoint = Cpt(EpicsSignal, \"SETPOINT:SET\")\n    temperature_rate_setpoint = Cpt(EpicsSignal, \"RAMPRATE:SET\")\n\n    SysReset = Cpt(EpicsSignal, \"SysReset\")\n\n    # Read-Only signals\n    status_power = Cpt(EpicsSignalRO, \"STARTHEAT\")\n    status_code = Cpt(EpicsSignalRO, \"STATUS\")\n    # status_code = Cpt(EpicsSignal, 'STATUS')\n    # done = Cpt(AtSetpoint, parent_attr = 'status_code')\n    temperature_current = Cpt(EpicsSignalRO, \"TEMP\")\n    temperature_rate_current = Cpt(EpicsSignalRO, \"RAMPRATE\")\n\n    # not commonly used\n    init = Cpt(EpicsSignal, \"INIT\")\n    model_array = Cpt(EpicsSignal, \"MODEL\")\n    serial_array = Cpt(EpicsSignal, \"SERIAL\")\n    stage_model_array = Cpt(EpicsSignal, \"STAGE:MODEL\")\n    stage_serial_array = Cpt(EpicsSignal, \"STAGE:SERIAL\")\n    firm_ver = Cpt(EpicsSignal, \"FIRM:VER\")\n    hard_ver = Cpt(EpicsSignal, \"HARD:VER\")\n    ctrllr_err = Cpt(EpicsSignal, \"CTRLLR:ERR\")\n    config = Cpt(EpicsSignal, \"CONFIG\")\n    stage_config = Cpt(EpicsSignal, \"STAGE:CONFIG\")\n    disable = Cpt(EpicsSignal, \"DISABLE\")\n    dsc = Cpt(EpicsSignal, \"DSC\")\n    # RR_set = Cpt(EpicsSignal, 'RAMPRATE:SET')\n    # RR = Cpt(EpicsSignal, 'RAMPRATE')\n    ramptime = Cpt(EpicsSignal, \"RAMPTIME\")\n    # startheat = Cpt(EpicsSignal, 'STARTHEAT')\n    holdtime_set = Cpt(EpicsSignal, \"HOLDTIME:SET\")\n    holdtime = Cpt(EpicsSignal, \"HOLDTIME\")\n    power = Cpt(EpicsSignalRO, \"POWER\")\n    lnp_speed = Cpt(EpicsSignal, \"LNP_SPEED\")\n    lnp_mode_set = Cpt(EpicsSignal, \"LNP_MODE:SET\")\n    lnp_speed_set = Cpt(EpicsSignal, \"LNP_SPEED:SET\")\n\n    def on(self):\n        return self.cmd.put(1)\n\n    def _on(self):\n        yield from bps.mv(self.cmd, 1)\n\n    def off(self):\n        return self.cmd.put(0)\n\n    def _off(self):\n        yield from bps.mv(self.cmd, 0)\n\n    def setTemperature(self, temperature):\n        return self.temperature_setpoint.put(temperature)\n\n    def setTemperatureRate(self, temperature_rate):\n        return self.temperature_rate_setpoint.put(temperature_rate)\n\n    def temperature(self):\n        return self.temperature_current.get()\n\n    def temperatureRate(self):\n        return self.temperature_rate_current.get()\n\n    @property\n    def serial(self):\n        return self.arr2word(self.serial_array.get())\n\n    @property\n    def model(self):\n        return self.arr2word(self.model_array.get())\n\n    @property\n    def stage_model(self):\n        return self.arr2word(self.stage_model_array.get())\n\n    @property\n    def stage_serial(self):\n        return self.arr2word(self.stage_serial_array.get())\n\n    @property\n    def firmware_version(self):\n        return self.arr2word(self.firm_ver.get())\n\n    @property\n    def hardware_version(self):\n        return self.arr2word(self.hard_ver.get())\n\n    def status(self):\n        text = f\"\\nCurrent temperature = {self.temperature():.1f}, setpoint = {self.temperature_setpoint.get():.1f}\\n\\n\"\n        code = int(self.status_code.get())\n\n        if code & 1:  # Error\n            text += \"Error        : yes\" + \"\\n\"\n        else:\n            text += \"Error        : no\\n\"\n        if code & 2:  # at setpoint\n            text += \"At setpoint  : yes\" + \"\\n\"\n        else:\n            text += \"At setpoint  : no\\n\"\n        if code & 4:  # heater\n            text += \"Heater       : on\" + \"\\n\"\n        else:\n            text += \"Heater       : off\\n\"\n        if code & 8:  # pump\n            text += \"Pump         : on\" + \"\\n\"\n        else:\n            text += \"Pump         : off\\n\"\n        if code & 16:  # pump auto\n            text += \"Pump Auto    : yes\" + \"\\n\"\n        else:\n            text += \"Pump Auto    : no\\n\"\n\n        print(text)"
  },
  {
    "class_name": "SLIT",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/slits.py",
    "source": "class SLIT(Device):\n    h = Cpt(EpicsMotor, \"Hpos}Mtr\")\n    hg = Cpt(EpicsMotor, \"Hgap}Mtr\")\n    v = Cpt(EpicsMotor, \"Vpos}Mtr\")\n    vg = Cpt(EpicsMotor, \"Vgap}Mtr\")"
  },
  {
    "class_name": "SLTH",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/slits.py",
    "source": "class SLTH(Device):\n    h = Cpt(EpicsMotor, \"Hpos}Mtr\")\n    hg = Cpt(EpicsMotor, \"Hgap}Mtr\")"
  },
  {
    "class_name": "SLTV",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/slits.py",
    "source": "class SLTV(Device):\n    v = Cpt(EpicsMotor, \"Vpos}Mtr\")\n    vg = Cpt(EpicsMotor, \"Vgap}Mtr\")"
  },
  {
    "class_name": "APER",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/slits.py",
    "source": "class APER(Device):\n    x = Cpt(EpicsMotor, \"Xap}Mtr\")\n    y = Cpt(EpicsMotor, \"Yap}Mtr\")"
  },
  {
    "class_name": "bladecoater_smaract",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/bladecoater.py",
    "source": "class bladecoater_smaract(Device):\n    x1 = Cpt(EpicsMotor, \"X1}Mtr\", labels=[\"piezo\"])\n    x2 = Cpt(EpicsMotor, \"X2}Mtr\", labels=[\"piezo\"])"
  },
  {
    "class_name": "syringe_pump",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/bladecoater.py",
    "source": "class syringe_pump(Device):\n    vol = Cpt(EpicsSignal, \"Val:Vol-SP\",) \n    rate = Cpt(EpicsSignal, \"Val:Rate-SP\", )\n    go = Cpt(EpicsSignal, \"Cmd:Run-Cmd\",)\n    stop_flow = Cpt(EpicsSignal, \"Cmd:Stop-Cmd\",)\n    dia = Cpt(EpicsSignal, \"Val:Dia-RB\")\n    dir = Cpt(EpicsSignal, \"Val:Dir-Sel\",)"
  },
  {
    "class_name": "CRL",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/crls.py",
    "source": "class CRL(Device):\n    lens1 = Cpt(EpicsMotor, \"L1}Mtr\")\n    lens2 = Cpt(EpicsMotor, \"L2}Mtr\")\n    lens3 = Cpt(EpicsMotor, \"L3}Mtr\")\n    lens4 = Cpt(EpicsMotor, \"L4}Mtr\")\n    lens5 = Cpt(EpicsMotor, \"L5}Mtr\")\n    lens6 = Cpt(EpicsMotor, \"L6}Mtr\")\n    lens7 = Cpt(EpicsMotor, \"L7}Mtr\")\n    lens8 = Cpt(EpicsMotor, \"L8}Mtr\")\n    lens9 = Cpt(EpicsMotor, \"L9}Mtr\")\n    lens10 = Cpt(EpicsMotor, \"L10}Mtr\")\n    lens11 = Cpt(EpicsMotor, \"L11}Mtr\")\n    lens12 = Cpt(EpicsMotor, \"L12}Mtr\")\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")\n    ph = Cpt(EpicsMotor, \"Ph}Mtr\")\n    th = Cpt(EpicsMotor, \"Th}Mtr\")"
  },
  {
    "class_name": "DCMInternals",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/energy.py",
    "source": "class DCMInternals(Device):\n    \"\"\"\n    Device representing the internal motors of the Double Crystal Monochromator (DCM).\n\n    Attributes:\n        height (EpicsMotor): Motor controlling the height of the DCM.\n        pitch (EpicsMotor): Motor controlling the pitch of the DCM.\n        roll (EpicsMotor): Motor controlling the roll of the DCM.\n        theta (EpicsMotor): Motor controlling the theta angle of the DCM.\n    \"\"\"\n    height = Cpt(EpicsMotor, \"XF:12ID:m66\")\n    pitch = Cpt(EpicsMotor, \"XF:12ID:m67\")\n    roll = Cpt(EpicsMotor, \"XF:12ID:m68\")\n    theta = Cpt(EpicsMotor, \"XF:12ID:m65\")"
  },
  {
    "class_name": "HFM_voltage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/bimorph.py",
    "source": "class HFM_voltage(Device):\n    ch0 = Cpt(EpicsSignal, \"GET-VOUT0\")\n    ch0_trg = Cpt(EpicsSignal, \"SET-VTRGT0\")\n    ch1 = Cpt(EpicsSignal, \"GET-VOUT1\")\n    ch1_trg = Cpt(EpicsSignal, \"SET-VTRGT1\")\n    ch2 = Cpt(EpicsSignal, \"GET-VOUT2\")\n    ch2_trg = Cpt(EpicsSignal, \"SET-VTRGT2\")\n    ch3 = Cpt(EpicsSignal, \"GET-VOUT3\")\n    ch3_trg = Cpt(EpicsSignal, \"SET-VTRGT3\")\n    ch4 = Cpt(EpicsSignal, \"GET-VOUT4\")\n    ch4_trg = Cpt(EpicsSignal, \"SET-VTRGT4\")\n    ch5 = Cpt(EpicsSignal, \"GET-VOUT5\")\n    ch5_trg = Cpt(EpicsSignal, \"SET-VTRGT5\")\n    ch6 = Cpt(EpicsSignal, \"GET-VOUT6\")\n    ch6_trg = Cpt(EpicsSignal, \"SET-VTRGT6\")\n    ch7 = Cpt(EpicsSignal, \"GET-VOUT7\")\n    ch7_trg = Cpt(EpicsSignal, \"SET-VTRGT7\")\n    ch8 = Cpt(EpicsSignal, \"GET-VOUT8\")\n    ch8_trg = Cpt(EpicsSignal, \"SET-VTRGT8\")\n    ch9 = Cpt(EpicsSignal, \"GET-VOUT9\")\n    ch9_trg = Cpt(EpicsSignal, \"SET-VTRGT9\")\n    ch10 = Cpt(EpicsSignal, \"GET-VOUT10\")\n    ch10_trg = Cpt(EpicsSignal, \"SET-VTRGT10\")\n    ch11 = Cpt(EpicsSignal, \"GET-VOUT11\")\n    ch11_trg = Cpt(EpicsSignal, \"SET-VTRGT11\")\n    ch12 = Cpt(EpicsSignal, \"GET-VOUT12\")\n    ch12_trg = Cpt(EpicsSignal, \"SET-VTRGT12\")\n    ch13 = Cpt(EpicsSignal, \"GET-VOUT13\")\n    ch13_trg = Cpt(EpicsSignal, \"SET-VTRGT13\")\n    ch14 = Cpt(EpicsSignal, \"GET-VOUT14\")\n    ch14_trg = Cpt(EpicsSignal, \"SET-VTRGT14\")\n    ch15 = Cpt(EpicsSignal, \"GET-VOUT15\")\n    ch15_trg = Cpt(EpicsSignal, \"SET-VTRGT15\")\n    shift_rel = Cpt(EpicsSignal, \"SET-ALLSHIFT\")\n    set_tar = Cpt(EpicsSignal, \"SET-ALLTRGT\")\n\n    # This is the default hfm mirror voltage for smi swaxs hutch\n    default_hfm_v2 = np.asarray(\n        [-151, 261, 250, 293, 175, 236, 168, 231, 242, 200, 291, 222, 215, 157, 311, 36]\n    )\n\n    def set_target(self, mode=\"SWAXS\"):\n        ch_pattern = re.compile(\"ch(?P<number>\\d{1,2})\")\n        for att_an in dir(self):\n            ch_pattern_match = ch_pattern.match(att_an)\n            if ch_pattern_match and \"trg\" in att_an:\n                # -80 to move directly to teh good voltag for lowdiv configuration\n                yield from bps.mv(\n                    getattr(self, att_an),\n                    -80 + self.default_hfm_v2[int(ch_pattern_match[1])],\n                )\n                yield from bps.sleep(5)\n\n    def move_target(self):\n        yield from bps.mv(self.set_tar, 0)\n\n    def shift_relative(self, relative_value=0):\n        yield from bps.mv(self.shift_rel, relative_value)\n\n    def move_abs(self, mode=\"SWAXS\"):\n        yield from self.set_target(mode=mode)\n        yield from bps.sleep(5)\n        yield from self.move_target()"
  },
  {
    "class_name": "VFM_voltage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/bimorph.py",
    "source": "class VFM_voltage(Device):\n    ch0 = Cpt(EpicsSignal, \"GET-VOUT0\")\n    ch0_trg = Cpt(EpicsSignal, \"SET-VTRGT0\")\n    ch1 = Cpt(EpicsSignal, \"GET-VOUT1\")\n    ch1_trg = Cpt(EpicsSignal, \"SET-VTRGT1\")\n    ch2 = Cpt(EpicsSignal, \"GET-VOUT2\")\n    ch2_trg = Cpt(EpicsSignal, \"SET-VTRGT2\")\n    ch3 = Cpt(EpicsSignal, \"GET-VOUT3\")\n    ch3_trg = Cpt(EpicsSignal, \"SET-VTRGT3\")\n    ch4 = Cpt(EpicsSignal, \"GET-VOUT4\")\n    ch4_trg = Cpt(EpicsSignal, \"SET-VTRGT4\")\n    ch5 = Cpt(EpicsSignal, \"GET-VOUT5\")\n    ch5_trg = Cpt(EpicsSignal, \"SET-VTRGT5\")\n    ch6 = Cpt(EpicsSignal, \"GET-VOUT6\")\n    ch6_trg = Cpt(EpicsSignal, \"SET-VTRGT6\")\n    ch7 = Cpt(EpicsSignal, \"GET-VOUT7\")\n    ch7_trg = Cpt(EpicsSignal, \"SET-VTRGT7\")\n    ch8 = Cpt(EpicsSignal, \"GET-VOUT8\")\n    ch8_trg = Cpt(EpicsSignal, \"SET-VTRGT8\")\n    ch9 = Cpt(EpicsSignal, \"GET-VOUT9\")\n    ch9_trg = Cpt(EpicsSignal, \"SET-VTRGT9\")\n    ch10 = Cpt(EpicsSignal, \"GET-VOUT10\")\n    ch10_trg = Cpt(EpicsSignal, \"SET-VTRGT10\")\n    ch11 = Cpt(EpicsSignal, \"GET-VOUT11\")\n    ch11_trg = Cpt(EpicsSignal, \"SET-VTRGT11\")\n    ch12 = Cpt(EpicsSignal, \"GET-VOUT12\")\n    ch12_trg = Cpt(EpicsSignal, \"SET-VTRGT12\")\n    ch13 = Cpt(EpicsSignal, \"GET-VOUT13\")\n    ch13_trg = Cpt(EpicsSignal, \"SET-VTRGT13\")\n    ch14 = Cpt(EpicsSignal, \"GET-VOUT14\")\n    ch14_trg = Cpt(EpicsSignal, \"SET-VTRGT14\")\n    ch15 = Cpt(EpicsSignal, \"GET-VOUT15\")\n    ch15_trg = Cpt(EpicsSignal, \"SET-VTRGT15\")\n    shift_rel = Cpt(EpicsSignal, \"SET-ALLSHIFT\")\n    set_tar = Cpt(EpicsSignal, \"SET-ALLTRGT\")\n\n    # This is the default vfm mirror voltage for smi swaxs hutch\n    default_vfm_v2 = [\n        39,\n        -102,\n        277,\n        234,\n        325,\n        163,\n        392,\n        280,\n        365,\n        273,\n        196,\n        400,\n        219,\n        304,\n        51,\n        -327,\n    ]\n    # default_vfm_v2 = -430 + np.asarray([  39,   85, 311, 310,  -15, 485,   68, 447, 291,  130, 606,  170, 272, 437,  192, -308]) #Ca edge\n\n    # default_vfm_v2 =  [-281, -235,  -9, -10, -335, 165, -252, 127, -29, -190, 286, -150, -48, 117, -128, -628] #S edge\n\n    # This is the default vfm mirror voltage for opls hutch\n    default_vfm_opls = [\n        -206,\n        -191,\n        6,\n        71,\n        -316,\n        184,\n        -223,\n        120,\n        45,\n        -130,\n        202,\n        -111,\n        17,\n        62,\n        -75,\n        -553,\n    ]\n\n    def set_target(self, mode=\"SWAXS\"):\n        ch_pattern = re.compile(\"ch(?P<number>\\d{1,2})\")\n        for att_an in dir(self):\n            ch_pattern_match = ch_pattern.match(att_an)\n            if ch_pattern_match and \"trg\" in att_an:\n                if mode == \"SWAXS\":\n                    yield from bps.mv(\n                        getattr(self, att_an),\n                        self.default_vfm_v2[int(ch_pattern_match[1])],\n                    )\n                    yield from bps.sleep(5)\n                elif mode == \"OPLS\":\n                    yield from bps.mv(\n                        getattr(self, att_an),\n                        self.default_vfm_opls[int(ch_pattern_match[1])],\n                    )\n                    yield from bps.sleep(5)\n                else:\n                    print(\"Unknown mode, your should choose between SWAXS or OPLS\")\n\n    def move_target(self):\n        yield from bps.mv(self.set_tar, 0)\n\n    def shift_relative(self, relative_value=0):\n        yield from bps.mv(self.shift_rel, relative_value)\n\n    def move_abs(self, mode=\"SWAXS\"):\n        yield from self.set_target(mode=mode)\n        yield from bps.sleep(5)\n        yield from self.move_target()"
  },
  {
    "class_name": "Ring",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/machine.py",
    "source": "class Ring(Device):\n    current = EpicsSignalRO(\"SR:C03-BI{DCCT:1}I:Real-I\", name=\"ring_current\")\n    lifetime = EpicsSignalRO(\"SR:OPS-BI{DCCT:1}Lifetime-I\", name=\"ring_lifetime\")\n    energy = EpicsSignalRO(\"SR{}Energy_SRBend\", name=\"ring_energy\")\n    mode = EpicsSignal(\"SR-OPS{}Mode-Sts\", name=\"ring_ops\", string=True)\n    filltarget = EpicsSignalRO(\"SR-HLA{}FillPattern:DesireImA\", name=\"ring_filltarget\")"
  },
  {
    "class_name": "STG",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/manipulators.py",
    "source": "class STG(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\", labels=[\"stage\"])\n    y = Cpt(EpicsMotor, \"Y}Mtr\", labels=[\"stage\"])\n    z = Cpt(EpicsMotor, \"Z}Mtr\", labels=[\"stage\"])\n    th = Cpt(EpicsMotor, \"theta}Mtr\", labels=[\"stage\"])\n    ph = Cpt(EpicsMotor, \"phi}Mtr\", labels=[\"stage\"])\n    ch = Cpt(EpicsMotor, \"chi}Mtr\", labels=[\"stage\"])"
  },
  {
    "class_name": "SMPL",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/manipulators.py",
    "source": "class SMPL(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\", labels=[\"sample\"])\n    y = Cpt(EpicsMotor, \"Y}Mtr\", labels=[\"sample\"])\n    z = Cpt(EpicsMotor, \"Z}Mtr\", labels=[\"sample\"])\n    al = Cpt(EpicsMotor, \"alpha}Mtr\", labels=[\"sample\"])\n    az = Cpt(EpicsMotor, \"azimuth}Mtr\", labels=[\"sample\"])\n    ka = Cpt(EpicsMotor, \"kappa}Mtr\", labels=[\"sample\"])"
  },
  {
    "class_name": "HEXAPOD",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/manipulators.py",
    "source": "class HEXAPOD(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    z = Cpt(EpicsMotor, \"Z}Mtr\")\n    a = Cpt(EpicsMotor, \"A}Mtr\")\n    b = Cpt(EpicsMotor, \"B}Mtr\")\n    c = Cpt(EpicsMotor, \"C}Mtr\")"
  },
  {
    "class_name": "SMARACT",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/manipulators.py",
    "source": "class SMARACT(Device):\n    x = Cpt(EpicsMotor, \"0}Mtr\", labels=[\"piezo\"])\n    y = Cpt(EpicsMotor, \"3}Mtr\", labels=[\"piezo\"])\n    z = Cpt(EpicsMotor, \"6}Mtr\", labels=[\"piezo\"])\n    # swapping Th and ch as of Oct 2024 when old th motor seems to fail it's sensor\n    #th = Cpt(EpicsMotor, \"4}Mtr\", labels=[\"piezo\"])\n    #ch = Cpt(EpicsMotor, \"1}Mtr\", labels=[\"piezo\"])\n    ch = Cpt(EpicsMotor, \"4}Mtr\", labels=[\"piezo\"])\n    th = Cpt(EpicsMotor, \"1}Mtr\", labels=[\"piezo\"])"
  },
  {
    "class_name": "BDMStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/manipulators.py",
    "source": "class BDMStage(Device):\n    x = Cpt(EpicsSignal, \"ACT2:POSITION\", write_pv=\"ACT2:CMD:TARGET\", kind=\"hinted\")\n    y = Cpt(EpicsSignal, \"ACT1:POSITION\", write_pv=\"ACT1:CMD:TARGET\", kind=\"hinted\")\n    th = Cpt(EpicsSignal, \"ACT0:POSITION\", write_pv=\"ACT0:CMD:TARGET\", kind=\"hinted\")"
  },
  {
    "class_name": "ioLogik1241",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/ioLogik.py",
    "source": "class ioLogik1241(Device):\n    ch1_read = Cpt(EpicsSignal, \"1-RB\")\n    ch1_sp = Cpt(EpicsSignal, \"1-SP\")\n    ch2_read = Cpt(EpicsSignal, \"2-RB\")\n    ch2_sp = Cpt(EpicsSignal, \"2-SP\")\n    ch3_read = Cpt(EpicsSignal, \"3-RB\")\n    ch3_sp = Cpt(EpicsSignal, \"3-SP\")\n    ch4_read = Cpt(EpicsSignal, \"4-RB\")\n    ch4_sp = Cpt(EpicsSignal, \"4-SP\")"
  },
  {
    "class_name": "ioLogik1240",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/ioLogik.py",
    "source": "class ioLogik1240(Device):\n    ch1_read = Cpt(EpicsSignal, \"1-I\")\n    ch2_read = Cpt(EpicsSignal, \"2-I\")\n    ch3_read = Cpt(EpicsSignal, \"3-I\")\n    ch4_read = Cpt(EpicsSignal, \"4-I\")\n    ch5_read = Cpt(EpicsSignal, \"5-I\")\n    ch6_read = Cpt(EpicsSignal, \"6-I\")\n    ch7_read = Cpt(EpicsSignal, \"7-I\")\n    ch8_read = Cpt(EpicsSignal, \"8-I\")"
  },
  {
    "class_name": "Diag_Module",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/ioLogik.py",
    "source": "class Diag_Module(Device):\n    # real positions and readbacks\n    out_sts = Cpt(EpicsSignal,'DI1-Sts') # when negative - in position\n    fs_sts = Cpt(EpicsSignal,'DI3-Sts') # when negative - in position\n    pd_sts = Cpt(EpicsSignal,'DI2-Sts') # when negative - in position\n    pd_vlv = Cpt(EpicsSignal,'DO2-Cmd')\n    fs_vlv = Cpt(EpicsSignal,'DO4-Cmd')\n    out_vlv = Cpt(EpicsSignal,'DO6-Cmd')\n    # virtual positions and readbacks\n    def fs_in(self):\n        yield from bps.mv(self.out_vlv,0)\n        yield from bps.sleep(.5)\n        yield from bps.mv(self.fs_vlv,1)\n        yield from bps.mv(self.pd_vlv,1)\n        yield from bps.sleep(1)\n        yield from bps.mv(self.fs_vlv,0)\n        yield from bps.mv(self.out_vlv,0)\n        yield from bps.mv(self.pd_vlv,0)\n    def out(self):\n        yield from bps.mv(self.fs_vlv,0)\n        yield from bps.mv(self.pd_vlv,0)\n        yield from bps.sleep(.5)\n        yield from bps.mv(self.out_vlv,1)\n        yield from bps.mv(self.fs_vlv,1)\n        yield from bps.sleep(1)\n        yield from bps.mv(self.fs_vlv,0)\n        # yield from bps.mv(self.out_vlv,0)\n        # yield from bps.mv(self.pd_vlv,0)\n    def pd_in(self):\n        yield from self.out()\n        yield from bps.sleep(.5)\n        yield from bps.mv(self.out_vlv,0)\n        yield from bps.mv(self.fs_vlv,0)\n        yield from bps.mv(self.pd_vlv,0)\n        yield from bps.sleep(.5)\n        yield from bps.mv(self.pd_vlv,1)\n        yield from bps.sleep(1)\n        yield from bps.mv(self.fs_vlv,0)\n        yield from bps.mv(self.out_vlv,0)\n        yield from bps.mv(self.pd_vlv,0)"
  },
  {
    "class_name": "output_lakeshore",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/electrometers.py",
    "source": "class output_lakeshore(Device):\n\n    status = Cpt(EpicsSignal, \"Val:Range-Sel\")\n    P = Cpt(EpicsSignal, \"Gain:P-SP\")\n    I = Cpt(EpicsSignal, \"Gain:I-SP\")\n    D = Cpt(EpicsSignal, \"Gain:I-SP\")\n    temp_set_point = Cpt(EpicsSignal, \"T-SP\")\n\n    def turn_on(self):\n        yield from bps.mv(self.status, 1)\n\n    def turn_off(self):\n        yield from bps.mv(self.status, 0)\n\n    def mv_temp(self, temp):\n        yield from bps.mv(self.temp_set_point, temp)"
  },
  {
    "class_name": "new_LakeShore",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/electrometers.py",
    "source": "class new_LakeShore(Device):\n    \"\"\"\n    Lakeshore is the device reading the temperature from the heating stage for SAXS and GISAXS.\n    This class define the PVs to read and write to control lakeshore\n    :param Device: ophyd device\n    \"\"\"\n\n    input_A = Cpt(EpicsSignal, \"{Env:01-Chan:A}T-I\")\n    input_A_celsius = Cpt(EpicsSignal, \"{Env:01-Chan:A}T:C-I\")\n\n    input_B = Cpt(EpicsSignal, \"{Env:01-Chan:B}T-I\")\n    input_C = Cpt(EpicsSignal, \"{Env:01-Chan:C}T-I\")\n    input_D = Cpt(EpicsSignal, \"{Env:01-Chan:D}T-I\")\n\n    output1 = output_lakeshore(\"XF:12ID-ES{Env:01-Out:1}\", name=\"ls_outpu1\")\n    output2 = output_lakeshore(\"XF:12ID-ES{Env:01-Out:2}\", name=\"ls_outpu2\")\n    output3 = output_lakeshore(\"XF:12ID-ES{Env:01-Out:3}\", name=\"ls_outpu3\")\n    output4 = output_lakeshore(\"XF:12ID-ES{Env:01-Out:4}\", name=\"ls_outpu4\")"
  },
  {
    "class_name": "XBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/electrometers.py",
    "source": "class XBPM(Device):\n    \"\"\"\n    XBPM are diamond windows that generate current when the beam come through. It is used to know the position\n    of the beam at the bpm postion as well as the amount of incoming photons. 3 bpms are available at SMI: bpm1\n    is position upstream, bpm2 after the focusing mirrons and bpm3 downstream\n    :param Device: ophyd device\n    \"\"\"\n\n    ch1 = Cpt(EpicsSignal, \"Current1:MeanValue_RBV\")\n    ch2 = Cpt(EpicsSignal, \"Current2:MeanValue_RBV\")\n    ch3 = Cpt(EpicsSignal, \"Current3:MeanValue_RBV\")\n    ch4 = Cpt(EpicsSignal, \"Current4:MeanValue_RBV\")\n    sumX = Cpt(EpicsSignal, \"SumX:MeanValue_RBV\")\n    sumY = Cpt(EpicsSignal, \"SumY:MeanValue_RBV\")\n    posX = Cpt(EpicsSignal, \"PosX:MeanValue_RBV\")\n    posY = Cpt(EpicsSignal, \"PosY:MeanValue_RBV\")"
  },
  {
    "class_name": "Keithly2450",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/electrometers.py",
    "source": "class Keithly2450(Device):\n    run = Cpt(EpicsSignal, \"run\")\n    busy = Cpt(EpicsSignalRO, \"busy\")\n    reading = Cpt(EpicsSignalRO, \"reading\")\n\n    send_done = Cpt(EpicsSignal, \"send_done\")\n\n    send_pgm = Cpt(EpicsSignal, \"send_pgm.AOUT\")\n    send_prt = Cpt(EpicsSignal, \"send_prt.AOUT\")\n    send_stb = Cpt(EpicsSignal, \"send_stb.SCAN\", string=True)\n    # calc_done = Cpt(EpicsSignalRO, 'calc_done')\n    # fast_thold = Cpt(EpicsSignalRO, 'fast_thold')\n    # parse_cmd = Cpt(EpicsSignalRO, 'parse_cmd')\n    # fast_done = Cpt(EpicsSignalRO, 'fast_done')\n\n    _default_read_attrs = (\"reading\",)\n    _default_configuration_attrs = (\"send_pgm\", \"send_prt\", \"send_stb\")\n\n    def trigger(self):\n        st = DeviceStatus(self)\n\n        def keithy_done_monitor(old_value, value, **kwargs):\n            if old_value == 1 and value == 0:\n                st._finished()\n                self.busy.clear_sub(keithy_done_monitor)\n\n        self.busy.subscribe(keithy_done_monitor, run=False)\n        self.run.put(1)\n        return st"
  },
  {
    "class_name": "Attenuator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/attenuators.py",
    "source": "class Attenuator(Device):\n    \"\"\"\n    Class representing a single attenuator.\n\n    Attributes:\n        open_cmd (EpicsSignal): Command to open the attenuator.\n        close_cmd (EpicsSignal): Command to close the attenuator.\n        status (EpicsSignalRO): Read-only signal for the attenuator's status.\n        fail_to_close (EpicsSignalRO): Signal indicating failure to close.\n        fail_to_open (EpicsSignalRO): Signal indicating failure to open.\n    \"\"\"\n    open_cmd = Cpt(EpicsSignal, \"Cmd:Opn-Cmd\", string=True)\n    open_val = \"Open\"\n\n    close_cmd = Cpt(EpicsSignal, \"Cmd:Cls-Cmd\", string=True)\n    close_val = \"Not Open\"\n\n    status = Cpt(EpicsSignalRO, \"Pos-Sts\", string=True)\n    fail_to_close = Cpt(EpicsSignalRO, \"Sts:FailCls-Sts\", string=True)\n    fail_to_open = Cpt(EpicsSignalRO, \"Sts:FailOpn-Sts\", string=True)\n\n    # User-facing commands\n    open_str = \"Insert\"\n    close_str = \"Retract\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._set_st = None\n        self.read_attrs = [\"status\"]\n\n    def set(self, val):\n        \"\"\"\n        Set the attenuator to the desired state.\n\n        Parameters:\n            val (str or int): Desired state ('Open', 'Close', etc.).\n\n        Returns:\n            DeviceStatus: Status of the operation.\n        \"\"\"\n        st = self._set_st = DeviceStatus(self)\n\n        if val in ['Open', 'Insert', 'open', 'insert', 'in', 1]:\n            while self.status.get() != 'Open':\n                try:\n                    self.open_cmd.set(1,timeout=1).wait()\n                except: # what is the error, a timeout error?  status error?  for now any error\n                    pass\n\n        elif val in ['Close', 'Retract', 'close', 'retract', 'out', 0]:\n            while self.status.get() != 'Not Open':\n                try:\n                    self.close_cmd.set(1,timeout=1).wait()\n                except:\n                    pass\n\n        st.set_finished()\n        return st"
  },
  {
    "class_name": "XBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/xbpms.py",
    "source": "class XBPM(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")"
  },
  {
    "class_name": "MIR",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/mirrors.py",
    "source": "class MIR(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    th = Cpt(EpicsMotor, \"P}Mtr\")"
  },
  {
    "class_name": "TwoButtonShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/shutter.py",
    "source": "class TwoButtonShutter(Device):\n    # TODO this needs to be fixed in EPICS as these names make no sense\n    # the vlaue comingout of the PV do not match what is shown in CSS\n    open_cmd = Cpt(EpicsSignal, \"Cmd:Opn-Cmd\", string=True)\n    open_val = \"Open\"\n\n    close_cmd = Cpt(EpicsSignal, \"Cmd:Cls-Cmd\", string=True)\n    close_val = \"Not Open\"\n\n    status = Cpt(EpicsSignalRO, \"Pos-Sts\", string=True)\n    fail_to_close = Cpt(EpicsSignalRO, \"Sts:FailCls-Sts\", string=True)\n    fail_to_open = Cpt(EpicsSignalRO, \"Sts:FailOpn-Sts\", string=True)\n    # user facing commands\n    open_str = \"Insert\"\n    close_str = \"Retract\"\n    #!!these commands are correct with open_str = 'Insert'  close_str = 'Retract'for FOILS ONLY, to trigger gatevalevs this has to be swapped!!!\n    # to check with Bluesky guys!!!\n\n    def set(self, val):\n        if self._set_st is not None:\n            raise RuntimeError(\"trying to set while a set is in progress\")\n\n        cmd_map = {self.open_str: self.open_cmd, self.close_str: self.close_cmd}\n        target_map = {self.open_str: self.open_val, self.close_str: self.close_val}\n\n        cmd_sig = cmd_map[val]\n        target_val = target_map[val]\n\n        st = self._set_st = DeviceStatus(self)\n        enums = self.status.enum_strs\n\n        def shutter_cb(value, timestamp, **kwargs):\n            value = enums[int(value)]\n            if value == target_val:\n                self._set_st._finished()\n                self._set_st = None\n                self.status.clear_sub(shutter_cb)\n\n        cmd_enums = cmd_sig.enum_strs\n        count = 0\n\n        def cmd_retry_cb(value, timestamp, **kwargs):\n            nonlocal count\n            value = cmd_enums[int(value)]\n            # ts = datetime.datetime.fromtimestamp(timestamp).strftime(_time_fmtstr)\n            # print('sh', ts, val, st)\n            count += 1\n            if count > 5:\n                cmd_sig.clear_sub(cmd_retry_cb)\n                st._finished(success=False)\n            if value == \"None\":\n                if not st.done:\n                    yield from bps.sleep(0.5)\n                    cmd_sig.set(1)\n                    ts = datetime.datetime.fromtimestamp(timestamp).strftime(\n                        _time_fmtstr\n                    )\n                    print(\n                        \"** ({}) Had to reactuate shutter while {}ing\".format(ts, val)\n                    )\n                else:\n                    cmd_sig.clear_sub(cmd_retry_cb)\n\n        cmd_sig.subscribe(cmd_retry_cb, run=False)\n        cmd_sig.set(1)\n        self.status.subscribe(shutter_cb)\n        return st\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._set_st = None\n        self.read_attrs = [\"status\"]"
  },
  {
    "class_name": "SMIFastShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smiclasses/shutter.py",
    "source": "class SMIFastShutter(Device):\n    open_cpt = Cpt(EpicsSignal, \"XF:12IDC-ES:2{PSh:ES}pz:sh:open\")\n    close_cpt = Cpt(EpicsSignal, \"XF:12IDC-ES:2{PSh:ES}pz:sh:close\")\n    status_pv = Cpt(EpicsSignalRO, \"XF:12IDA-BI:2{EM:BPM1}DAC3\")\n    status = Cpt(Signal, value=\"\")\n\n    def check_status(self):\n        if int(self.status_pv.get()) == 7:\n            self.status.put(\"Closed\")\n        elif int(self.status_pv.get()) == 0:\n            self.status.put(\"Open\")\n        else:\n            raise RuntimeError(f'Shutter \"{self.name}\" is in a weird state.')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.check_status()\n\n    def open(self):\n        self.open_cpt.put(1)\n        self.check_status()\n\n    def close(self):\n        self.close_cpt.put(1)\n        self.check_status()"
  },
  {
    "class_name": "SMI_WAXS_detector",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smibase/beam.py",
    "source": "class SMI_WAXS_detector(Device):\n    prefix = \"detector_waxs_\"\n    pixel_size = Component(Signal, value=0.172, name=prefix + \"pixel_size\", kind=\"hinted\")\n    x0_pix = Component(Signal, value=97, name=prefix + \"x0_pix\", kind=\"hinted\")\n    y0_pix = Component(Signal, value=1386, name=prefix + \"y0_pix\", kind=\"hinted\")\n    sdd = Component(Signal, value=274.9, name=prefix + \"sdd\", kind=\"hinted\")"
  },
  {
    "class_name": "SMI_SAXS_detector",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/smi-profile-collection/startup/smibase/beam.py",
    "source": "class SMI_SAXS_detector(Device):\n    prefix = \"detector_saxs_\"\n    pixel_size = Component(Signal, value=0.172, name=prefix + \"pixel_size\", kind=\"hinted\")\n    bs_kind = Component(Signal, value=\"rod\", name=prefix + \"bs_kind\", kind=\"hinted\")\n    xbs_mask = Component(Signal, value=0, name=prefix + \"xbs_mask\", kind=\"hinted\")\n    ybs_mask = Component(Signal, value=0, name=prefix + \"ybs_mask\", kind=\"hinted\")\n    x0_pix = Component(Signal, value=0, name=prefix + \"y0_pix\", kind=\"hinted\")\n    y0_pix = Component(Signal, value=0, name=prefix + \"y0_pix\", kind=\"hinted\")\n    sdd = Component(Signal, value=8300, name=prefix + \"sdd\", kind=\"hinted\")"
  },
  {
    "class_name": "AnalogPizzaBoxTrigger",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/34-apb_trigger.py",
    "source": "class AnalogPizzaBoxTrigger(Device):\n    freq = Cpt(EpicsSignal,'Frequency-SP')\n    duty_cycle = Cpt(EpicsSignal,'DutyCycle-SP')\n    max_counts = Cpt(EpicsSignal,'MaxCount-SP')\n\n    acquire = Cpt(EpicsSignal, 'Mode-SP')\n    acquiring = Cpt(EpicsSignal, 'Status-I')\n    filename = Cpt(EpicsSignal,'Filename-SP', string=True)\n    filebin_status = Cpt(EpicsSignalRO,'File:Status-I')\n    stream = Cpt(EpicsSignal,'Stream:Mode-SP')\n\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._acquiring = None\n\n        self._asset_docs_cache = deque()\n        self._resource_uid = None\n        self._datum_counter = None\n\n    def prepare_to_fly(self, traj_duration):\n        self.num_points = int(self.freq.get() * (traj_duration + 1))\n\n    # Step-scan interface\n    def stage(self):\n        staged_list = super().stage()\n\n        file_uid = new_uid()\n        self.fn = f'{ROOT_PATH}/{RAW_PATH}/apb/{dt.datetime.strftime(dt.datetime.now(), \"%Y/%m/%d\")}/{file_uid}.bin'\n        self.filename.set(self.fn).wait()\n        # self.poke_streaming_destination()\n        self._resource_uid = new_uid()\n        resource = {'spec': 'APB_TRIGGER', #self.name.upper(),\n                    'root': ROOT_PATH,  # from 00-startup.py (added by mrakitin for future generations :D)\n                    'resource_path': self.fn,\n                    'resource_kwargs': {},\n                    'path_semantics': os.name,\n                    'uid': self._resource_uid}\n        self._asset_docs_cache.append(('resource', resource))\n        self._datum_counter = itertools.count()\n        self.max_counts.set(self.num_points).wait()\n        # self.stream.set(1).wait()\n        return staged_list\n\n    def unstage(self):\n        self._datum_counter = None\n        # self.stream.set(0).wait()\n        return super().unstage()\n\n    def kickoff(self):\n        # return self.acquire.set(2)\n        return self.stream.set(1)\n\n    def complete(self):\n        # self.acquire.set(0).wait()\n        self.stream.set(0).wait()\n        ttime.sleep(0.5)\n        self.acquire.set(0).wait()\n        ttime.sleep(0.5)\n        self._datum_ids = []\n        datum_id = '{}/{}'.format(self._resource_uid, next(self._datum_counter))\n        datum = {'resource': self._resource_uid,\n                 'datum_kwargs': {},\n                 'datum_id': datum_id}\n        self._asset_docs_cache.append(('datum', datum))\n        self._datum_ids.append(datum_id)\n        return NullStatus()\n\n\n    def collect(self):\n        print_to_gui(f'{ttime.ctime()} >>> {self.name} collect starting')\n        now = ttime.time()\n        for datum_id in self._datum_ids:\n            data = {self.name: datum_id}\n            yield {'data': data,\n                   'timestamps': {key: now for key in data}, 'time': now,\n                   'filled': {key: False for key in data}}\n            # print(f'yield data {ttime.ctime(ttime.time())}')\n        print_to_gui(f'{ttime.ctime()} >>> {self.name} collect complete')\n\n        # self.unstage()\n\n\n    def describe_collect(self):\n        return_dict = {self.name:\n                           {f'{self.name}': {'source': self.name.upper(),\n                                             'dtype': 'array',\n                                             'shape': [-1, -1],\n                                             'filename': f'{self.fn}',\n                                             'external': 'FILESTORE:'}}}\n        return return_dict\n\n\n    def collect_asset_docs(self):\n        items = list(self._asset_docs_cache)\n        self._asset_docs_cache.clear()\n        for item in items:\n            yield item"
  },
  {
    "class_name": "HHMTrajDesc",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/12-hhm.py",
    "source": "class HHMTrajDesc(Device):\n    filename = Cpt(EpicsSignal, '-Name')\n    elem = Cpt(EpicsSignal, '-Elem')\n    edge = Cpt(EpicsSignal, '-Edge')\n    e0 = Cpt(EpicsSignal, '-E0')"
  },
  {
    "class_name": "HHM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/12-hhm.py",
    "source": "class HHM(Device):\n    _default_configuration_attrs = ('pitch', 'roll', 'theta', 'y', 'energy')\n    _default_read_attrs = ('pitch', 'roll', 'theta', 'y', 'energy')\n    \"High Heat Load Monochromator\"\n    ip = '10.66.58.106'\n\n    pitch = Cpt(EpicsMotor, 'Mono:HHM-Ax:P}Mtr', kind='hinted')\n    roll = Cpt(EpicsMotor, 'Mono:HHM-Ax:R}Mtr', kind='hinted')\n    y = Cpt(StuckingEpicsMotor, 'Mono:HHM-Ax:Y}Mtr', kind='hinted')\n    theta = Cpt(EpicsMotor, 'Mono:HHM-Ax:Th}Mtr', kind='hinted')\n    # theta_speed = Cpt(EpicsSignal, 'Mono:HHM-Ax:Th}Mtr.VMAX', kind='hinted')\n    # theta_speed_max = Cpt(EpicsSignal, 'Mono:HHM-Ax:Th}Mtr.VELO', kind='hinted')\n    energy = Cpt(StuckingEpicsMotorThatFlies, 'Mono:HHM-Ax:E}Mtr', kind=Kind.hinted)\n\n    main_motor_res = Cpt(EpicsSignal, 'Mono:HHM-Ax:Th}Mtr.MRES')\n\n    # The following are related to trajectory motion\n    lut_number = Cpt(EpicsSignal, 'MC:06}LUT-Set')\n    lut_number_rbv = Cpt(EpicsSignal, 'MC:06}LUT-Read')\n    lut_start_transfer = Cpt(EpicsSignal, 'MC:06}TransferLUT')\n    lut_transfering = Cpt(EpicsSignal, 'MC:06}TransferLUT-Read')\n    trajectory_loading = Cpt(EpicsSignal, 'MC:06}TrajLoading')\n    traj_mode = Cpt(EpicsSignal, 'MC:06}TrajFlag1-Set')\n    traj_mode_rbv = Cpt(EpicsSignal, 'MC:06}TrajFlag1-Read')\n    enable_ty = Cpt(EpicsSignal, 'MC:06}TrajFlag2-Set')\n    enable_ty_rbv = Cpt(EpicsSignal, 'MC:06}TrajFlag2-Read')\n    cycle_limit = Cpt(EpicsSignal, 'MC:06}TrajRows-Set')\n    cycle_limit_rbv = Cpt(EpicsSignal, 'MC:06}TrajRows-Read')\n    enable_loop = Cpt(EpicsSignal, 'MC:06}TrajLoopFlag-Set')\n    enable_loop_rbv = Cpt(EpicsSignal, 'MC:06}TrajLoopFlag')\n\n    prepare_trajectory = Cpt(EpicsSignal, 'MC:06}PrepareTraj')\n    trajectory_ready = Cpt(EpicsSignal, 'MC:06}TrajInitPlc-Read')\n    start_trajectory = Cpt(EpicsSignal, 'MC:06}StartTraj')\n    stop_trajectory = Cpt(EpicsSignal, 'MC:06}StopTraj')\n    trajectory_running = Cpt(EpicsSignal,'MC:06}TrajRunning', write_pv='MC:06}TrajRunning-Set')\n    trajectory_progress = Cpt(EpicsSignal,'MC:06}TrajProgress')\n    trajectory_name = Cpt(EpicsSignal, 'MC:06}TrajFilename')\n\n    traj1 = Cpt(HHMTrajDesc, 'MC:06}Traj:1')\n    traj2 = Cpt(HHMTrajDesc, 'MC:06}Traj:2')\n    traj3 = Cpt(HHMTrajDesc, 'MC:06}Traj:3')\n    traj4 = Cpt(HHMTrajDesc, 'MC:06}Traj:4')\n    traj5 = Cpt(HHMTrajDesc, 'MC:06}Traj:5')\n    traj6 = Cpt(HHMTrajDesc, 'MC:06}Traj:6')\n    traj7 = Cpt(HHMTrajDesc, 'MC:06}Traj:7')\n    traj8 = Cpt(HHMTrajDesc, 'MC:06}Traj:8')\n    traj9 = Cpt(HHMTrajDesc, 'MC:06}Traj:9')\n\n\n\n    if shutdown:\n        # use this when softioc-piE712-02.service is down:\n        fb_status = Signal(name='fb_status')\n        fb_center = Signal(name='fb_center')\n        fb_line = Signal(name='fb_line')\n        fb_nlines = Signal(name='fb_nlines')\n        fb_nmeasures = Signal(name='fb_nmeasures')\n        fb_pcoeff = Signal(name='fb_pcoeff')\n        fb_hostname = Signal(name='fb_hostname')\n        fb_heartbeat = Signal(name='fb_heartbeat')\n        fb_status_err = Signal(name='fb_status_err')\n        fb_status_msg = Signal(name='fb_status_msg')\n    else:\n        # use this when softioc-piE712-02.service is up:\n        fb_status = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-Sts')\n        fb_center = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-Center')\n        fb_line = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-Line')\n        fb_nlines = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-NLines')\n        fb_nmeasures = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-NMeasures')\n        fb_pcoeff = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-PCoeff')\n        fb_hostname = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-Hostname')\n        fb_heartbeat = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-Heartbeat')\n        fb_status_err = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-Err')\n        fb_status_msg = Cpt(EpicsSignal, 'Mono:HHM-Ax:P}FB-StsMsg', string=True)\n\n\n\n    angle_offset = Cpt(EpicsSignal, 'Mono:HHM-Ax:E}Offset', limits=True)\n    home_y = Cpt(EpicsSignal, 'MC:06}Home-HHMY')\n    y_precise = Cpt(InfirmStuckingEpicsMotor, 'Mono:HHM-Ax:Y}Mtr', kind='hinted')\n\n    servocycle = 16000\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        try:\n            self.pulses_per_deg = 1 / self.main_motor_res.get()\n        except ZeroDivisionError:\n            self.pulses_per_deg = -1\n\n        # self.enc = enc\n        self._preparing = None\n        self._starting = None\n        self.y_precise.append_homing_pv(self.home_y)\n        # self.y_precise.set_low_lim(low_lim=8.5)\n\n        self.energy.append_flying_status_pv(self.trajectory_running)\n\n        self.flying_status = None\n\n\n    # def stage(self):\n    #     print(f'{ttime.ctime()} >>>>> HHM STAGED')\n    #     return super().stage()\n\n    def _ensure_mono_faces_down(self):\n        _, emax = trajectory_manager.read_trajectory_limits()\n        hhm.energy.move(emax + 50)\n\n    def prepare(self):\n        def callback(value, old_value, **kwargs):\n            if int(round(old_value)) == 1 and int(round(value)) == 0:\n                if self._preparing or self._preparing is None:\n                    self._preparing = False\n                    return True\n                else:\n                    self._preparing = True\n            return False\n\n        status = SubscriptionStatus(self.trajectory_ready, callback)\n\n        # print_to_gui(f'Mono trajectory prepare starting...', add_timestamp=True, ntabs=2)\n\n        self._ensure_mono_faces_down()\n        print_to_gui(f'Prepare trajectory starting...', add_timestamp=True, tag='Monochromator')\n        self.prepare_trajectory.set('1')  # Yes, the IOC requires a string.\n        print_to_gui(f'Perpare trajectory complete.', add_timestamp=True, tag='Monochromator')\n        # status.wait()\n        # print_to_gui(f'Ensuring mono faces down (starting)', add_timestamp=True, ntabs=2)\n        # self._ensure_mono_faces_down()\n        # print_to_gui(f'Mono trajectory prepare done', add_timestamp=True, ntabs=2)\n        self.flying_status = None\n        return status\n\n    def kickoff(self):\n        def callback(value, old_value, **kwargs):\n\n            if int(round(old_value)) == 1 and int(round(value)) == 0:\n                if self._starting or self._starting is None:\n                    self._starting = False\n                    return True\n                else:\n                    self._starting = True\n                return False\n\n        self.flying_status = SubscriptionStatus(self.trajectory_running, callback)\n        self.start_trajectory.set('1')\n        return self.flying_status\n\n    def complete(self):\n        self.flying_status = None\n\n    def abort_trajectory(self):\n        is_flying = (self.flying_status is not None) and (not self.flying_status.done)\n        self.stop_trajectory.put('1')\n        if is_flying:\n            print_to_gui('Stopping trajectory ... ', tag='HHM')\n            if not self.flying_status.done:\n                self.flying_status.set_finished()\n            print_to_gui('Stopped trajectory', tag='HHM')\n        return is_flying\n\n\n    def home_y_pos(self):\n        self.home_y.put('1')\n\n\n    def set_new_angle_offset(self, value, error_message_func=None):\n        try:\n            self.angle_offset.put(float(value))\n            return True\n        except Exception as exc:\n            if type(exc) == ophyd_utils.errors.LimitError:\n                msg = 'HHM limit error'\n                print_to_gui(f'[Energy calibration] {msg}.'.format(exc))\n                if error_message_func is not None:\n                    error_message_func(msg)\n            else:\n                msg = f'HHM error. Something went wrong, not the limit: {exc}'\n                print_to_gui(f'[Energy calibration] {msg}')\n                if error_message_func is not None:\n                    error_message_func(msg)\n            return False\n\n    def calibrate(self, energy_nominal, energy_actual, error_message_func=None):\n        offset_actual = xray.energy2encoder(energy_actual, hhm.pulses_per_deg) / hhm.pulses_per_deg\n        offset_nominal = xray.energy2encoder(energy_nominal, hhm.pulses_per_deg) / hhm.pulses_per_deg\n        angular_offset_shift = offset_actual - offset_nominal\n        new_angular_offset = self.angle_offset.value - angular_offset_shift\n        return self.set_new_angle_offset(new_angular_offset, error_message_func=error_message_func)\n\n    def get_angle_offset_deg_str(self):\n        return f'{np.round(hhm.angle_offset.get() * 180 / np.pi, 3)} deg'\n\n    def get_mono_encoder_resolution_str(self):\n        return f'{(np.round(hhm.main_motor_res.get() * np.pi / 180 * 1e9))} nrad'\n\n    @property\n    def current_trajectory_duration(self):\n        # calls function from trajectory manager defined in the next file :'(\n        return trajectory_manager.current_trajectory_duration"
  },
  {
    "class_name": "Accelerator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/08-accelerator.py",
    "source": "class Accelerator(Device):\n    beam_current = Cpt(EpicsSignal, ':OPS-BI{DCCT:1}I:Real-I')\n    life_time = Cpt(EpicsSignal, ':OPS-BI{DCCT:1}Lifetime-I')\n    status = Cpt(EpicsSignal,'-OPS{}Mode-Sts')\n    energy_str = '3 GeV'\n\n    def return_status_string(self):\n        value = self.status.get()\n        if value == 0:\n            string = 'Beam available'\n        elif value == 1:\n            string = 'Setup'\n        elif value == 2:\n            string = 'Accelerator studies'\n        elif value == 3:\n            string = 'Beam has dumped'\n        elif value == 4:\n            string = 'Maintenance'\n        elif value == 6:\n            string = 'Shutdown'\n        # elif value == 6:\n        #     string = 'Unscheduled ops'\n        elif value == 8:\n            string = 'Decay mode'\n        else:\n            string = 'Unknown'\n        return string\n\n    @property\n    def status_str(self):\n        return self.return_status_string()\n\n    def get_energy_str(self):\n        return self.energy_str"
  },
  {
    "class_name": "FrontEnd",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/08-accelerator.py",
    "source": "class FrontEnd(Device):\n    slit_top = Cpt(EpicsSignal, '{Slt:12-Ax:Y}xp')\n    slit_inb = Cpt(EpicsSignal,'{Slt:12-Ax:X}xp')\n    slit_bottom = Cpt(EpicsSignal, '{Slt:12-Ax:Y}xn')\n    slit_outb = Cpt(EpicsSignal, '{Slt:12-Ax:X}xn')\n\n    slit_vert_gap = Cpt(EpicsSignal, '{Slt:12-Ax:Y}size')\n    slit_vert_pos = Cpt(EpicsSignal, '{Slt:12-Ax:Y}center')\n    slit_horiz_gap = Cpt(EpicsSignal, '{Slt:12-Ax:X}size')\n    slit_horiz_pos = Cpt(EpicsSignal, '{Slt:12-Ax:X}center')\n\n    sync_horiz = Cpt(EpicsSignal,'{Slt:12-Ax:X}sync.PROC')\n    sync_vert = Cpt(EpicsSignal,'{Slt:12-Ax:Y}sync.PROC')\n\n    def sync_slits(self):\n        try:\n            self.sync_horiz.put(1)\n            self.sync_vert.put(1)\n        except:\n            # print('Could not sync slits - permissions')\n            pass"
  },
  {
    "class_name": "MFC",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/20-devices.py",
    "source": "class MFC(Device):\n    flow = Cpt(EpicsSignal, '-RB', write_pv='-SP')"
  },
  {
    "class_name": "DeviceWithNegativeReadBack",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/20-devices.py",
    "source": "class DeviceWithNegativeReadBack(Device):\n    read_pv = Cpt(EpicsSignal, 'V-Sense')\n    write_pv =  Cpt(EpicsSignal, 'V-Set')\n    switch_pv = Cpt(EpicsSignal, 'Switch')\n    def __init__(self,*args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._moving = None\n\n\n    def set(self, value, switch=False):\n\n        def callback(*args,**kwargs):\n            if self._moving and  abs(abs(self.read_pv.get())-abs(self.write_pv.get())) < 2:\n                self._moving = False\n                return True\n            else:\n                self._moving = True\n                return False\n\n        status = SubscriptionStatus(self.read_pv, callback)\n\n        if switch:\n            self.switch_pv.set(value)\n        else:\n            self.write_pv.set(value)\n\n        return status"
  },
  {
    "class_name": "WPS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/20-devices.py",
    "source": "class WPS(Device):\n    hv300 = Cpt(DeviceWithNegativeReadBack, 'HV:u300}')\n    hv301 = Cpt(DeviceWithNegativeReadBack, 'HV:u301}')\n    hv302 = Cpt(DeviceWithNegativeReadBack, 'HV:u302}')\n    hv303 = Cpt(DeviceWithNegativeReadBack, 'HV:u303}')\n    hv304 = Cpt(DeviceWithNegativeReadBack, 'HV:u304}')\n    hv305 = Cpt(DeviceWithNegativeReadBack, 'HV:u305}')\n    hv306 = Cpt(DeviceWithNegativeReadBack, 'HV:u306}')\n    hv307 = Cpt(DeviceWithNegativeReadBack, 'HV:u307}')\n\n    '''\n    lv0 = Cpt(EpicsSignal, '-LV:u0}V-Sense', write_pv='-LV:u0}V-Set')\n    lv1 = Cpt(EpicsSignal, '-LV:u1}V-Sense', write_pv='-LV:u1}V-Set')\n    lv2 = Cpt(EpicsSignal, '-LV:u2}V-Sense', write_pv='-LV:u2}V-Set')\n    lv3 = Cpt(EpicsSignal, '-LV:u3}V-Sense', write_pv='-LV:u3}V-Set')\n    lv4 = Cpt(EpicsSignal, '-LV:u4}V-Sense', write_pv='-LV:u4}V-Set')\n    lv5 = Cpt(EpicsSignal, '-LV:u5}V-Sense', write_pv='-LV:u5}V-Set')\n    lv6 = Cpt(EpicsSignal, '-LV:u6}V-Sense', write_pv='-LV:u6}V-Set')\n    lv7 = Cpt(EpicsSignal, '-LV:u7}V-Sense', write_pv='-LV:u7}V-Set')\n    '''"
  },
  {
    "class_name": "ShutterMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/20-devices.py",
    "source": "class ShutterMotor(Device):\n    exposure_time = Cpt(Signal)\n    def __init__(self, shutter_type, motor, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # self.name = name\n        self.shutter_type = shutter_type\n        self.motor = motor\n        self.function_call = None\n        self._start_time = None\n\n\n        if motor.connected:\n            self.output = motor.pos\n            self.open_pos = 0.00\n            self.open_range = 1\n            self.closed_pos = 1.1\n            # self.update_state(self.current_pos)\n            self.output.subscribe(self.update_state) # , event_type='done_moving'\n        else:\n            self.state = 'unknown'\n\n    @property\n    def current_pos(self):\n        return self.output.position\n\n    def update_state(self, pvname=None, value=None, char_value=None, **kwargs):\n        if self.current_pos-self.open_pos > self.open_range:\n            self.state = 'closed'\n        else:\n            self.state = 'open'\n\n        if self.function_call is not None:\n            self.function_call(pvname=pvname, value=value, char_value=char_value, **kwargs)\n\n    def subscribe(self, function):\n        self.function_call = function\n\n    def unsubscribe(self):\n        self.function_call = None\n\n    def open(self, printing=True, time_opening=False):\n        if printing: print_to_gui(f'{ttime.ctime()} >>> {self.name} opening...')\n        if time_opening: self._start_time = ttime.time()\n        self.output.move(self.open_pos, wait=True)\n\n    def close(self, printing=True):\n        if printing: print_to_gui(f'{ttime.ctime()} >>> {self.name} closing')\n        self.output.move(self.closed_pos, wait=True)\n        if self._start_time is not None:\n            self.exposure_time.put(ttime.time() - self._start_time)\n            self._start_time = None\n            print_to_gui(f'. Total exposure time: {self.exposure_time.get():0.2f} s')\n        print()\n\n\n    def open_plan(self, printing=True):\n        if printing: print_to_gui('Opening {}'.format(self.name))\n        yield from bps.mv(self.output, self.open_pos, wait=True)\n\n    def close_plan(self, printing=True):\n        if printing: print('Closing {}'.format(self.name))\n        yield from bps.mv(self.output, self.closed_pos, wait=True)"
  },
  {
    "class_name": "EPS_Shutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/20-devices.py",
    "source": "class EPS_Shutter(Device):\n    state = Cpt(EpicsSignal, 'Pos-Sts')\n    cls = Cpt(EpicsSignal, 'Cmd:Cls-Cmd')\n    opn = Cpt(EpicsSignal, 'Cmd:Opn-Cmd')\n    error = Cpt(EpicsSignal,'Err-Sts')\n    permit = Cpt(EpicsSignal, 'Permit:Enbl-Sts')\n    enabled = Cpt(EpicsSignal, 'Enbl-Sts')\n\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.color = 'red'\n\n    def open_plan(self):\n        yield from bps.mv(self.opn, 1)\n\n    def close_plan(self):\n        yield from bps.mv(self.cls, 1)\n\n    def open(self):\n        print('Opening {}'.format(self.name))\n        self.opn.put(1)\n\n    def close(self):\n        print('Closing {}'.format(self.name))\n        self.cls.put(1)"
  },
  {
    "class_name": "ICAmplifier",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/20-devices.py",
    "source": "class ICAmplifier(Device):\n    #low_noise_gain = Cpt(EpicsSignal, 'LN}I0')\n\n    def __init__(self, *args, gain_0, gain_1, gain_2, hspeed_bit, bw_10mhz_bit, bw_1mhz_bit, lnoise, hspeed, bwidth, par = None, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.gain_0 = EpicsSignal(self.prefix + gain_0, name=self.name + '_gain_0')\n        self.gain_1 = EpicsSignal(self.prefix + gain_1, name=self.name + '_gain_1')\n        self.gain_2 = EpicsSignal(self.prefix + gain_2, name=self.name + '_gain_2')\n        self.hspeed_bit = EpicsSignal(self.prefix + hspeed_bit, name=self.name + '_hspeed_bit')\n        self.bw_10mhz_bit = EpicsSignal(self.prefix + bw_10mhz_bit, name=self.name + '_bw_10mhz_bit')\n        self.bw_1mhz_bit = EpicsSignal(self.prefix + bw_1mhz_bit, name=self.name + '_bw_1mhz_bit')\n        self.low_noise_gain = EpicsSignal(self.prefix + lnoise, name=self.name + '_lnoise')\n        self.high_speed_gain = EpicsSignal(self.prefix + hspeed, name=self.name + '_hspeed')\n        self.band_width = EpicsSignal(self.prefix + bwidth, name=self.name + '_bwidth')\n        self.par = par\n\n    def set_gain(self, value: int, high_speed: bool):\n\n        val = int(value) - 2\n        if not ((high_speed and (1 <= val < 7)) or (not high_speed and (0 <= val < 6))):\n            print('{} invalid value. Ignored...'.format(self.name))\n            return 'Aborted'\n\n        if high_speed:\n            val -= 1\n            self.low_noise_gain.put(0)\n            self.high_speed_gain.put(val + 1)\n            self.hspeed_bit.put(1)\n        else:\n            self.low_noise_gain.put(val + 1)\n            self.high_speed_gain.put(0)\n            self.hspeed_bit.put(0)\n\n        self.gain_0.put((val >> 0) & 1)\n        self.gain_1.put((val >> 1) & 1)\n        self.gain_2.put((val >> 2) & 1)\n\n    def set_gain_plan(self, value: int, high_speed: bool):\n\n        val = int(value) - 2\n        if not ((high_speed and (1 <= val < 7)) or (not high_speed and (0 <= val < 6))):\n            print('{} invalid value. Ignored...'.format(self.name))\n            return 'Aborted'\n\n        if high_speed:\n            val -= 1\n            yield from bps.abs_set(self.low_noise_gain, 0)\n            yield from bps.abs_set(self.high_speed_gain, val + 1)\n            yield from bps.abs_set(self.hspeed_bit, 1)\n        else:\n            yield from bps.abs_set(self.low_noise_gain, val + 1)\n            yield from bps.abs_set(self.high_speed_gain, 0)\n            yield from bps.abs_set(self.hspeed_bit, 0)\n\n        yield from bps.abs_set(self.gain_0, (val >> 0) & 1)\n        yield from bps.abs_set(self.gain_1, (val >> 1) & 1)\n        yield from bps.abs_set(self.gain_2, (val >> 2) & 1)\n\n    def get_gain(self):\n        if self.low_noise_gain.get() == 0:\n            return [int(self.high_speed_gain.enum_strs[self.high_speed_gain.get()][-1]),1]\n        elif self.high_speed_gain.get() == 0:\n            return [int(self.low_noise_gain.enum_strs[self.low_noise_gain.get()][-1]),0]\n\n    def get_gain_value(self):\n        return self.get_gain()[0]\n\n        '''\n        if self.low_noise_gain.get() == 0:\n            return [self.high_speed_gain.enum_strs[self.high_speed_gain.get()], 1]\n        elif self.high_speed_gain.get() == 0:\n            return [self.low_noise_gain.enum_strs[self.low_noise_gain.get()], 0]\n        else:\n            return ['0', 0]\n        '''"
  },
  {
    "class_name": "ICAmplifier_Keithley",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/20-devices.py",
    "source": "class ICAmplifier_Keithley(Device):\n\n    gain = Cpt(EpicsSignal, 'Gain')\n    risetime = Cpt(EpicsSignal, 'RiseTime')\n    supr_mode = Cpt(EpicsSignal, 'SuppressionMode')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.polarity = 'pos'\n\n    def get_gain(self):\n        return [self.gain.get() + 3, 0]\n\n    def set_gain(self, gain, *args, **kwargs):\n        self.gain.set(gain - 3)\n\n    def set_gain_plan(self, gain, *args, **kwargs):\n        yield from bps.abs_set(self.gain, gain - 3)\n\n    def get_gain_value(self):\n        return self.get_gain()[0]"
  },
  {
    "class_name": "Lakeshore331Setpoint",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/20-devices.py",
    "source": "class Lakeshore331Setpoint(Device):\n    readback = Cpt(EpicsSignalRO, 'SAMPLE_A')\n    setpoint = Cpt(EpicsSignal, 'SP')"
  },
  {
    "class_name": "FlyerWithMotors",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/65-fly_scan_plans.py",
    "source": "class FlyerWithMotors(Device):\n    def __init__(self, default_dets, motors, shutter, *args, **kwargs):\n        super().__init__(parent=None, **kwargs)\n\n        # apb_stream_idx = dets.index(apb_stream)\n        # self.apb_stream = dets[apb_stream_idx]\n\n        self.default_dets = default_dets\n        self.aux_dets = []\n        self.dets = []\n        if type(motors) != list:\n            motors = [motors]\n        self.motors = motors\n        self.shutter = shutter\n        self.complete_status = None\n\n    def set_aux_dets(self, aux_dets):\n        self.aux_dets = aux_dets\n\n    def flush_dets(self):\n        self.aux_dets = []\n        self.dets = []\n\n    def stage(self):\n        _motor_prepare_status = []\n        for motor in self.motors:\n            print_to_gui(f'Preparing {motor.name} starting...', add_timestamp=True, tag='Flyer')\n            _st = motor.prepare()\n            _motor_prepare_status.append(_st)\n        combine_status_list(_motor_prepare_status).wait()\n        print_to_gui(f'Preparing motors complete', add_timestamp=True, tag='Flyer')\n        self.dets = self.default_dets + self.aux_dets\n        print_to_gui(f'Fly scan staging starting...', add_timestamp=True, tag='Flyer')\n        staged_list = super().stage()\n        trajectory_durations = [motor.current_trajectory_duration for motor in self.motors]\n        scan_duration = max(trajectory_durations)\n        for det in self.dets:\n            if hasattr(det, 'prepare_to_fly'):\n                det.prepare_to_fly(scan_duration)\n            print_to_gui(f'{det.name} staging starting', add_timestamp=True, tag='Flyer')\n            staged_list += det.stage()\n        print_to_gui(f'Fly scan staging complete', add_timestamp=True, tag='Flyer')\n        return staged_list\n\n    def unstage(self):\n        print_to_gui(f'Fly scan unstaging starting...', add_timestamp=True, tag='Flyer')\n        unstaged_list = super().unstage()\n        for det in self.dets:\n            unstaged_list += det.unstage()\n        self.flush_dets()\n        print_to_gui(f'Fly scan unstaging complete', add_timestamp=True, tag='Flyer')\n        return unstaged_list\n\n    def kickoff(self):\n        self.kickoff_status = DeviceStatus(self)\n        self.complete_status = DeviceStatus(self)\n        thread = threading.Thread(target=self.action_sequence, daemon=True)\n        thread.start()\n        return self.kickoff_status\n\n    def action_sequence(self):\n\n        print_to_gui(f'Detector kickoff starting...', add_timestamp=True, tag='Flyer')\n        self.shutter.open(time_opening=True)\n        # priority_det = self.dets[0]\n        # priority_det_kickoff_status = priority_det.kickoff()\n        # priority_det_kickoff_status.wait()\n        # ttime.sleep(1)\n        # det_kickoff_status = combine_status_list([det.kickoff() for det in self.dets[1:]])\n        det_kickoff_status = combine_status_list([det.kickoff() for det in self.dets])\n        det_kickoff_status.wait()\n\n        print_to_gui(f'Detector kickoff complete', add_timestamp=True, tag='Flyer')\n\n        self.motors_flying_status_list = []\n        for motor in self.motors:\n            print_to_gui(f'{motor.name} trajectory motion starting...', add_timestamp=True, tag='Flyer')\n            _st = motor.kickoff()\n            self.motors_flying_status_list.append(_st)\n\n        self.kickoff_status.set_finished()\n\n        combine_status_list(self.motors_flying_status_list).wait()\n\n        print_to_gui(f'Trajectory motion complete', add_timestamp=True, tag='Flyer')\n\n        print_to_gui(f'Detector complete starting...', add_timestamp=True, tag='Flyer')\n        det_complete_status = combine_status_list([det.complete() for det in self.dets])\n        det_complete_status.wait()\n        # det_complete_status = combine_status_list([det.complete() for det in self.dets[1:]])\n        # det_complete_status.wait()\n        # ttime.sleep(1)\n        # priority_det_complete_status = priority_det.complete()\n        # priority_det_complete_status.wait()\n        print(\"motors complete start\")\n        for motor in self.motors:\n            motor.complete()\n\n        print(\"motors complete done\")\n\n        self.shutter.close()\n        print_to_gui(f'Detector complete complete', add_timestamp=True, tag='Flyer')\n        self.complete_status.set_finished()\n\n    def complete(self):\n        # print(f'{ttime.ctime()} >>> COMPLETE: begin')\n        if self.complete_status is None:\n            raise RuntimeError(\"No collection in progress\")\n        return self.complete_status\n\n    def describe_collect(self):\n        return_dict = {}\n        for det in self.dets:\n            return_dict = {**return_dict, **det.describe_collect()}\n        return return_dict\n\n    def collect(self):\n        # print_to_gui(f'{ttime.ctime()} Collect starting')\n        print_to_gui(f'Collect starting...', add_timestamp=True, tag='Flyer')\n        for det in self.dets:\n            yield from det.collect()\n        # print_to_gui(f'{ttime.ctime()} Collect finished')\n        print_to_gui(f'Collect complete', add_timestamp=True, tag='Flyer')\n\n    def collect_asset_docs(self):\n        print_to_gui(f'Collect asset docs starting...', add_timestamp=True, tag='Flyer')\n        for det in self.dets:\n            yield from det.collect_asset_docs()\n        print_to_gui(f'Collect asset docs complete', add_timestamp=True, tag='Flyer')"
  },
  {
    "class_name": "Potentiostat",
    "bases": [
      "EpicsSignalRO"
    ],
    "file": "profile-collections/iss-profile-collection/startup/25-sample_environment.py",
    "source": "class Potentiostat(EpicsSignalRO):\n    def get(self):\n        value = super().get()\n        if value>10:\n            return 0\n        else:\n            return value"
  },
  {
    "class_name": "Encoder",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/30-detectors.py",
    "source": "class Encoder(Device):\n    \"\"\"This class defines components but does not implement actual reading.\n\n    See EncoderFS and EncoderParser\"\"\"\n    pos_I = Cpt(EpicsSignal, '}Cnt:Pos-I')\n    sec_array = Cpt(EpicsSignal, '}T:sec_Bin_')\n    nsec_array = Cpt(EpicsSignal, '}T:nsec_Bin_')\n    pos_array = Cpt(EpicsSignal, '}Cnt:Pos_Bin_')\n    index_array = Cpt(EpicsSignal, '}Cnt:Index_Bin_')\n    data_array = Cpt(EpicsSignal, '}Data_Bin_')\n    # The '$' in the PV allows us to write 40 chars instead of 20.\n    filepath = Cpt(EpicsSignal, '}ID:File.VAL', string=True)\n    # filepath = Cpt(EpicsSignal, '}ID:File')\n    dev_name = Cpt(EpicsSignal, '}DevName')\n\n    filter_dy = Cpt(EpicsSignal, '}Fltr:dY-SP')\n    filter_dt = Cpt(EpicsSignal, '}Fltr:dT-SP')\n    reset_counts = Cpt(EpicsSignal, '}Rst-Cmd')\n\n    ignore_sel = Cpt(EpicsSignal, suffix='}Ignore-RB', write_pv='}Ignore-Sel')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._ready_to_collect = False\n        if self.connected:\n            self.ignore_sel.put(1)"
  },
  {
    "class_name": "PizzaBoxFS",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/30-detectors.py",
    "source": "class PizzaBoxFS(Device):\n    ts_sec = Cpt(EpicsSignal, '}T:sec-I')\n    #internal_ts_sel = Cpt(EpicsSignal, '}T:Internal-Sel')\n\n    enc1 = Cpt(EncoderFS, ':1')\n    enc2 = Cpt(EncoderFS, ':2')\n    enc3 = Cpt(EncoderFS, ':3')\n    enc4 = Cpt(EncoderFS, ':4')\n    # di = Cpt(DIFS, ':DI')\n    # do0 = Cpt(DigitalOutput, '-DO:0')\n    # do1 = Cpt(DigitalOutput, '-DO:1')\n    # do2 = Cpt(DigitalOutput, '-DO:2')\n    # do3 = Cpt(DigitalOutput, '-DO:3')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)"
  },
  {
    "class_name": "Mirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class Mirror(Device):\n    pitch = Cpt(EpicsMotor, '-Ax:P}Mtr')\n    roll = Cpt(EpicsMotor, '-Ax:R}Mtr')\n    xd = Cpt(EpicsMotor, '-Ax:XD}Mtr')  # downstream\n    xu = Cpt(EpicsMotor, '-Ax:XU}Mtr')  # upstream\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    ydi = Cpt(EpicsMotor, '-Ax:YDI}Mtr')  # downstream inboard\n    ydo = Cpt(EpicsMotor, '-Ax:YDO}Mtr')  # downstream outboard\n    yu = Cpt(EpicsMotor, '-Ax:YU}Mtr')\n    yaw = Cpt(EpicsMotor, '-Ax:Yaw}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n\n    def __init__(self, *args, pos_dict=None, **kwargs):\n        super().__init__(*args, **kwargs)\n        if pos_dict is None:\n            pos_dict = {}\n        self.pos_dict = pos_dict\n\n    def get_current_stripe(self):\n        pos = self.x.position\n        for k, value in self.pos_dict.items():\n            if np.isclose(pos, value, atol=15):\n                return k\n        return 'undefined'"
  },
  {
    "class_name": "HRM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class HRM(Device):\n    \"\"\"High Resolution Monochromator\"\"\"\n    theta = Cpt(EpicsMotor, '-Ax:Th}Mtr')\n    y = Cpt(StuckingEpicsMotor, '-Ax:Y}Mtr')\n    pitch = Cpt(EpicsMotor, '-Ax:P}Mtr')"
  },
  {
    "class_name": "HHRM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class HHRM(Device):\n    \"\"\"High Harmonics Rejection Mirror\"\"\"\n    yu = Cpt(EpicsMotor, 'Mir:HRM:YU}Mtr')\n    yd1 = Cpt(EpicsMotor, 'Mir:HRM:YD1}Mtr')\n    yd2 = Cpt(EpicsMotor, 'Mir:HRM:YD2}Mtr')\n    mir_pitch = Cpt(EpicsMotor, 'Mir:HRM:P}Mtr')\n    hor_translation = Cpt(EpicsMotor, 'Mir:HRM:H}Mtr')\n\n    table_pitch = Cpt(EpicsMotor, 'Mir:HRM:TP}Mtr')\n    y = Cpt(StuckingEpicsMotor, 'Mir:HRM:TY}Mtr')\n\n\n    #     # print_to_gui('WARNING HHRM STRIPE IS NOT DEFINED')\n    #     # return 'undefined'\n    #\n    # def get_current_stripe(self):\n    #     pos = self.hor_translation.user_readback.get()\n    #     if np.isclose(pos, 0, atol=15):\n    #         stripe = 'Si'\n    #     elif np.isclose(pos, -80, atol=15):\n    #         stripe = 'Pt'\n    #     elif np.isclose(pos, 80, atol=15):\n    #         stripe = 'Rh'\n    #     else:\n    #         stripe = 'undefined'\n    #     return stripe\n\n    def __init__(self, *args, pos_dict=None, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.x = self.hor_translation\n        if pos_dict is None:\n            pos_dict = {}\n        self.pos_dict = pos_dict\n\n    def get_current_stripe(self):\n        pos = self.x.position\n        for k, value in self.pos_dict.items():\n            if np.isclose(pos, value, atol=15):\n                return k\n        return 'undefined'\n\n    @property\n    def current_stripe(self):\n        return self.get_current_stripe()"
  },
  {
    "class_name": "SampleXY",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class SampleXY(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')"
  },
  {
    "class_name": "DetStageXYZ",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class DetStageXYZ(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    z = Cpt(EpicsMotor, '-Ax:Z}Mtr')"
  },
  {
    "class_name": "Usermotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class Usermotor(Device):\n    pos = Cpt(EpicsMotor, '}Mtr')"
  },
  {
    "class_name": "IonChamberMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class IonChamberMotor(Device):\n    pos = Cpt(EpicsMotor, '}Mtr')"
  },
  {
    "class_name": "Bender",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class Bender(Device):\n    pos = Cpt(EpicsMotor, '}Mtr')\n    load_cell = EpicsSignalRO('XF:08IDA-OP{Mir:CM-Ax:Bender}W-I', name='bender_loading')"
  },
  {
    "class_name": "BenderFM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class BenderFM(Device):\n    pos = Cpt(EpicsMotor, '}Mtr')\n    load_cell = EpicsSignalRO('XF:08IDA-OP{Mir:FM-Ax:Bender}W-I', name='bender_fm_loading')"
  },
  {
    "class_name": "FilterBox",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class FilterBox(Device):\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    pos1 = Cpt(EpicsSignal, '}Fltr1:In-Sts')\n    pos2 = Cpt(EpicsSignal, '}Fltr2:In-Sts')\n    pos3 = Cpt(EpicsSignal, '}Fltr3:In-Sts')\n    pos4 = Cpt(EpicsSignal, '}Fltr4:In-Sts')\n    pos5 = Cpt(EpicsSignal, '}Fltr5:In-Sts')\n\n    pos_limit = Cpt(EpicsSignal, '-Ax:Y}OvrP-Sts')\n    neg_limit = Cpt(EpicsSignal, '-Ax:Y}OvrN-Sts')"
  },
  {
    "class_name": "Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class Slits(Device):\n    v_gap = Cpt(EpicsMotor, '-Ax:V-GAP}Mtr')\n    v_pos = Cpt(EpicsMotor, '-Ax:V-POS}Mtr')\n    hor_in = Cpt(EpicsMotor, '-Ax:XI}Mtr')\n    hor_out = Cpt(EpicsMotor, '-Ax:XO}Mtr')"
  },
  {
    "class_name": "Hutch_Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class Hutch_Slits(Device):\n    top = Cpt(EpicsMotor, '1}Mtr')\n    bottom = Cpt(EpicsMotor, '2}Mtr')\n    inboard = Cpt(EpicsMotor, '3}Mtr')\n    outboard = Cpt(EpicsMotor, '4}Mtr')"
  },
  {
    "class_name": "HuberStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class HuberStage(Device):\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    pitch = Cpt(EpicsMotor, '-Ax:P}Mtr')\n    z = Cpt(EpicsMotor, '-Ax:Z}Mtr')"
  },
  {
    "class_name": "XBIC",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class XBIC(Device):\n    dac1 = Cpt(EpicsSignal, 'MC:XBIC}DAC1-I', write_pv='MC:XBIC}DAC1R-SP')\n    dac2 = Cpt(EpicsSignal, 'MC:XBIC}DAC2-I', write_pv='MC:XBIC}DAC2R-SP')"
  },
  {
    "class_name": "SixAxesStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class SixAxesStage(Device):\n    x = Cpt(EpicsMotor, '-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '-Ax:Y}Mtr')\n    z = Cpt(EpicsMotor, '-Ax:Z}Mtr')\n    pitch = Cpt(EpicsMotor, '-Ax:P}Mtr')\n    yaw = Cpt(EpicsMotor, '-Ax:Yaw}Mtr')\n    roll = Cpt(EpicsMotor, '-Ax:R}Mtr')"
  },
  {
    "class_name": "FoilWheel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class FoilWheel(Device):\n    wheel1 = Cpt(EpicsMotor, '1:Rot}Mtr')\n    wheel2 = Cpt(EpicsMotor, '2:Rot}Mtr')"
  },
  {
    "class_name": "GonioMeter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class GonioMeter(Device):\n    th1 = Cpt(EpicsMotor, ':1}Mtr')\n    th2 = Cpt(EpicsMotor, ':2}Mtr')"
  },
  {
    "class_name": "SampleStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class SampleStage(Device):\n    x = Cpt(EpicsMotor, 'XF:08IDB-OP{Stage:Sample-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, 'XF:08IDB-OP{Stage:Sample-Ax:Y}Mtr')\n    z = Cpt(EpicsMotor, 'XF:08IDB-OP{Misc-Ax:2}Mtr')\n    # z = Cpt(EpicsMotorThatCannotReachTheTargetProperly, 'XF:08IDB-OP{Misc-Ax:2}Mtr')\n    th = Cpt(EpicsMotor, 'XF:08IDB-OP{Gon:Th:1}Mtr')\n    def mv(self, pos_dict, wait=True):\n        '''\n        pos_dict = {'x' : -300,\n                      'y' : -60}\n        or\n        pos_dict = {'th' : -800}\n        '''\n        st_list = []\n        for axis, pos in pos_dict.items():\n            motor = getattr(self, axis)\n            # print(f'{motor.user_setpoint.value=}')\n            if (not wait) or (not motor.moving):\n\n                st = motor.move(pos, wait=False)\n                st_list.append(st)\n        if len(st_list) > 0:\n            return combine_status_list(st_list)\n        else:\n            return NullStatus()\n\n    def mvr(self, delta_dict, wait=True):\n        pos_dict = {}\n        for axis, delta in delta_dict.items():\n            motor = getattr(self, axis)\n            # if not motor.moving:\n                # pos_dict[axis] = motor.position + delta\n            pos_dict[axis] = motor.user_setpoint.value + delta\n        return self.mv(pos_dict, wait=wait)\n\n    def positions(self, *axes, prefix=''):\n        if len(axes) == 0:\n            axes = ['x', 'y', 'z', 'th']\n        pos_dict = {}\n        for axis in axes:\n            motor = getattr(self, axis)\n            if len(prefix) > 0:\n                key = f'{prefix}_{axis}'\n            else:\n                key = axis\n            pos_dict[key] = motor.position\n        return pos_dict"
  },
  {
    "class_name": "FIPSpectrometerMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class FIPSpectrometerMotor(Device):\n    x = Cpt(EpicsMotor, ':X}Mtr')\n    y = Cpt(EpicsMotor, ':Y}Mtr')"
  },
  {
    "class_name": "VonHamosSpectrometerMotors",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/10-motors.py",
    "source": "class VonHamosSpectrometerMotors(Device):\n    assm_y = Cpt(EpicsMotor, ':1}Mtr')\n    assm_x = Cpt(EpicsMotor, ':2}Mtr')\n    arc = Cpt(EpicsMotor, ':3}Mtr')\n\n    crystal_x = Cpt(EpicsMotor, ':6}Mtr')\n    crystal_yaw = Cpt(EpicsMotor, ':7}Mtr')\n    crystal_pitch = Cpt(EpicsMotor, ':8}Mtr')"
  },
  {
    "class_name": "Electrometer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/35-electrometer.py",
    "source": "class Electrometer(Device):\n\n    polarity = 'neg'\n\n    ch1 = Cpt(EpicsSignal, 'SA:A:uA-I')\n    ch2 = Cpt(EpicsSignal, 'SA:B:uA-I')\n    ch3 = Cpt(EpicsSignal, 'SA:C:uA-I')\n    ch4 = Cpt(EpicsSignal, 'SA:D:uA-I')\n    ch5 = Cpt(EpicsSignal, 'SA:E:mV-I')\n    ch6 = Cpt(EpicsSignal, 'SA:F:mV-I')\n    ch7 = Cpt(EpicsSignal, 'SA:G:mV-I')\n    ch8 = Cpt(EpicsSignal, 'SA:H:mV-I')\n\n    ch1_range = Cpt(EpicsSignal, 'ADC:Range:A-SP')\n    ch2_range = Cpt(EpicsSignal, 'ADC:Range:D-SP')\n    ch3_range = Cpt(EpicsSignal, 'ADC:Range:C-SP')\n    ch4_range = Cpt(EpicsSignal, 'ADC:Range:D-SP')\n    ch5_range = Cpt(EpicsSignal, 'ADC:Range:E-SP')\n    ch6_range = Cpt(EpicsSignal, 'ADC:Range:F-SP')\n    ch7_range = Cpt(EpicsSignal, 'ADC:Range:G-SP')\n    ch8_range = Cpt(EpicsSignal, 'ADC:Range:H-SP')\n\n\n    # ch1_offset = Cpt(EpicsSignal, 'Ch1:User:Offset-SP', kind=Kind.config)\n    # ch2_offset = Cpt(EpicsSignal, 'Ch2:User:Offset-SP', kind=Kind.config)\n    # ch3_offset = Cpt(EpicsSignal, 'Ch3:User:Offset-SP', kind=Kind.config)\n    # ch4_offset = Cpt(EpicsSignal, 'Ch4:User:Offset-SP', kind=Kind.config)\n    # ch5_offset = Cpt(EpicsSignal, 'Ch5:User:Offset-SP', kind=Kind.config)\n    # ch6_offset = Cpt(EpicsSignal, 'Ch6:User:Offset-SP', kind=Kind.config)\n    # ch7_offset = Cpt(EpicsSignal, 'Ch7:User:Offset-SP', kind=Kind.config)\n    # ch8_offset = Cpt(EpicsSignal, 'Ch8:User:Offset-SP', kind=Kind.config)\n\n    acquire = Cpt(EpicsSignal, 'FA:SoftTrig-SP', kind=Kind.omitted)\n    acquiring = Cpt(EpicsSignal, 'FA:Busy-I', kind=Kind.omitted)\n\n\n    divide = Cpt(EpicsSignal, 'FA:Divide-SP')\n    sample_len = Cpt(EpicsSignal, 'FA:Samples-SP')\n    wf_len = Cpt(EpicsSignal, 'FA:Wfm:Length-SP')\n\n    stream = Cpt(EpicsSignal, 'FA:Stream-SP', kind=Kind.omitted)\n    streaming = Cpt(EpicsSignal, 'FA:Streaming-I', kind=Kind.omitted)\n\n    acq_rate= Cpt(EpicsSignal,'FA:Rate-I', kind=Kind.omitted)\n    stream_samples = Cpt(EpicsSignal, 'FA:Stream:Samples-SP')\n\n    filename_bin = Cpt(EpicsSignal, 'FA:Stream:Bin:File-SP')\n    filebin_status = Cpt(EpicsSignal, 'FA:Stream:Bin:File:Status-I')\n\n    trig_source = Cpt(EpicsSignal, 'Machine:Clk-SP')"
  },
  {
    "class_name": "JohannCrystalHoming",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/80-johann_spectrometer.py",
    "source": "class JohannCrystalHoming(Device):\n    cr_main_roll_home = Cpt(EpicsSignal, '1:Roll}Mtr.HOMF')\n    cr_main_yaw_home = Cpt(EpicsSignal, '1:Yaw}Mtr.HOMF')\n\n    cr_aux2_roll_home = Cpt(EpicsSignal, '2:Roll}Mtr.HOMF')\n    cr_aux2_yaw_home = Cpt(EpicsSignal, '2:Yaw}Mtr.HOMF')\n    cr_aux2_x_home = Cpt(EpicsSignal, '2:X}Mtr.HOMF')\n    cr_aux2_y_home = Cpt(EpicsSignal, '2:Y}Mtr.HOMF')\n\n    cr_aux3_roll_home = Cpt(EpicsSignal, '3:Roll}Mtr.HOMF')\n    cr_aux3_yaw_home = Cpt(EpicsSignal, '3:Yaw}Mtr.HOMF')\n    cr_aux3_x_home = Cpt(EpicsSignal, '3:X}Mtr.HOMF')\n    cr_aux3_y_home = Cpt(EpicsSignal, '3:Y}Mtr.HOMF')\n\n    cr_aux4_roll_home = Cpt(EpicsSignal, '4:Roll}Mtr.HOMF')\n    cr_aux4_yaw_home = Cpt(EpicsSignal, '4:Yaw}Mtr.HOMF')\n    cr_aux4_x_home = Cpt(EpicsSignal, '4:X}Mtr.HOMF')\n    cr_aux4_y_home = Cpt(EpicsSignal, '4:Y}Mtr.HOMF')\n\n    cr_aux5_roll_home = Cpt(EpicsSignal, '5:Roll}Mtr.HOMF')\n    cr_aux5_yaw_home = Cpt(EpicsSignal, '5:Yaw}Mtr.HOMF')\n    cr_aux5_x_home = Cpt(EpicsSignal, '5:X}Mtr.HOMF')\n    cr_aux5_y_home = Cpt(EpicsSignal, '5:Y}Mtr.HOMF')\n\n    def home_all_axes(self):\n        for component in self.component_names:\n            cpt = getattr(self, component)\n            cpt.put(1)"
  },
  {
    "class_name": "EpicsSignalAsEncoderForMotor",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/iss-profile-collection/startup/80-johann_spectrometer.py",
    "source": "class EpicsSignalAsEncoderForMotor(EpicsSignal):\n    \"\"\"\n    A hook class to connect an inclinometer to a goniometer motor and correct its position.\n    Requires a table (pandas df saved as json) for conversion between the inclinometer readback values and the motor\n    positions. Loosly, this allows to use the EpicsSignal sensor as an absolute encoder for the motor.\n    \"\"\"\n\n    def __init__(self, *args, conversion_json_path: str = '', motor: EpicsMotor = None, polynom_order: int = 1,\n                 atol: float = 0.1, **kwargs):\n        \"\"\"\n        args, kwargs as those for EpicsSignal;\n        conversion_json_path - conversion table saved as pandas DataFrame json. Format: 1st column - motor position, 2nd\n        column - sensor values;\n        motor - EpicsMotor instance to connect with sensor;\n        polynom_order - order for polynomial fitting of the conversion table;\n        atol - absolute tolerance to the differences between the nominal motor position and sensor-inferred motor position\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self._conversion_df = pd.read_json(conversion_json_path)\n        self._get_converter_parameters(polynom_order)\n        self._atol = atol\n        self.motor = motor\n        self._callback_cid = None\n        self._subscribe_to_moving_status()\n\n    def _subscribe_to_moving_status(self):\n        def callback(value, old_value, timestamp, **kwargs):\n            if (int(value) == 0) and (int(old_value) == 1):\n\n                # check if the inclinometer value read was done ~0.3 seconds (empirically derived) AFTER the motion has stopped\n                for i in range(10):\n                    sensor_timestamp = self.read()[self.name]['timestamp']\n                    if sensor_timestamp - timestamp >= 0.3:\n                        break\n                    ttime.sleep(0.2)\n\n                # if a new motion has started, then skip the checking\n                if not self.motor.moving:\n                    self.check_with_sensor()\n\n        self._callback_cid = self.motor.motor_is_moving.subscribe(callback, run=False)\n\n    def _unsubscribe_from_moving_status(self):\n        if self._callback_cid is not None:\n            self.motor.motor_is_moving.unsubscribe(self._callback_cid)\n\n    def _get_converter_parameters(self, polynom_order):\n        d = self._conversion_df.values\n        self._p_sen2pos = np.polyfit(d[:, 1], d[:, 0], polynom_order)\n\n    def _sen2pos(self, sensor_value):\n        return np.polyval(self._p_sen2pos, sensor_value)\n\n    @property\n    def position_from_sensor(self):\n        value = self.get()\n        return self._sen2pos(value)\n\n    def update_motor_position(self, new_position):\n        limits = self.motor.limits\n        old_offset = self.motor.user_offset.get()\n        new_offset = old_offset + new_position - self.motor.position\n        self.motor.user_offset.set(new_offset)\n        self.motor.set_lim(*limits)\n\n    def check_with_sensor(self):\n        if (abs(self.motor.position - self.position_from_sensor) > self._atol):\n            print_to_gui(\n                f'Detector Goniometer 1 position disagrees with inclinometer by >{self._atol} degrees. Correcting.',\n                tag='Spectrometer', add_timestamp=True)\n            self.update_motor_position(self.position_from_sensor)"
  },
  {
    "class_name": "Xspress3FileStoreFlyable",
    "bases": [
      "Xspress3FileStore"
    ],
    "file": "profile-collections/iss-profile-collection/startup/38-xspress3.py",
    "source": "class Xspress3FileStoreFlyable(Xspress3FileStore):\n    def warmup(self):\n        \"\"\"\n        A convenience method for 'priming' the plugin.\n        The plugin has to 'see' one acquisition before it is ready to capture.\n        This sets the array size, etc.\n        NOTE : this comes from:\n            https://github.com/NSLS-II/ophyd/blob/master/ophyd/areadetector/plugins.py\n        We had to replace \"cam\" with \"settings\" here.\n        Also modified the stage sigs.\n        \"\"\"\n        print_to_gui(\"warming up the hdf5 plugin...\")\n        self.enable.set(1).wait()\n        sigs = OrderedDict([(self.parent.settings.array_callbacks, 1),\n                            (self.parent.settings.trigger_mode, 'Internal'),\n                            # just in case the acquisition time is set very long...\n                            (self.parent.settings.acquire_time, 1),\n                            # (self.capture, 1),\n                            (self.parent.settings.acquire, 1)])\n\n        original_vals = {sig: sig.get() for sig in sigs}\n\n        # Remove the hdf5.capture item here to avoid an error as it should reset back to 0 itself\n        # del original_vals[self.capture]\n\n        for sig, val in sigs.items():\n            ttime.sleep(0.1)  # abundance of caution\n            sig.set(val).wait()\n\n        ttime.sleep(2)  # wait for acquisition\n\n        for sig, val in reversed(list(original_vals.items())):\n            ttime.sleep(0.1)\n            sig.set(val).wait()\n        print_to_gui(\"done\")"
  },
  {
    "class_name": "ISSXspress3Detector",
    "bases": [
      "XspressTrigger",
      "Xspress3Detector"
    ],
    "file": "profile-collections/iss-profile-collection/startup/38-xspress3.py",
    "source": "class ISSXspress3Detector(XspressTrigger, Xspress3Detector):\n    roi_data = Cpt(PluginBase, 'ROIDATA:')\n    channel1 = Cpt(Xspress3Channel, 'C1_', channel_num=1, read_attrs=['rois'])\n    channel2 = Cpt(Xspress3Channel, 'C2_', channel_num=2, read_attrs=['rois'])\n    channel3 = Cpt(Xspress3Channel, 'C3_', channel_num=3, read_attrs=['rois'])\n    channel4 = Cpt(Xspress3Channel, 'C4_', channel_num=4, read_attrs=['rois'])\n    # create_dir = Cpt(EpicsSignal, 'HDF5:FileCreateDir')\n\n    mca1_sum = Cpt(EpicsSignal, 'ARRSUM1:ArrayData')\n    mca2_sum = Cpt(EpicsSignal, 'ARRSUM2:ArrayData')\n    mca3_sum = Cpt(EpicsSignal, 'ARRSUM3:ArrayData')\n    mca4_sum = Cpt(EpicsSignal, 'ARRSUM4:ArrayData')\n\n    mca1 = Cpt(EpicsSignal, 'ARR1:ArrayData')\n    mca2 = Cpt(EpicsSignal, 'ARR2:ArrayData')\n    mca3 = Cpt(EpicsSignal, 'ARR3:ArrayData')\n    mca4 = Cpt(EpicsSignal, 'ARR4:ArrayData')\n\n    hdf5 = Cpt(Xspress3FileStoreFlyable, 'HDF5:',\n               read_path_template=f'{ROOT_PATH}/{RAW_PATH}/xspress3/%Y/%m/%d/',\n               root=f'{ROOT_PATH}/{RAW_PATH}/',\n               write_path_template=f'{ROOT_PATH}/{RAW_PATH}/xspress3/%Y/%m/%d/',\n               )\n\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None, **kwargs):\n        if configuration_attrs is None:\n            configuration_attrs = ['external_trig', 'total_points',\n                                   'spectra_per_point', 'settings',\n                                   'rewindable']\n        if read_attrs is None:\n            read_attrs = ['channel1', 'channel2', 'channel3', 'channel4', 'hdf5', 'settings.acquire_time']\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n        self.set_channels_for_hdf5()\n        # self.create_dir.put(-3)\n        self.spectra_per_point.put(1)\n        self.channel1.rois.roi01.configuration_attrs.append('bin_low')\n\n        self._asset_docs_cache = deque()\n        # self._datum_counter = None\n        self.warmup()\n\n    # Step-scan interface methods.\n    # def stage(self):\n    #     staged_list = super().stage()\n    #\n    #     return staged_list\n\n    # def unstage(self):\n    #\n    #     return super().unstage()\n\n    def trigger(self):\n\n        self._status = DeviceStatus(self)\n        self.settings.erase.put(1)\n        # self.settings.erase.put(1)    # this was\n        self._acquisition_signal.put(1, wait=False)\n        trigger_time = ttime.time()\n\n        for sn in self.read_attrs:\n            if sn.startswith('channel') and '.' not in sn:\n                ch = getattr(self, sn)\n                self.dispatch(ch.name, trigger_time)\n\n        self._abs_trigger_count += 1\n        return self._status\n\n    def set_exposure_time(self, new_exp_time):\n        self.settings.acquire_time.set(new_exp_time).wait()\n\n    def read_exposure_time(self):\n        return self.settings.acquire_time.get()\n\n    def test_exposure(self, acq_time=1, num_images=1):\n        _old_acquire_time = self.settings.acquire_time.value\n        _old_num_images = self.settings.num_images.value\n        # self.settings.acquire_time.set(acq_time).wait()\n        self.set_exposure_time(acq_time)\n        self.settings.num_images.set(num_images).wait()\n        self.settings.erase.put(1)\n        self._acquisition_signal.put(1, wait=True)\n        # self.settings.acquire_time.set(_old_acquire_time).wait()\n        self.set_exposure_time(_old_acquire_time)\n        self.settings.num_images.set(_old_num_images).wait()\n\n    def set_channels_for_hdf5(self, channels=(1, 2, 3, 4)):\n        \"\"\"\n        Configure which channels' data should be saved in the resulted hdf5 file.\n        Parameters\n        ----------\n        channels: tuple, optional\n            the channels to save the data for\n        \"\"\"\n        # The number of channel\n        for n in channels:\n            getattr(self, f'channel{n}').rois.read_attrs = ['roi{:02}'.format(j) for j in [1, 2, 3, 4]]\n        self.hdf5.num_extra_dims.put(0)\n        self.settings.num_channels.put(len(channels))\n\n    def warmup(self, hdf5_warmup=False):\n        self.channel1.vis_enabled.put(1)\n        self.channel2.vis_enabled.put(1)\n        self.channel3.vis_enabled.put(1)\n        self.channel4.vis_enabled.put(1)\n        self.total_points.put(1)\n        if hdf5_warmup:\n            self.hdf5.warmup()\n\n        # Hints:\n        for n in range(1, 5):\n            getattr(self, f'channel{n}').rois.roi01.value.kind = 'hinted'\n\n        self.settings.configuration_attrs = ['acquire_period',\n                                           'acquire_time',\n                                           'gain',\n                                           'image_mode',\n                                           'manufacturer',\n                                           'model',\n                                           'num_exposures',\n                                           'num_images',\n                                           'temperature',\n                                           'temperature_actual',\n                                           'trigger_mode',\n                                           'config_path',\n                                           'config_save_path',\n                                           'invert_f0',\n                                           'invert_veto',\n                                           'xsp_name',\n                                           'num_channels',\n                                           'num_frames_config',\n                                           'run_flags',\n                                           'trigger_signal']\n\n        for key, channel in self.channels.items():\n            roi_names = ['roi{:02}'.format(j) for j in [1, 2, 3, 4]]\n            channel.rois.read_attrs = roi_names\n            channel.rois.configuration_attrs = roi_names\n            for roi_n in roi_names:\n                getattr(channel.rois, roi_n).value_sum.kind = 'omitted'\n\n    def set_limits_for_roi(self, energy_nom, roi, window='auto'):\n\n        for ch_index, channel in self.channels.items():\n            if window == 'auto':\n                w = _compute_window_for_xs_roi_energy(energy_nom)\n            else:\n                w = int(window)\n            energy = _convert_xs_energy_nom2act(energy_nom, ch_index)\n            ev_low_new = int(energy - w / 2)\n            ev_high_new = int(energy + w / 2)\n\n            roi_obj = getattr(channel.rois, roi)\n            if ev_high_new < roi_obj.ev_low.get():\n                roi_obj.ev_low.put(ev_low_new)\n                roi_obj.ev_high.put(ev_high_new)\n            else:\n                roi_obj.ev_high.put(ev_high_new)\n                roi_obj.ev_low.put(ev_low_new)\n\n    def ensure_roi4_covering_total_mca(self, emin=600, emax=40960):\n        for ch_index, channel in self.channels.items():\n            channel.rois.roi04.ev_high.put(emax)\n            channel.rois.roi04.ev_low.put(emin)\n\n    @property\n    def roi_metadata(self):\n        md = {}\n        for ch_index, channel in self.channels.items():\n            v = {}\n            for roi_idx in range(1, 5):\n                roi_str = f'roi{roi_idx:02d}'\n                roi_obj = getattr(channel.rois, roi_str)\n                v[roi_str] = [roi_obj.ev_low.get(), roi_obj.ev_high.get()]\n            md[f\"ch{ch_index:02d}\"] = v\n        return md\n\n    def read_config_metadata(self):\n        md = {'device_name': self.name,\n              'roi': self.roi_metadata}\n        return md"
  },
  {
    "class_name": "XmapMCA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/42-xia.py",
    "source": "class XmapMCA(Device):\n    # DO WE REALLY NEED THEM ALL HINTED?\n    val = Cpt(EpicsSignal, \".VAL\", kind=Kind.hinted)\n    R0low = Cpt(EpicsSignal, \".R0LO\", kind=Kind.hinted)\n    R0high = Cpt(EpicsSignal, \".R0HI\", kind=Kind.hinted)\n    R0 = Cpt(EpicsSignal, \".R0\", kind=Kind.hinted)\n    R0nm = Cpt(EpicsSignal, \".R0NM\", kind=Kind.hinted)\n\n    R1low = Cpt(EpicsSignal, \".R1LO\", kind=Kind.hinted)\n    R1high = Cpt(EpicsSignal, \".R1HI\", kind=Kind.hinted)\n    R1 = Cpt(EpicsSignal, \".R1\", kind=Kind.hinted)\n    R1nm = Cpt(EpicsSignal, \".R1NM\", kind=Kind.hinted)\n\n    R2low = Cpt(EpicsSignal, \".R2LO\", kind=Kind.hinted)\n    R2high = Cpt(EpicsSignal, \".R2HI\", kind=Kind.hinted)\n    R2 = Cpt(EpicsSignal, \".R2\", kind=Kind.hinted)\n    R2nm = Cpt(EpicsSignal, \".R2NM\", kind=Kind.hinted)\n\n    R3low = Cpt(EpicsSignal, \".R3LO\", kind=Kind.hinted)\n    R3high = Cpt(EpicsSignal, \".R3HI\", kind=Kind.hinted)\n    R3 = Cpt(EpicsSignal, \".R3\", kind=Kind.hinted)\n    R3nm = Cpt(EpicsSignal, \".R3NM\", kind=Kind.hinted)"
  },
  {
    "class_name": "XmapSCA",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/42-xia.py",
    "source": "class XmapSCA(Device):\n    sca0counts = Cpt(EpicsSignal, \":SCA0Counts\", kind=Kind.hinted)\n    sca1counts = Cpt(EpicsSignal, \":SCA1Counts\", kind=Kind.hinted)\n    sca2counts = Cpt(EpicsSignal, \":SCA2Counts\", kind=Kind.hinted)\n    sca3counts = Cpt(EpicsSignal, \":SCA3Counts\", kind=Kind.hinted)"
  },
  {
    "class_name": "Preamp",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/42-xia.py",
    "source": "class Preamp(Device):\n    adc_percent_rule = Cpt(EpicsSignal, \":ADCPercentRule\")\n    decay_time = Cpt(EpicsSignal, \":DecayTime\")\n    detector_polarity = Cpt(EpicsSignal, \":DetectorPolarity\")\n    max_energy = Cpt(EpicsSignal, \":MaxEnergy\")\n    gain = Cpt(EpicsSignal, \":PreampGain\")\n    reset_delay = Cpt(EpicsSignal, \":ResetDelay\")"
  },
  {
    "class_name": "FlyableEpicsMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/64-flying_epics_motor.py",
    "source": "class FlyableEpicsMotor(Device): # device is needed to have Device status\n    '''\n    This class mimics hhm behavior that is used in the standard HHM ISS flyer\n    '''\n\n    def __init__(self, motor, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.motor = motor\n        self.traj_dict = None\n        self.flying_status = None\n\n    def set_trajectory(self, traj_dict):\n        # traj_dict = {'positions': [point1, point2, point3, point4],\n        #              'durations': [t1_2, t2_3, t3_4]}\n        self.traj_dict = traj_dict\n\n    def prepare(self):\n        return self.motor.move(self.traj_dict['positions'][0], wait=False)\n\n    def kickoff(self):\n        self.flying_status = DeviceStatus(self)\n        thread = threading.Thread(target=self.execute_motion, daemon=True)\n        thread.start()\n        return self.flying_status\n\n    def execute_motion(self):\n        self.data = []\n        def write_data_callback(value, timestamp, **kwargs):\n            self.data.append([timestamp, value])\n        cid = self.motor.user_readback.subscribe(write_data_callback)\n\n        pre_fly_velocity = self.motor.velocity.get()\n        for prev_position, next_position, duration in zip(self.traj_dict['positions'][:-1],\n                                                          self.traj_dict['positions'][1:],\n                                                          self.traj_dict['durations']):\n            velocity = abs(next_position - prev_position) / duration\n            self.motor.velocity.set(velocity).wait()\n            self.motor.move(next_position).wait()\n        self.flying_status.set_finished()\n\n        self.motor.velocity.set(pre_fly_velocity).wait()\n        self.motor.user_readback.unsubscribe(cid)\n\n    def complete(self):\n        self.flying_status = None\n        self.traj_dict = None\n\n    @property\n    def current_trajectory_duration(self):\n        return sum(self.traj_dict['durations'])"
  },
  {
    "class_name": "AnalogPizzaBox",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/33-apb.py",
    "source": "class AnalogPizzaBox(Device):\n\n    polarity = 'pos'\n\n    ch1 = Cpt(EpicsSignal, 'SA:Ch1:mV-I', kind=Kind.hinted)\n    ch2 = Cpt(EpicsSignal, 'SA:Ch2:mV-I', kind=Kind.hinted)\n    ch3 = Cpt(EpicsSignal, 'SA:Ch3:mV-I', kind=Kind.hinted)\n    ch4 = Cpt(EpicsSignal, 'SA:Ch4:mV-I', kind=Kind.hinted)\n    ch5 = Cpt(EpicsSignal, 'SA:Ch5:mV-I', kind=Kind.hinted)\n    ch6 = Cpt(EpicsSignal, 'SA:Ch6:mV-I', kind=Kind.hinted)\n    ch7 = Cpt(EpicsSignal, 'SA:Ch7:mV-I', kind=Kind.hinted)\n    ch8 = Cpt(EpicsSignal, 'SA:Ch8:mV-I', kind=Kind.hinted)\n\n\n    ch1_offset = Cpt(EpicsSignal, 'Ch1:User:Offset-SP', kind=Kind.config)\n    ch2_offset = Cpt(EpicsSignal, 'Ch2:User:Offset-SP', kind=Kind.config)\n    ch3_offset = Cpt(EpicsSignal, 'Ch3:User:Offset-SP', kind=Kind.config)\n    ch4_offset = Cpt(EpicsSignal, 'Ch4:User:Offset-SP', kind=Kind.config)\n    ch5_offset = Cpt(EpicsSignal, 'Ch5:User:Offset-SP', kind=Kind.config)\n    ch6_offset = Cpt(EpicsSignal, 'Ch6:User:Offset-SP', kind=Kind.config)\n    ch7_offset = Cpt(EpicsSignal, 'Ch7:User:Offset-SP', kind=Kind.config)\n    ch8_offset = Cpt(EpicsSignal, 'Ch8:User:Offset-SP', kind=Kind.config)\n\n    ch1_adc_gain = Cpt(EpicsSignal, 'ADC1:Gain-SP')\n    ch2_adc_gain = Cpt(EpicsSignal, 'ADC2:Gain-SP')\n    ch3_adc_gain = Cpt(EpicsSignal, 'ADC3:Gain-SP')\n    ch4_adc_gain = Cpt(EpicsSignal, 'ADC4:Gain-SP')\n    ch5_adc_gain = Cpt(EpicsSignal, 'ADC5:Gain-SP')\n    ch6_adc_gain = Cpt(EpicsSignal, 'ADC6:Gain-SP')\n    ch7_adc_gain = Cpt(EpicsSignal, 'ADC7:Gain-SP')\n    ch8_adc_gain = Cpt(EpicsSignal, 'ADC8:Gain-SP')\n\n    ch1_adc_offset = Cpt(EpicsSignal, 'ADC1:Offset-SP')\n    ch2_adc_offset = Cpt(EpicsSignal, 'ADC2:Offset-SP')\n    ch3_adc_offset = Cpt(EpicsSignal, 'ADC3:Offset-SP')\n    ch4_adc_offset = Cpt(EpicsSignal, 'ADC4:Offset-SP')\n    ch5_adc_offset = Cpt(EpicsSignal, 'ADC5:Offset-SP')\n    ch6_adc_offset = Cpt(EpicsSignal, 'ADC6:Offset-SP')\n    ch7_adc_offset = Cpt(EpicsSignal, 'ADC7:Offset-SP')\n    ch8_adc_offset = Cpt(EpicsSignal, 'ADC8:Offset-SP')\n\n    acquire = Cpt(EpicsSignal, 'FA:SoftTrig-SP', kind=Kind.omitted)\n    acquiring = Cpt(EpicsSignal, 'FA:Busy-I', kind=Kind.omitted)\n\n    data_rate = Cpt(EpicsSignal, 'FA:Rate-I')\n    divide = Cpt(EpicsSignal, 'FA:Divide-SP')\n    sample_len = Cpt(EpicsSignal, 'FA:Samples-SP')\n    wf_len = Cpt(EpicsSignal, 'FA:Wfm:Length-SP')\n\n    stream = Cpt(EpicsSignal,'FA:Stream-SP', kind=Kind.omitted)\n    streaming = Cpt(EpicsSignal,'FA:Streaming-I', kind=Kind.omitted)\n    acq_rate= Cpt(EpicsSignal,'FA:Rate-I', kind=Kind.omitted)\n    stream_samples = Cpt(EpicsSignal, 'FA:Stream:Samples-SP')\n\n    trig_source = Cpt(EpicsSignal, 'Machine:Clk-SP')\n\n    filename_bin = Cpt(EpicsSignal, 'FA:Stream:Bin:File-SP')\n    filebin_status = Cpt(EpicsSignal, 'FA:Stream:Bin:File:Status-I')\n    filename_txt = Cpt(EpicsSignal, 'FA:Stream:Txt:File-SP')\n    filetxt_status = Cpt(EpicsSignal, 'FA:Stream:Txt:File:Status-I')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._IP = '10.66.59.42'\n\n    def read_exposure_time(self):\n        pass\n\n    def set_exposure_time(self, value):\n        pass"
  },
  {
    "class_name": "VonHamosSpectrometerMotors",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/iss-profile-collection/startup/45-device_dictionaries.py",
    "source": "class VonHamosSpectrometerMotors(Device):\n    assm_y = Cpt(EpicsMotor, ':1}Mtr')\n    assm_x = Cpt(EpicsMotor, ':2}Mtr')\n    arc = Cpt(EpicsMotor, ':3}Mtr')\n\n    crystal_x = Cpt(EpicsMotor, ':6}Mtr')\n    crystal_yaw = Cpt(EpicsMotor, ':7}Mtr')\n    crystal_pitch = Cpt(EpicsMotor, ':8}Mtr')"
  },
  {
    "class_name": "PBSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/24-powerbrick.py",
    "source": "class PBSignalWithRBV(EpicsSignal):\n    # An EPICS signal that uses the NSLS-II convention of 'pvname-SP' being the\n    # setpoint and 'pvname-I' being the read-back\n\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix + '-I', write_pv=prefix + '-SP', **kwargs)"
  },
  {
    "class_name": "PowerBrickVectorMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/24-powerbrick.py",
    "source": "class PowerBrickVectorMotor(Device):\n    start = Cpt(PBSignalWithRBV, 'Start')\n    end = Cpt(PBSignalWithRBV, 'End')\n\n    def __init__(self, prefix, *, parent=None, **kwargs):\n        cfg_attrs = ['start', 'end']\n        super().__init__(prefix, configuration_attrs=cfg_attrs,\n                         parent=parent, **kwargs)"
  },
  {
    "class_name": "PowerBrickVectorBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/24-powerbrick.py",
    "source": "class PowerBrickVectorBase(Device):\n    x = Cpt(PowerBrickVectorMotor, 'Pos:X')\n    y = Cpt(PowerBrickVectorMotor, 'Pos:Y')\n    z = Cpt(PowerBrickVectorMotor, 'Pos:Z',)\n    o = Cpt(PowerBrickVectorMotor, 'Pos:O')\n\n    exposure = Cpt(PBSignalWithRBV, 'Val:Exposure')\n    num_samples = Cpt(PBSignalWithRBV, 'Val:NumSamples')\n\n    expose = Cpt(EpicsSignal, 'Expose-Sel')\n    hold = Cpt(EpicsSignal, 'Hold-Sel')\n\n    state = Cpt(EpicsSignalRO, 'Sts:State-Sts', auto_monitor=True)\n    running = Cpt(EpicsSignalRO, 'Sts:Running-Sts', auto_monitor=True)\n\n    go = Cpt(EpicsSignal, 'Cmd:Go-Cmd')\n    proceed = Cpt(EpicsSignal, 'Cmd:Proceed-Cmd')\n    abort = Cpt(EpicsSignal, 'Cmd:Abort-Cmd')\n    sync = Cpt(EpicsSignal, 'Cmd:Sync-Cmd')\n\n    def __init__(self, prefix, configuration_attrs=None, *args, **kwargs):\n        cfg_attrs = ['x', 'y', 'z', 'o', 'exposure', 'num_samples', 'expose', 'hold']\n        if configuration_attrs is not None:\n            cfg_attrs = configuration_attrs + cfg_attrs\n        super().__init__(prefix, configuration_attrs=cfg_attrs, *args, **kwargs)\n\n        self.motors = [self.x, self.y, self.z, self.o]"
  },
  {
    "class_name": "RISlider",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/23-attenuator_crl_99.py",
    "source": "class RISlider(Device):\n    mv_in = Cpt(EpicsSignal, 'Cmd:In-Cmd')\n    mv_out = Cpt(EpicsSignal, 'Cmd:Out-Cmd')\n    status = Cpt(EpicsSignalRO, 'Pos-Sts')"
  },
  {
    "class_name": "AttenuatorRI",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/23-attenuator_crl_99.py",
    "source": "class AttenuatorRI(Device):\n    f1 = Cpt(RISlider, '01}')\n    f2 = Cpt(RISlider, '02}')\n    f3 = Cpt(RISlider, '03}')\n    f4 = Cpt(RISlider, '04}')\n    f5 = Cpt(RISlider, '05}')\n    f6 = Cpt(RISlider, '06}')\n    f7 = Cpt(RISlider, '07}')\n    f8 = Cpt(RISlider, '08}')\n    f9 = Cpt(RISlider, '09}')\n    f10 = Cpt(RISlider, '10}')\n    f11 = Cpt(RISlider, '11}')\n    f12 = Cpt(RISlider, '12}')"
  },
  {
    "class_name": "Transfocator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/23-attenuator_crl_99.py",
    "source": "class Transfocator(Device):\n    c1 = Cpt(RISlider, '01}')\n    c2 = Cpt(RISlider, '02}')\n    c3 = Cpt(RISlider, '03}')\n    c4 = Cpt(RISlider, '04}')\n    c5 = Cpt(RISlider, '05}')\n    c6 = Cpt(RISlider, '06}')\n    c7 = Cpt(RISlider, '07}')\n    c8 = Cpt(RISlider, '08}')\n    c9 = Cpt(RISlider, '09}')\n    c10 = Cpt(RISlider, '10}')\n    c11 = Cpt(RISlider, '11}')\n    c12 = Cpt(RISlider, '12}')\n    vs = Cpt(RISlider, '02}')  # 1st bank with V slit\n    v2a = Cpt(RISlider, '04}') # 1st bank with 2 V lenses\n    v1a = Cpt(RISlider, '06}') # 1st bank with 1 V lens\n    v1b = Cpt(RISlider, '08}') # 2nd bank with 1 V lens\n    hs = Cpt(RISlider, '01}')  # 1st bank with H slit\n    h4a = Cpt(RISlider, '03}') # 1st bank with 4 H lenses\n    h2a = Cpt(RISlider, '05}') # 1st bank with 2 H lenses\n    h1a = Cpt(RISlider, '07}') # 1st bank with 1 H lens\n    h1b = Cpt(RISlider, '09}')"
  },
  {
    "class_name": "ppmac_input",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/27-chip_scanner.py",
    "source": "class ppmac_input(Device):\n    prog = Cpt(EpicsSignal, 'Program')\n    dwell = Cpt(EpicsSignal, 'Dwell')\n    drop_dwell = Cpt(EpicsSignal, 'DropDwell')\n    move_time = Cpt(EpicsSignal, 'Move')\n    go = Cpt(EpicsSignal, 'Go')\n    input_string = Cpt(EpicsSignal, 'Input')\n    mode = Cpt(EpicsSignal, 'Mode')\n    x_positions = Cpt(EpicsSignal, 'X_POSNS')\n    y_positions = Cpt(EpicsSignal, 'Y_POSNS')\n    dwell_times = Cpt(EpicsSignal, 'DWELLS')\n    drop_bools = Cpt(EpicsSignal, 'DROPS')\n    capture_bools = Cpt(EpicsSignal, 'IMAGES')\n    x_0 = Cpt(EpicsSignal, 'X0')\n    x_displacement = Cpt(EpicsSignal, 'X_VEC')\n    y_displacement = Cpt(EpicsSignal, 'Y_VEC')\n    end = Cpt(EpicsSignalRO, \"End\")\n\n    def create_program_from_points(self, program_number, move_time, x_list, y_list, dwell_list, drop_list, capture_list, start_position, fiducial_x, fiducial_y):\n        self.mode.put('POSITIONS')\n        self.move_time.put(move_time)\n        self.prog.put(program_number)\n        self.x_0.put(start_position)\n        self.x_displacement.put(fiducial_x*5/1016) # Distance between x wells = 25400*5/1016 = 125\n        self.y_displacement.put(fiducial_y*5/1016) # Distance between y wells = 25400*5/1016 = 125\n        self.x_positions.put(x_list)\n        self.y_positions.put(y_list)\n        self.dwell_times.put(dwell_list)\n        self.drop_bools.put(drop_list)\n        self.capture_bools.put(capture_list)\n        setattr(self, f'ready{program_number}', True)\n\n    def send_program(self, program_number, dwell_time, move_time, input_array, drop_dwell=None):\n        self.mode.put('STRING')\n        self.dwell.put(dwell_time)\n        if drop_dwell:\n            self.drop_dwell.put(drop_dwell)\n        else:\n            self.drop_dwell.put(dwell_time)\n        self.move_time.put(move_time)\n        self.prog.put(program_number)\n        i_string = \"\"\n        for row in input_array:\n            i_string = i_string + f'x{row[0]}y{row[1]}_'\n        self.input_string.put(i_string[:-1])\n        setattr(self, f'ready{program_number}', True)\n\n    def run_program(self, program_number):\n        if hasattr(self, f'ready{program_number}'):\n            self.go.put(1)\n        else:\n            print(f'Must create program {program_number} first!')"
  },
  {
    "class_name": "ChipScanner",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/27-chip_scanner.py",
    "source": "class ChipScanner(Device):\n    x = Cpt(MotorWithEncoder, 'XF:17IDC-ES:FMX{Chip:1-Ax:CX}Mtr')\n    y = Cpt(MotorWithEncoder, 'XF:17IDC-ES:FMX{Chip:1-Ax:CY}Mtr')\n    z = Cpt(MotorWithEncoder, 'XF:17IDC-ES:FMX{Gon:2-Ax:GZ}Mtr')\n\n    drpyz = Cpt(EpicsMotor, 'XF:17IDC-ES:FMX{Drp:1-Ax:YZ}Mtr')\n    drpy = Cpt(EpicsMotor, 'XF:17IDC-ES:FMX{Drp:1-Ax:Y}Mtr')\n    drpx = Cpt(EpicsMotor, 'XF:17IDC-ES:FMX{Drp:1-Ax:X}Mtr')\n\n    def __init__(self, F0_x, F0_y, F1_x, F1_y, F2_x, F2_y,\n                 BLnum_x, BLnum_y, BLgap_x, BLgap_y,\n                 APnum_x, APnum_y, APgap_x, APgap_y,\n                 lo_camera, hi_camera, **kwargs):\n        super().__init__(**kwargs)\n\n        self.F0_x = F0_x\n        self.F0_y = F0_y\n        self.F1_x = F1_x\n        self.F1_y = F1_y\n        self.F2_x = F2_x\n        self.F2_y = F2_y\n\n        self.BLnum_x = BLnum_x\n        self.BLnum_y = BLnum_y\n        self.BLgap_x = BLgap_x\n        self.BLgap_y = BLgap_y\n\n        self.APnum_x = APnum_x\n        self.APnum_y = APnum_y\n        self.APgap_x = APgap_x\n        self.APgap_y = APgap_y\n\n        self.lo_camera = lo_camera\n        self.hi_camera = hi_camera\n\n        self.lo_camera_ratios = (BL_calibration.LoMagCal.get(), BL_calibration.LoMagCal.get())\n        self.hi_camera_ratios = (BL_calibration.HiMagCal.get(), BL_calibration.HiMagCal.get())\n\n        self.filepath = None\n        \n        self.additional_fiducials = {}\n\n    def set_droplet_reference_1(self):\n        self.z_ref_1 = self.z.get().user_readback\n        self.yz_ref_1 = self.drpyz.get().user_readback\n        self.y_ref_1 = self.drpy.get().user_readback\n        self.x_ref_1 = self.drpx.get().user_readback\n\n    #def set_droplet_reference_2(self):\n    #    self.z_ref_2 = self.z.get().user_readback\n    #    self.yz_ref_2 = self.drpyz.get().user_readback\n    #    self.y_ref_2 = self.drpy.get().user_readback\n    #    self.x_ref_2 = self.drpx.get().user_readback\n\n    def correct_droplet_offset(self, y_offset = 0):\n        offset = -self.z.get().user_readback + self.z_ref_1\n        #slope = (self.y_ref_1 - self.y_ref_2) / (self.z_ref_1 - self.z_ref_2)\n        slope = 1\n        y = -slope*offset + self.y_ref_1\n        yield from bps.mv(self.drpy, y+y_offset)\n\n    def manual_set_fiducial(self, location):\n        x_loc = self.x.get().user_readback\n        y_loc = self.y.get().user_readback\n        z_loc = self.z.get().user_readback\n\n        x_loc_enc = self.x.get().encoder_readback\n        y_loc_enc = self.y.get().encoder_readback\n        z_loc_enc = self.z.get().encoder_readback\n\n        setattr(self, location+\"_x_motor\", x_loc)\n        setattr(self, location+\"_y_motor\", y_loc)\n        setattr(self, location+\"_z_motor\", z_loc)\n\n        setattr(self, location+\"_x_motor_enc\", x_loc_enc)\n        setattr(self, location+\"_y_motor_enc\", y_loc_enc)\n        setattr(self, location+\"_z_motor_enc\", z_loc_enc)\n\n        setattr(self, location, np.array([x_loc, y_loc, z_loc]))\n        setattr(self, location + \"_enc\", np.array([x_loc_enc, y_loc_enc, z_loc_enc]))\n        \n    def override_fiducials(self, points = None):\n        if points is not None:\n            if len(points) != 3:\n                print(f\"Refiducialization currently only supports 3 points, {len(points)} were given.\")\n                return False\n            for p in points:\n                if p not in self.additional_fiducials:\n                    print(f\"Point {p} is not present in the additional_fiducials dictionary, failed to refiducialize.\")\n                    return False\n        else:\n            if len(self.additional_fiducials) < 3:\n                print(f\"At least 3 additional fiducials must be present in the additional_fiducials dictionary to refiducialize, but only {len(self.additional_fiducials)} are present.\")\n                return(False)\n            elif len(self.additional_fiducials) > 3:\n                print(f\"More than 3 additional fiducials identified, refiducializing on {list(self.additional_fiducials.keys())[0:3]}.\")\n            points = list(self.additional_fiducials.keys())[0:3]\n\n        p0_ns = self.additional_fiducials[points[0]][2]\n        d1 = self.additional_fiducials[points[1]][2] - self.additional_fiducials[points[0]][2]\n        d2 = self.additional_fiducials[points[2]][2] - self.additional_fiducials[points[0]][2]\n\n        M = np.transpose(np.vstack([d1, d2]))\n        Minv = np.linalg.inv(M)\n        \n        v1 = self.additional_fiducials[points[1]][0] - self.additional_fiducials[points[0]][0]\n        v2 = self.additional_fiducials[points[2]][0] - self.additional_fiducials[points[0]][0]\n        \n        v1_enc = self.additional_fiducials[points[1]][1] - self.additional_fiducials[points[0]][1]\n        v2_enc = self.additional_fiducials[points[2]][1] - self.additional_fiducials[points[0]][1]\n        \n        V = np.transpose(np.vstack([v1, v2]))\n\n        V_enc = np.transpose(np.vstack([v1_enc, v2_enc]))\n        tvecs = np.matmul(V, Minv)\n        \n        tvecs_enc = np.matmul(V_enc, Minv)\n\n        self.f0t = np.squeeze(np.asarray(np.reshape(self.additional_fiducials[points[0]][0] - p0_ns[0]*tvecs[:,0] - p0_ns[1]*tvecs[:,1], (3,1))))\n        self.f1t = np.squeeze(np.asarray(np.reshape(self.additional_fiducials[points[0]][0] - (p0_ns[0]-25400)*tvecs[:,0] - p0_ns[1]*tvecs[:,1], (3,1))))\n        self.f2t = np.squeeze(np.asarray(np.reshape(self.additional_fiducials[points[0]][0] - p0_ns[0]*tvecs[:,0] - (p0_ns[1]-25400)*tvecs[:,1], (3,1))))\n        \n        self.f0t_enc = np.squeeze(np.asarray(np.reshape(self.additional_fiducials[points[0]][1] - p0_ns[0]*tvecs_enc[:,0] - p0_ns[1]*tvecs_enc[:,1], (3,1))))\n        self.f1t_enc = np.squeeze(np.asarray(np.reshape(self.additional_fiducials[points[0]][1] - (p0_ns[0]-25400)*tvecs_enc[:,0] - p0_ns[1]*tvecs_enc[:,1], (3,1))))\n        self.f2t_enc = np.squeeze(np.asarray(np.reshape(self.additional_fiducials[points[0]][1] - p0_ns[0]*tvecs_enc[:,0] - (p0_ns[1]-25400)*tvecs_enc[:,1], (3,1))))\n        \n        for i in range(3):\n            setattr(self, f'F{i}', getattr(self,f'f{i}t'))\n            setattr(self, f'F{i}_enc', getattr(self, f'f{i}t_enc'))\n            \n    def use_as_fiducial(self, location, limit=100):\n        chip_x, chip_y = self.name_to_fiducial_distances(location)\n        motor_loc = self.fiducial_distances_to_location(chip_x, chip_y)\n\n        x_loc = self.x.get().user_readback\n        y_loc = self.y.get().user_readback\n        z_loc = self.z.get().user_readback\n\n        x_loc_enc = self.x.get().encoder_readback\n        y_loc_enc = self.y.get().encoder_readback\n        z_loc_enc = self.z.get().encoder_readback\n        \n        ### UGLY HACK by Martin: Up limit from 50 to 150 um\n        if not np.linalg.norm(np.array([x_loc, y_loc, z_loc]) - motor_loc) < limit:\n            print(\"Current location is outside of allowed region for correction, please redo the manual_set_fiducial routine and retry.\")\n            return False\n\n        mloc = np.array([x_loc, y_loc, z_loc])\n        eloc = np.array([x_loc_enc, y_loc_enc, z_loc_enc])\n        cloc = np.array(self.name_to_fiducial_distances(location))\n        self.additional_fiducials[location] = Fiducial_Location(mloc, eloc, cloc)\n        \n    def calculate_fit(self):\n        ab = self.F1 - self.F0\n        ac = self.F2 - self.F0\n        print(f\"Distance between fiducial F0 and F1: {np.linalg.norm(ab):6.0f}um\")\n        print(f\"Distance between fiducial F0 and F2: {np.linalg.norm(ac):6.0f}um\")\n        cos_theta = np.dot(ab, ac)/np.linalg.norm(ab)/np.linalg.norm(ac)\n        theta = np.arccos(np.clip(cos_theta, -1, 1))\n        print(f\"Angle between vectors: {theta:6.4f}radians ({theta*180/np.pi:6.3f}deg)\")\n        return(np.linalg.norm(ab), np.linalg.norm(ac), np.arccos(np.clip(cos_theta, -1, 1)))\n\n    def get_fiducials(self):\n        return self.F0, self.F1, self.F2, self.F0_enc, self.F1_enc, self.F2_enc\n\n    def save_fiducials(self, filepath=None):\n        if not filepath:\n            current_time = time.strftime(\"%Y%m%d-%H%M\")\n            filepath = save_dir+\"/current_fiducials-\"+current_time+\"rs.txt\"\n        with open(filepath, 'ab') as f:\n            for arr in self.get_fiducials():\n                np.save(f, arr)\n\n    def load_fiducials(self, filepath=None):\n        if not filepath:\n            list_of_files = glob.glob(f'{save_dir}/*')\n            filepath = max(list_of_files, key=os.path.getctime)\n        to_load = ['F0', 'F1', 'F2', 'F0_enc', 'F1_enc', 'F2_enc']\n        with open(filepath, 'rb') as f:\n            for prop in to_load:\n                setattr(self, prop, np.load(f))\n\n    def load_last_fiducials(self):\n        list_of_files = glob.glob(f'{save_dir}/*')\n        latest_file = max(list_of_files, key=os.path.getctime)\n        self.load_fiducials(latest_file)\n\n    def set_fiducials(self, F0, F1, F2, F0e, F1e, F2e):\n        self.F0 = F0\n        self.F1 = F1\n        self.F2 = F2\n        self.F0_enc = F0e\n        self.F1_enc = F1e\n        self.F2_enc = F2e\n\n    def save_droplet_reference(self, filepath=None):\n        params = [\"z_ref_1\", \"yz_ref_1\", \"y_ref_1\", \"x_ref_1\"]#, \"z_ref_2\", \"yz_ref_2\", \"y_ref_2\", \"x_ref_2\"]\n        if not filepath:\n            current_time = time.strftime(\"%Y%m%d-%H%M\")\n            filepath = droplet_dir+\"/current_droplet_ref-\"+current_time+\"rs.txt\"\n        with open(filepath, 'ab') as f:\n            for p in params:\n                np.save(f,getattr(self, p))\n\n    def load_droplet_reference(self, filepath=None):\n        params = [\"z_ref_1\", \"yz_ref_1\", \"y_ref_1\", \"x_ref_1\"]#, \"z_ref_2\", \"yz_ref_2\", \"y_ref_2\", \"x_ref_2\"]\n        if not filepath:\n            list_of_files = glob.glob(f'{droplet_dir}/*')\n            filepath = max(list_of_files, key=os.path.getctime)\n        with open(filepath, 'rb') as f:\n            for p in params:\n                setattr(self, p, np.load(f))\n\n    def save_all(self, filepath=None):\n        if not filepath:\n            current_time = time.strftime(\"%Y%m%d-%H%M\")\n            filepath = droplet_dir+\"/fiducials_ref-\"+current_time+\".txt\"\n        fiducials = (self.F0, self.F1, self.F2, self.F0_enc, self.F1_enc, self.F2_enc)\n        try:\n            params = [\"z_ref_1\", \"yz_ref_1\", \"y_ref_1\", \"x_ref_1\"]\n            droplets = [getattr(self, p) for p in params]\n        except AttributeError as e:\n            droplets = None\n        to_save = Save_Objects(fiducials, self.additional_fiducials, droplets)\n        with open(filepath, 'wb') as f:\n            pickle.dump(to_save, f, protocol=pickle.HIGHEST_PROTOCOL)\n\n    def load_all(self, filepath=None):\n        if not filepath:\n            list_of_files = glob.glob(f'{droplet_dir}/*')\n            filepath = max(list_of_files, key=os.path.getctime)\n        with open(filepath, 'rb') as f:\n            to_load = pickle.load(f)\n        fs = ['F0', 'F1', 'F2', 'F0_enc', 'F1_enc', 'F2_enc']\n        for i, f in enumerate(fs):\n            setattr(self, f, to_load[0][i])\n        self.additional_fiducials = to_load[1]\n        if to_load[2] is not None:\n            params = [\"z_ref_1\", \"yz_ref_1\", \"y_ref_1\", \"x_ref_1\"]\n            for i, f in enumerate(params):\n                setattr(self, f, to_load[2][i])\n\n    def center_on_point(self):\n        yield from bps.sleep(0.5)\n        focus_size = 200  # Size to cover large fiducial, not the small neighbors\n        MagCal = BL_calibration.HiMagCal.get()\n\n        if not hasattr(self, \"ROI_centers\"):\n            mins = self.hi_camera.roi1.min_xyz.get()\n            sizes = self.hi_camera.roi1.size.get()\n            self.ROI_centers = [int(mins.min_y + sizes.y/2), int(mins.min_x + sizes.x/2)]\n\n        hi_image = self.hi_camera.image.image\n        with open(f'hi_pictures/hcam{int(time.time()*10)}.npy', 'wb') as f:\n            np.save(f, hi_image)\n\n        d2d = np.sum(hi_image, axis=2)[self.ROI_centers[0]-100:self.ROI_centers[0]+100, self.ROI_centers[1]-100:self.ROI_centers[1]+100]\n\n        blurred_image = scipy.ndimage.gaussian_filter(d2d, 8, truncate=3.0)\n        with open(f'hi_pictures/blurred{int(time.time()*10)}.npy', 'wb') as f:\n            np.save(f, hi_image)\n        center_y, center_x = np.unravel_index(np.argmax(blurred_image, axis=None), blurred_image.shape)\n\n        dx_mot =  MagCal * (center_x - int(focus_size/2))\n        dy_mot =  -MagCal * (center_y - int(focus_size/2))\n        print(d2d, center_y, center_x, dx_mot, dy_mot)\n        yield from bps.mvr(self.x, dx_mot, self.y, dy_mot)\n        with open(f'hi_pictures/hcam{int(time.time()*10)}.npy', 'wb') as f:\n            np.save(f, hi_image)\n        yield from bps.sleep(0.5)\n        with open(f'hi_pictures/hcam{int(time.time()*10)}.npy', 'wb') as f:\n            np.save(f, hi_image)\n\n    def name_to_fiducial_distances(self, location_name):\n        \"\"\"Given a location name of the form @#&& where @ is a capital\n        letter from A-H, # is a number from 1-8 and &s are lower case\n        letters from a-t, returns the x and y coordinates of the\n        desired house on the chip, relative to the fiducials F0=(0,0).\n\n        Only valid for the Oxford Chip.\"\"\"\n\n        Ny = ord(location_name[0])-65\n        Nx = int(location_name[1])-1\n        Hy = ord(location_name[2])-97\n        Hx = ord(location_name[3])-97\n\n        x_loc = (self.F0_x +\n                 Nx*(self.BLgap_x + (self.APnum_x-1)*self.APgap_x) +\n                 Hx*self.APgap_x)\n\n        y_loc = (self.F0_y +\n                 Ny*(self.BLgap_y + (self.APnum_y-1)*self.APgap_y) +\n                 Hy*self.APgap_y)\n\n        return x_loc, y_loc\n\n    def fiducial_distances_to_location(self, x_loc, y_loc, original_fiducials = False):\n        \"\"\"Given distances to the fiducial from the starting point F0=(0,0),\n        returns the x, y and z coordinates of the desired house on the chip.\n\n        Only valid for the Oxford Chip.\"\"\"\n\n        M = np.array([self.F1-self.F0, self.F2-self.F0]).transpose()\n        if original_fiducials:\n            relative_x_loc = x_loc/self.F1_x\n            relative_y_loc = y_loc/self.F2_y\n            relative_loc = np.array([relative_x_loc, relative_y_loc])\n            motor_coords = np.matmul(M, relative_loc) + self.F0\n        else:\n            location_options = {np.linalg.norm([x_loc-0, y_loc-0]):'F0', np.linalg.norm([x_loc-25400, y_loc-0]):'F1', np.linalg.norm([x_loc-0, y_loc-25400]):'F2'}\n            for loc, pls in self.additional_fiducials.items():\n                location_options[np.linalg.norm(pls.chip_loc - np.array([x_loc, y_loc]))] = loc\n            closest_location = location_options[min(location_options)]\n            if closest_location in ['F0', 'F1', 'F2']:\n                motor_loc = self.F0\n                chip_loc = [0,0]\n            else:\n                motor_loc, enc_loc, chip_loc = self.additional_fiducials[closest_location]\n            relative_x_loc = (x_loc - chip_loc[0])/self.F1_x\n            relative_y_loc = (y_loc - chip_loc[1])/self.F2_y\n            relative_loc = np.array([relative_x_loc, relative_y_loc])\n            motor_coords = np.matmul(M, relative_loc) + motor_loc\n\n        return(motor_coords)\n\n\n    def fiducial_distances_to_enc_location(self, x_loc, y_loc):\n        \"\"\"Given distances to the fiducial from the starting point F0=(0,0),\n        returns the x, y and z encoder coordinates of the desired house on\n        the chip.\n\n        Only valid for the Oxford Chip.\"\"\"\n\n        relative_x_loc = x_loc/self.F1_x\n        relative_y_loc = y_loc/self.F2_y\n\n        relative_loc = np.array([relative_x_loc, relative_y_loc])\n\n        M = np.array([self.F1_enc-self.F0_enc, self.F2_enc-self.F0_enc]).transpose()\n        motor_coords = np.matmul(M, relative_loc) + self.F0_enc\n        return(motor_coords)\n\n    def drive_to_location(self, location_name):\n        chip_x, chip_y = self.name_to_fiducial_distances(location_name)\n        motor_loc = self.fiducial_distances_to_location(chip_x, chip_y)\n        yield from bps.mv(self.x, motor_loc[0], self.y, motor_loc[1], self.z, motor_loc[2])\n\n    def configure_detector(self, filename, triggers, acquisition_time = 0.01):\n        #path = '/nsls2/data/fmx/proposals/commissioning/pass-312064/312064-20230706-fuchs/mx312064-1'\n        if not self.filepath:\n            print(f'Must set filepath attribute for this chip scanner object before taking data, to determine location where the file will be saved.')\n            raise Exception('Filepath not found')\n        eiger_single.cam.acquire_time.put(acquisition_time)\n        eiger_single.cam.fw_num_images_per_file.put(triggers)\n        eiger_single.cam.file_path.put(self.filepath)\n        if not eiger_single.cam.file_path_exists.get():\n            print(f'Filepath {self.filepath} does not appear to be a valid directory recognized by the Eiger detector.')\n            raise Exception('Filepath not found')\n        eiger_single.cam.num_images.put(triggers)\n        eiger_single.cam.num_triggers.put(triggers)\n        eiger_single.cam.trigger_mode.put(3)\n        my_time = int(time.time())\n        eiger_single.cam.fw_name_pattern.put(f'CHIP{filename}{my_time}')\n        dist = getDetectorDist(configStr = 'Chip_Scanner')\n        eiger_single.cam.omega_start.put(0)\n        eiger_single.cam.omega_incr.put(0)\n        eiger_single.cam.det_distance.put(dist/1000)\n        def check_armed(*, old_value, value, **kwargs):\n            return(old_value == 0 and value == 1)\n        status = SubscriptionStatus(eiger_single.cam.acquire, check_armed)\n        eiger_single.cam.acquire.put(1)\n        return status\n\n    def pre_scan_setup(self, location, n_images, acquisition_time = 10, refocus = False, recenter = True, expose_to_beam=True, transition_before=True):\n        self.configure_zebra_for_hare()\n        #self.configure_detector(location, n_images, acquisition_time = acquisition_time/1000) # ms -> s\n        yield from self.drive_to_location(location)\n        if recenter and (transition_before or not expose_to_beam):\n            yield from self.center_on_point()\n        if refocus and transition_before:\n            yield from autofocus(self.hi_camera, 'stats4_sigma_x', self.z, -10,10,15)\n        enc_loc = np.array([self.x.get().encoder_readback, self.y.get().encoder_readback])\n        return(enc_loc)\n        \n    def scan_and_cleanup(self, xl, yl, dwell_list, dl, cl, enc_loc, expose_to_beam=True, transition_before=True, transition_after=True, detector_status = None, control_detector = True):\n        ppmac_channel.create_program_from_points(23, 10, xl, yl, dwell_list, dl, cl, enc_loc, self.F1_enc - self.F0_enc, self.F2_enc - self.F0_enc) ############ Might need a sleep here, let's try without first though\n        if transition_before:\n            govStateSet('CD', configStr = 'Chip_Scanner')\n        if expose_to_beam:\n            shutter_bcu.open.put(1)\n        if detector_status is not None:\n            detector_status.wait(10)\n        ppmac_channel.run_program(23)\n        endpoint = ppmac_channel.end.get()\n        while True:\n            loc = np.array([self.x.get().encoder_readback, self.y.get().encoder_readback])\n            if abs((loc-endpoint)[0]) < 10 and abs((loc-endpoint)[1]) < 10:\n                time.sleep(0.5)\n                break\n            time.sleep(1)\n        shutter_bcu.close.put(1)\n        if control_detector:\n            def check_eiger_disarmed(*, old_value, value, **kwargs):\n                return(old_value == 1 and value == 0)\n            status = SubscriptionStatus(eiger_single.cam.acquire, check_eiger_disarmed)\n            eiger_single.cam.acquire.put(0)\n        if transition_after:\n            govStateSet('CA', configStr = 'Chip_Scanner')\n        if control_detector:\n            status.wait(10)\n\n    def line_scan(self, line, acquisition_time = 10, location_offset_x = 0.0, location_offset_y = 0.0, refocus = False, recenter = True, expose_to_beam=True, transition_before=True, transition_after=True, control_detector = True):\n        pattern = re.compile(\"^([A-H][1-8][a-t])$\")\n        if not pattern.match(line):\n            print(f\"Hare scan requires input of form ex. A1d, got {line}. \")\n            return(False)\n        if control_detector:\n            detector_status = self.configure_detector(line, 20, acquisition_time = acquisition_time/1000)\n        else:\n            detector_status = None\n        enc_loc = yield from self.pre_scan_setup(line+\"a\", 20, acquisition_time = acquisition_time, refocus = refocus, recenter = recenter, expose_to_beam=expose_to_beam, transition_before=transition_before)\n        xl = list(range(-1,21))\n        yl = [0]*22\n        dl = [0]*22\n        cl = [0] + [1]*20 + [0]\n        dwell_list = [acquisition_time]*22\n        self.scan_and_cleanup(xl, yl, dwell_list, dl, cl, enc_loc, expose_to_beam=expose_to_beam, transition_before=transition_before, transition_after=transition_after, detector_status=detector_status, control_detector = control_detector)\n\n    def neighbourhood_scan(self, neighbourhood, acquisition_time = 10, location_offset_x = 0.0, location_offset_y = 0.0, refocus = False, recenter = True, expose_to_beam=True, transition_before=True, transition_after=True, control_detector = True):\n        pattern = re.compile(\"^([A-H][1-8])$\")\n        if not pattern.match(neighbourhood):\n            print(f\"Hare scan requires input of form ex. A1, got {neighbourhood}.\")\n            return(False)\n        if control_detector:\n            detector_status = self.configure_detector(neighbourhood, 400, acquisition_time = acquisition_time/1000)\n        else:\n            detector_status = None\n        enc_loc = yield from self.pre_scan_setup(neighbourhood+\"aa\", 400, acquisition_time = acquisition_time, refocus = refocus, recenter = recenter, expose_to_beam=expose_to_beam, transition_before=transition_before)\n        xl = []\n        yl = []\n        dl = []\n        cl = []\n        dwell_list = []\n        for y in range(10):\n            xl = xl + list(range(-1,21))\n            yl = yl + [y*2]*22\n            dl = dl + [0]*22\n            cl = cl + [0] + [1]*20 + [0]\n            dwell_list = dwell_list + [acquisition_time]*22\n\n            xl = xl + list(range(20,-2,-1))\n            yl = yl + [y*2 + 1]*22\n            dl = dl + [0]*22\n            cl = cl + [0] + [1]*20 + [0]\n            dwell_list = dwell_list + [acquisition_time]*22\n        self.scan_and_cleanup(xl, yl, dwell_list, dl, cl, enc_loc, expose_to_beam=expose_to_beam, transition_before=transition_before, transition_after=transition_after, detector_status=detector_status, control_detector = control_detector)\n\n    def calculate_hare(self, drop_to_det_time, droplet_offset_value = 0, acquisition_time = 10, post_drop_dwell_min_time = 10):\n        if not post_drop_dwell_min_time >= acquisition_time:\n            print(f\"post_drop_dwell_min_time ({post_drop_dwell_min_time}) must be greater than or equal to acquisition_time ({acquisition_time}).\")\n            raise RuntimeError(f\"post_drop_dwell_min_time ({post_drop_dwell_min_time}) must be greater than or equal to acquisition_time ({acquisition_time}).\")\n        motor_speed = epics.caget('XF:17IDC-ES:FMX{Chip:1-Ax:CX}Mtr.VELO')\n        well_move_time = 1000/(motor_speed/125)\n        min_time = well_move_time/2 + post_drop_dwell_min_time\n        if drop_to_det_time < min_time:\n            print(f'Minimum available time is {min_time} determined by the delay after the drop trigger prior to a move ({post_drop_dwell_min_time}) and the motor speed ({motor_speed} um/s).')\n            raise RuntimeError(f'Minimum available time is {min_time} determined by the delay after the drop trigger prior to a move ({post_drop_dwell_min_time}) and the motor speed ({motor_speed} um/s).')\n        steps_ahead = int((drop_to_det_time + 2*well_move_time)/(2*well_move_time+post_drop_dwell_min_time))\n        print(f\"HARE #{steps_ahead}\")\n        if steps_ahead == 1:\n            pdd = int(drop_to_det_time - .5*well_move_time)\n        else:\n            pdd = int((drop_to_det_time + 2*well_move_time)/steps_ahead - 2*well_move_time)\n        if steps_ahead == 1:\n            yield from self.correct_droplet_offset(y_offset=droplet_offset_value)\n        else:\n            yield from self.correct_droplet_offset(y_offset=-62.5+droplet_offset_value)\n        return well_move_time, steps_ahead, pdd\n\n    def line_scan_hare(self, line, drop_to_det_time, droplet_offset_value = 0, acquisition_time = 10, post_drop_dwell_min_time = 10, location_offset_x = 0.0, location_offset_y = 0.0, refocus = False, recenter = True, expose_to_beam=True, transition_before=True, transition_after=True, control_detector = True):\n        pattern = re.compile(\"^([A-H][1-8][a-t])$\")\n        if not pattern.match(line):\n            print(f\"Hare scan requires input of form ex. A1d, got {line}.\")\n            return(False)\n        if control_detector:\n            detector_status = self.configure_detector(line, 20, acquisition_time = acquisition_time/1000)\n        else:\n            detector_status = None\n        enc_loc = yield from self.pre_scan_setup(line+\"a\", 20, acquisition_time = acquisition_time, refocus = refocus, recenter = recenter, expose_to_beam=expose_to_beam, transition_before=transition_before)\n        well_move_time, steps_ahead, pdd = yield from self.calculate_hare(drop_to_det_time, droplet_offset_value = droplet_offset_value, acquisition_time = acquisition_time, post_drop_dwell_min_time = post_drop_dwell_min_time)\n        n_scans, remains = divmod(20, steps_ahead)\n        xl = []\n        yl = []\n        dl = []\n        cl = []\n        dwell_list = []\n        if steps_ahead == 1:\n            for n in range(20):\n                xl = xl + [-.5 + n] + [n]\n                yl = yl + [0] + [0]\n                dl = dl + [1] + [0]\n                cl = cl + [0] + [1]\n                dwell_list = dwell_list + [pdd] + [pdd]\n        else:\n            for n in range(n_scans):\n                xl = xl + [i-.5 + n*steps_ahead for i in range(0,steps_ahead)] + [n*steps_ahead] + [i + n*steps_ahead for i in range(0,steps_ahead)]\n                yl = yl + [-.5]*steps_ahead + [-.5] + [0]*steps_ahead\n                dl = dl + [1]*steps_ahead + [0] + [0]*steps_ahead\n                cl = cl + [0]*steps_ahead + [0] + [1]*steps_ahead\n                dwell_list = dwell_list + [pdd]*steps_ahead + [0] + [pdd]*steps_ahead\n            if remains != 0:\n                xl = xl + [i-.5 + n_scans*steps_ahead for i in range(0,remains)] + [n_scans*steps_ahead] + [i + n_scans*steps_ahead for i in range(0,remains)]\n                yl = yl + [-.5]*remains + [-.5] + [0]*remains\n                dl = dl + [1]*remains + [0] + [0]*remains\n                cl = cl + [0]*remains + [0] + [1]*remains\n                dwell_list = dwell_list + [pdd]*remains + [int(drop_to_det_time - well_move_time*2*(remains-1) - pdd*remains)] + [pdd]*remains\n        self.scan_and_cleanup(xl, yl, dwell_list, dl, cl, enc_loc, expose_to_beam=expose_to_beam, transition_before=transition_before, transition_after=transition_after, detector_status=detector_status, control_detector = control_detector)\n\n    def neighbourhood_scan_hare(self, neighbourhood, drop_to_det_time, droplet_offset_value = 0, acquisition_time = 10, post_drop_dwell_min_time = 10, location_offset_x = 0.0, location_offset_y = 0.0, refocus = False, recenter = True, expose_to_beam=True, transition_before=True, transition_after=True, control_detector = True):\n        ''' drop_to_det_time = pump-probe-delay'''\n        pattern = re.compile(\"^([A-H][1-8])$\")\n        if not pattern.match(neighbourhood):\n            print(f\"Hare scan requires input of form ex. A1, got {neighbourhood}.\")\n            return(False)\n        if control_detector:\n            detector_status = self.configure_detector(neighbourhood, 400, acquisition_time = acquisition_time/1000)\n        else:\n            detector_status = None\n        enc_loc = yield from self.pre_scan_setup(neighbourhood+\"aa\", 400, acquisition_time = acquisition_time, refocus = refocus, recenter = recenter, expose_to_beam=expose_to_beam, transition_before=transition_before)\n        well_move_time, steps_ahead, pdd = yield from self.calculate_hare(drop_to_det_time, droplet_offset_value = droplet_offset_value, acquisition_time = acquisition_time, post_drop_dwell_min_time = post_drop_dwell_min_time)\n        n_scans, remains = divmod(20, steps_ahead)\n        xl = []\n        yl = []\n        dl = []\n        cl = []\n        dwell_list = []\n        if steps_ahead == 1:\n            for y in range(20):\n                for n in range(20):\n                    xl = xl + [-.5 + n] + [n]\n                    yl = yl + [y] + [y]\n                    dl = dl + [1] + [0]\n                    cl = cl + [0] + [1]\n                    dwell_list = dwell_list + [pdd] + [pdd]\n        else:\n            for y in range(20):\n                for n in range(n_scans):\n                    xl = xl + [i-.5 + n*steps_ahead for i in range(0,steps_ahead)] + [n*steps_ahead] + [i + n*steps_ahead for i in range(0,steps_ahead)]\n                    yl = yl + [y-.5]*steps_ahead + [y-.5] + [y]*steps_ahead\n                    dl = dl + [1]*steps_ahead + [0] + [0]*steps_ahead\n                    cl = cl + [0]*steps_ahead + [0] + [1]*steps_ahead\n                    dwell_list = dwell_list + [pdd]*steps_ahead + [0] + [pdd]*steps_ahead\n                if remains != 0:\n                    xl = xl + [i-.5 + n_scans*steps_ahead for i in range(0,remains)] + [n_scans*steps_ahead] + [i + n_scans*steps_ahead for i in range(0,remains)]\n                    yl = yl + [y-.5]*remains + [y-.5] + [y]*remains\n                    dl = dl + [1]*remains + [0] + [0]*remains\n                    cl = cl + [0]*remains + [0] + [1]*remains\n                    dwell_list = dwell_list + [pdd]*remains + [int(drop_to_det_time - well_move_time*2*(remains-1) - pdd*remains)] + [pdd]*remains\n        self.scan_and_cleanup(xl, yl, dwell_list, dl, cl, enc_loc, expose_to_beam=expose_to_beam, transition_before=transition_before, transition_after=transition_after, detector_status=detector_status, control_detector = control_detector)\n\n    def multi_line_hare(self, neighbourhood, num_lines, droplet_offset_value = 0, acquisition_time = 10, post_drop_dwell_min_time = 10, location_offset_x = 0.0, location_offset_y = 0.0, refocus = False, recenter = True, expose_to_beam=True, transition_before=True, transition_after=True, control_detector = True):\n        ''' drop_to_det_time = pump-probe-delay'''\n        pattern = re.compile(\"^([A-H][1-8])$\")\n        if not pattern.match(neighbourhood):\n            print(f\"Hare scan requires input of form ex. A1, got {neighbourhood}.\")\n            return(False)\n        if control_detector:\n            detector_status = self.configure_detector(neighbourhood, 400, acquisition_time = acquisition_time/1000)\n        else:\n            detector_status = None\n        enc_loc = yield from self.pre_scan_setup(neighbourhood+\"aa\", 400, acquisition_time = acquisition_time, refocus = refocus, recenter = recenter, expose_to_beam=expose_to_beam, transition_before=transition_before)\n        # well_move_time, steps_ahead, pdd = yield from self.calculate_hare(drop_to_det_time, droplet_offset_value = droplet_offset_value, acquisition_time = acquisition_time, post_drop_dwell_min_time = post_drop_dwell_min_time)\n        xl = []\n        yl = []\n        dl = []\n        cl = []\n        dwell_list = []\n        for y in range(20//num_lines):\n            xl = xl + ([i - .5 for i in range(0,20)])*num_lines + [0] + [i for i in range(0,20)]*num_lines\n            for i in range(num_lines):\n                yl = yl + [y*num_lines + i - .5]*20\n            yl = yl + [y*num_lines]\n            for i in range(num_lines):\n                yl = yl + [y*num_lines + i]*20\n            dl = dl + [1]*20*num_lines + [0]*20*num_lines + [0]\n            cl = cl + [0]*20*num_lines + [0] + [1]*20*num_lines\n            dwell_list = dwell_list + [post_drop_dwell_min_time]*40*num_lines + [0]\n        \n        self.scan_and_cleanup(xl, yl, dwell_list, dl, cl, enc_loc, expose_to_beam=expose_to_beam, transition_before=transition_before, transition_after=transition_after, detector_status=detector_status, control_detector = control_detector)\n        \n    def configure_zebra_for_hare(self):\n        epics.caput(\"XF:17IDC-ES:FMX{Zeb:3}:OUT1_TTL\", 7)\n        epics.caput(\"XF:17IDC-ES:FMX{Zeb:3}:OUT3_TTL\", 10)\n\n    def check_camera_settings(self, camera):\n        if camera.cam.acquire_time.get() > 0.1:\n            print(f'{camera} acquireTime > 0.1, which could affect processing. Please reduce this to continue.')\n            return(False)\n        if camera.cam.image_mode.get() != 2:\n            print(f'{camera} not in continuous acquisition mode, please set this and retry.')\n            return(False)\n        if camera.cam.detector_state.get() != 1:\n            print(f'{camera} not acquiring, please start and retry.')\n            return(False)\n        return(True)\n\n    def multi_scan(self, domains, filename, drop_to_det_time, droplet_offset_value = 0, acquisition_time = 10, post_drop_dwell_min_time = 10, location_offset_x = 0.0, location_offset_y = 0.0, refocus = False, recenter = True, expose_to_beam=True, is_hare = True):\n        images = 0\n        for domain in domains:\n            if len(domain) == 2:\n                pattern = re.compile(\"^([A-H][1-8])$\")\n                if not pattern.match(domain):\n                    print(f\"Rejected location {domain}, neighbourhoods must match [A-H][1-8].\")\n                    return(False)\n                images = images + 400\n            elif len(domain) == 3:\n                pattern = re.compile(\"^([A-H][1-8][a-t])$\")\n                if not pattern.match(domain):\n                    print(f\"Rejected location {domain}, lines must match [A-H][1-8][a-t].\")\n                    return(False)\n                images = images + 20\n            else:\n                print(f\"Rejected location {domain}, values must be strings of length two or three.\")\n                return(False)\n        detector_status = self.configure_detector(filename, images, acquisition_time = acquisition_time/1000)\n        detector_status.wait(10)\n        for i, domain in enumerate(domains):\n            if len(domain) == 2:\n                scan_type = \"neighbourhood_scan\"\n            else:\n                scan_type = \"line_scan\"\n            if is_hare:\n                scan_type = scan_type + \"_hare\"\n            scan = getattr(self, scan_type)\n            if i == 0:\n                yield from scan(domain, drop_to_det_time, droplet_offset_value = droplet_offset_value, acquisition_time = acquisition_time, post_drop_dwell_min_time = post_drop_dwell_min_time, location_offset_x = location_offset_x, location_offset_y = location_offset_y, expose_to_beam = expose_to_beam, recenter = recenter, refocus = refocus, transition_before=True, transition_after=False, control_detector = False)\n            elif i < len(domains) - 1:\n                yield from scan(domain, drop_to_det_time, droplet_offset_value = droplet_offset_value, acquisition_time = acquisition_time, post_drop_dwell_min_time = post_drop_dwell_min_time, location_offset_x = location_offset_x, location_offset_y = location_offset_y, expose_to_beam = expose_to_beam, recenter = False, refocus = False, transition_before=False, transition_after=False, control_detector = False)\n            else:\n                yield from scan(domain, drop_to_det_time, droplet_offset_value = droplet_offset_value, acquisition_time = acquisition_time, post_drop_dwell_min_time = post_drop_dwell_min_time, location_offset_x = location_offset_x, location_offset_y = location_offset_y, expose_to_beam = expose_to_beam, recenter = False, refocus = False, transition_before=False, transition_after=True, control_detector = False)\n        time.sleep(5)\n        eiger_single.cam.acquire.put(0)"
  },
  {
    "class_name": "YMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class YMotor(Device):\n\ty = Cpt(EpicsMotor, '-Ax:Y}Mtr', labels=['fmx'])"
  },
  {
    "class_name": "XYMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class XYMotor(Device):\n\tx = Cpt(EpicsMotor, '-Ax:X}Mtr', labels=['fmx'])\n\ty = Cpt(EpicsMotor, '-Ax:Y}Mtr', labels=['fmx'])"
  },
  {
    "class_name": "XZXYMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class XZXYMotor(Device):\n\tx = Cpt(EpicsMotor, '-Ax:X}Mtr', labels=['fmx'])\n\tz = Cpt(EpicsMotor, '-Ax:Z}Mtr', labels=['fmx'])"
  },
  {
    "class_name": "XYZfMotor",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class XYZfMotor(Device):\n\tx = Cpt(EpicsMotor, '-Ax:Xf}Mtr')\n\ty = Cpt(EpicsMotor, '-Ax:Yf}Mtr')\n\tz = Cpt(EpicsMotor, '-Ax:Zf}Mtr')"
  },
  {
    "class_name": "Slits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class Slits(Device):\n\tb = Cpt(EpicsMotor, '-Ax:B}Mtr', labels=['fmx'])\n\ti = Cpt(EpicsMotor, '-Ax:I}Mtr', labels=['fmx'])\n\to = Cpt(EpicsMotor, '-Ax:O}Mtr', labels=['fmx'])\n\tt = Cpt(EpicsMotor, '-Ax:T}Mtr', labels=['fmx'])\n\tx_ctr = Cpt(EpicsMotor, '-Ax:XCtr}Mtr', labels=['fmx'])\n\tx_gap = Cpt(EpicsMotor, '-Ax:XGap}Mtr', labels=['fmx'])\n\ty_ctr = Cpt(EpicsMotor, '-Ax:YCtr}Mtr', labels=['fmx'])\n\ty_gap = Cpt(EpicsMotor, '-Ax:YGap}Mtr', labels=['fmx'])"
  },
  {
    "class_name": "HorizontalDCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class HorizontalDCM(Device):\n\tb = Cpt(EpicsMotor, '-Ax:B}Mtr', labels=['fmx'])\n\tg = Cpt(EpicsMotor, '-Ax:G}Mtr', labels=['fmx'])\n\tp = Cpt(EpicsMotor, '-Ax:P}Mtr', labels=['fmx'])\n\tr = Cpt(EpicsMotor, '-Ax:R}Mtr', labels=['fmx'])\n\te = Cpt(EpicsMotor, '-Ax:E}Mtr', labels=['fmx'])"
  },
  {
    "class_name": "VerticalDCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class VerticalDCM(Device):\n    b = Cpt(EpicsMotor, '-Ax:B}Mtr')\n    g = Cpt(EpicsMotor, '-Ax:G}Mtr')\n    p = Cpt(EpicsMotor, '-Ax:P}Mtr')\n    r = Cpt(EpicsMotor, '-Ax:R}Mtr')\n    e = Cpt(EpicsMotor, '-Ax:E}Mtr')\n    w = Cpt(EpicsMotor, '-Ax:W}Mtr')"
  },
  {
    "class_name": "Cover",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class Cover(Device):\n    close = Cpt(EpicsSignal, 'Cmd:Cls-Cmd')\n    open = Cpt(EpicsSignal, 'Cmd:Opn-Cmd')\n    status = Cpt(EpicsSignalRO, 'Pos-Sts')"
  },
  {
    "class_name": "Shutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class Shutter(Device):\n    close = Cpt(EpicsSignal, 'Cmd:Cls-Cmd.PROC')\n    open = Cpt(EpicsSignal, 'Cmd:Opn-Cmd.PROC')\n    status = Cpt(EpicsSignalRO, 'Pos-Sts')"
  },
  {
    "class_name": "ShutterTranslation",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class ShutterTranslation(Device):\n\tx = Cpt(EpicsMotor, '-Ax:X}Mtr')"
  },
  {
    "class_name": "GoniometerStack",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class GoniometerStack(Device):\n\tgx = Cpt(EpicsMotor, '-Ax:GX}Mtr', labels=['fmx'])\n\tgy = Cpt(EpicsMotor, '-Ax:GY}Mtr', labels=['fmx'])\n\tgz = Cpt(EpicsMotor, '-Ax:GZ}Mtr', labels=['fmx'])\n\to  = Cpt(EpicsMotor, '-Ax:O}Mtr', labels=['fmx'])\n\tpy = Cpt(EpicsMotor, '-Ax:PY}Mtr', labels=['fmx'])\n\tpz = Cpt(EpicsMotor, '-Ax:PZ}Mtr', labels=['fmx'])"
  },
  {
    "class_name": "BeamStop",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class BeamStop(Device):\n\tfx = Cpt(EpicsMotor, '-Ax:FX}Mtr', labels=['fmx'])\n\tfy = Cpt(EpicsMotor, '-Ax:FY}Mtr', labels=['fmx'])"
  },
  {
    "class_name": "Annealer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_00_lsdc.py",
    "source": "class Annealer(Device):\n    air = Cpt(EpicsSignal, '1}AnnealerAir-Sel')\n    inStatus = Cpt(EpicsSignalRO, '2}AnnealerIn-Sts') # status: 0 (Not In), 1 (In)\n    outStatus = Cpt(EpicsSignalRO, '2}AnnealerOut-Sts')"
  },
  {
    "class_name": "EpicsSignalPrec",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/09-machine_99.py",
    "source": "class EpicsSignalPrec(EpicsSignal):\n    @property\n    def precision(self):\n        return 4"
  },
  {
    "class_name": "EpicsSignalROPrec",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/09-machine_99.py",
    "source": "class EpicsSignalROPrec(EpicsSignal):\n    @property\n    def precision(self):\n        return 4"
  },
  {
    "class_name": "Xbpm",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/21-bpm_00_lsdc.py",
    "source": "class Xbpm(Device):\n    x = Cpt(EpicsSignalRO, 'Pos:X-I')\n    y = Cpt(EpicsSignalRO, 'Pos:Y-I')\n    a = Cpt(EpicsSignalRO, 'Ampl:ACurrAvg-I')\n    b = Cpt(EpicsSignalRO, 'Ampl:BCurrAvg-I')\n    c = Cpt(EpicsSignalRO, 'Ampl:CCurrAvg-I')\n    d = Cpt(EpicsSignalRO, 'Ampl:DCurrAvg-I')\n    total = Cpt(EpicsSignalRO, 'Ampl:CurrTotal-I')"
  },
  {
    "class_name": "Bpm",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/21-bpm_00_lsdc.py",
    "source": "class Bpm(Device):\n    x = Cpt(EpicsSignalRO, 'PosX:MeanValue_RBV')\n    y = Cpt(EpicsSignalRO, 'PosY:MeanValue_RBV')\n    a = Cpt(EpicsSignalRO, 'Current1:MeanValue_RBV')\n    b = Cpt(EpicsSignalRO, 'Current2:MeanValue_RBV')\n    c = Cpt(EpicsSignalRO, 'Current3:MeanValue_RBV')\n    d = Cpt(EpicsSignalRO, 'Current4:MeanValue_RBV')\n    sum_x = Cpt(EpicsSignalRO, 'SumX:MeanValue_RBV')\n    sum_y = Cpt(EpicsSignalRO, 'SumY:MeanValue_RBV')\n    sum_all = Cpt(EpicsSignalRO, 'SumAll:MeanValue_RBV')"
  },
  {
    "class_name": "ZebraSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraSignalWithRBV(EpicsSignal):\n    # An EPICS signal that uses the Zebra convention of 'pvname' being the\n    # setpoint and 'pvname:RBV' being the read-back\n\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix + ':RBV', write_pv=prefix, **kwargs)"
  },
  {
    "class_name": "ZebraPulse",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraPulse(Device):\n    width = Cpt(ZebraSignalWithRBV, 'WID')\n    input_addr = Cpt(ZebraSignalWithRBV, 'INP')\n    input_str = Cpt(EpicsSignalRO, 'INP:STR', string=True)\n    input_status = Cpt(EpicsSignalRO, 'INP:STA')\n    delay = Cpt(ZebraSignalWithRBV, 'DLY')\n    delay_sync = Cpt(EpicsSignal, 'DLY:SYNC')\n    time_units = Cpt(ZebraSignalWithRBV, 'PRE', string=True)\n    output = Cpt(EpicsSignal, 'OUT')\n\n    input_edge = FC(EpicsSignal,\n                    '{self._zebra_prefix}POLARITY:{self._edge_addr}')\n\n    _edge_addrs = {1: 'BC',\n                   2: 'BD',\n                   3: 'BE',\n                   4: 'BF',\n                   }\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['input_status', 'output']\n        if configuration_attrs is None:\n            configuration_attrs = list(self.component_names) + ['input_edge']\n\n        zebra = parent\n        self.index = index\n        self._zebra_prefix = zebra.prefix\n        self._edge_addr = self._edge_addrs[index]\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, parent=parent, **kwargs)"
  },
  {
    "class_name": "ZebraOutputBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraOutputBase(Device):\n    '''The base of all zebra outputs (1~8)\n\n        Front outputs\n        # TTL  LVDS  NIM  PECL  OC  ENC\n        1  o    o     o\n        2  o    o     o\n        3  o    o               o\n        4  o          o    o\n\n        Rear outputs\n        # TTL  LVDS  NIM  PECL  OC  ENC\n        5                            o\n        6                            o\n        7                            o\n        8                            o\n\n    '''\n    def __init__(self, prefix, *, index=None, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        self.index = index\n\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = list(self.component_names)  # _get_configuration_attrs(self.__class__)\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraOutputType",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraOutputType(Device):\n    '''Shared by all output types (ttl, lvds, nim, pecl, out)'''\n    addr = Cpt(ZebraSignalWithRBV, '')\n    status = Cpt(EpicsSignalRO, ':STA')\n    string = Cpt(EpicsSignalRO, ':STR', string=True)\n    sync = Cpt(EpicsSignal, ':SYNC')\n    write_output = Cpt(EpicsSignal, ':SET')\n\n    def __init__(self, prefix, *, read_attrs=None, configuration_attrs=None,\n                 **kwargs):\n        if read_attrs is None:\n            read_attrs = ['status']\n        if configuration_attrs is None:\n            configuration_attrs = ['addr']\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraEncoder",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraEncoder(Device):\n    motor_pos = FC(EpicsSignalRO, '{self._zebra_prefix}M{self.index}:RBV')\n    zebra_pos = FC(EpicsSignal, '{self._zebra_prefix}POS{self.index}_SET')\n    encoder_res = FC(EpicsSignal, '{self._zebra_prefix}M{self.index}:MRES')\n    encoder_off = FC(EpicsSignal, '{self._zebra_prefix}M{self.index}:OFF')\n    _copy_pos_signal = FC(EpicsSignal, '{self._zebra_prefix}M{self.index}:SETPOS.PROC')\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = ['encoder_res', 'encoder_off']\n\n        self.index = index\n        self._zebra_prefix = parent.prefix\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         parent=parent, **kwargs)\n\n    def copy_position(self):\n        self._copy_pos_signal.put(1, wait=True)"
  },
  {
    "class_name": "ZebraGateInput",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraGateInput(Device):\n    addr = Cpt(ZebraSignalWithRBV, '')\n    string = Cpt(EpicsSignalRO, ':STR', string=True)\n    status = Cpt(EpicsSignalRO, ':STA')\n    sync = Cpt(EpicsSignal, ':SYNC')\n    write_input = Cpt(EpicsSignal, ':SET')\n\n    # Input edge index depends on the gate number (these are set in __init__)\n    edge = FC(EpicsSignal,\n              '{self._zebra_prefix}POLARITY:B{self._input_edge_idx}')\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['status']\n        if configuration_attrs is None:\n            configuration_attrs = ['addr', 'edge']\n\n        gate = parent\n        zebra = gate.parent\n\n        self.index = index\n        self._zebra_prefix = zebra.prefix\n        self._input_edge_idx = gate._input_edge_idx[self.index]\n\n        super().__init__(prefix, read_attrs=read_attrs,\n                         configuration_attrs=configuration_attrs,\n                         parent=parent, **kwargs)"
  },
  {
    "class_name": "ZebraGate",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraGate(Device):\n    input1 = Cpt(ZebraGateInput, 'INP1', index=1)\n    input2 = Cpt(ZebraGateInput, 'INP2', index=2)\n    output = Cpt(EpicsSignal, 'OUT')\n\n    def __init__(self, prefix, *, index=None, read_attrs=None,\n                 configuration_attrs=None, **kwargs):\n        self.index = index\n        self._input_edge_idx = {1: index - 1,\n                                2: 4 + index - 1\n                                }\n\n        if read_attrs is None:\n            read_attrs = ['output']\n        if configuration_attrs is None:\n            configuration_attrs = ['input1', 'input2']\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n\n    def set_input_edges(self, edge1, edge2):\n        set_and_wait(self.input1.edge, int(edge1))\n        set_and_wait(self.input2.edge, int(edge2))"
  },
  {
    "class_name": "ZebraPositionCaptureDeviceBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraPositionCaptureDeviceBase(Device):\n    source = Cpt(ZebraSignalWithRBV, 'SEL', put_complete=True)\n    input_addr = Cpt(ZebraSignalWithRBV, 'INP')\n    input_str = Cpt(EpicsSignalRO, 'INP:STR', string=True)\n    input_status = Cpt(EpicsSignalRO, 'INP:STA', auto_monitor=True)\n    output = Cpt(EpicsSignalRO, 'OUT', auto_monitor=True)\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n\n        if read_attrs is None:\n            read_attrs = []\n        read_attrs += ['input_status', 'output']\n\n        if configuration_attrs is None:\n            configuration_attrs = []\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraPositionCaptureData",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraPositionCaptureData(Device):\n    num_captured = Cpt(EpicsSignalRO, 'NUM_CAP')\n    num_downloaded = Cpt(EpicsSignalRO, 'NUM_DOWN')\n\n    time = Cpt(EpicsSignalRO, 'TIME')\n\n    enc1 = Cpt(EpicsSignalRO, 'ENC1')\n    enc2 = Cpt(EpicsSignalRO, 'ENC2')\n    enc3 = Cpt(EpicsSignalRO, 'ENC3')\n    enc4 = Cpt(EpicsSignalRO, 'ENC4')\n\n    sys1 = Cpt(EpicsSignalRO, 'SYS1')\n    sys2 = Cpt(EpicsSignalRO, 'SYS2')\n\n    div1 = Cpt(EpicsSignalRO, 'DIV1')\n    div2 = Cpt(EpicsSignalRO, 'DIV2')\n    div3 = Cpt(EpicsSignalRO, 'DIV3')\n    div4 = Cpt(EpicsSignalRO, 'DIV4')\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n\n        if read_attrs is None:\n            read_attrs = list(self.component_names)  # _get_configuration_attrs(self.__class__, signal_class=EpicsSignalRO)\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraPositionCapture",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraPositionCapture(Device):\n    source = Cpt(ZebraSignalWithRBV, 'ENC')\n    direction = Cpt(ZebraSignalWithRBV, 'DIR')\n    time_units = Cpt(ZebraSignalWithRBV, 'TSPRE')\n\n    arm = Cpt(ZebraPositionCaptureArm, 'ARM_')\n    gate = Cpt(ZebraPositionCaptureGate, 'GATE_')\n    pulse = Cpt(ZebraPositionCapturePulse, 'PULSE_')\n\n    capture_enc1 = Cpt(EpicsSignal, 'BIT_CAP:B0')\n    capture_enc2 = Cpt(EpicsSignal, 'BIT_CAP:B1')\n    capture_enc3 = Cpt(EpicsSignal, 'BIT_CAP:B2')\n    capture_enc4 = Cpt(EpicsSignal, 'BIT_CAP:B3')\n\n    capture_sys1 = Cpt(EpicsSignal, 'BIT_CAP:B4')\n    capture_sys2 = Cpt(EpicsSignal, 'BIT_CAP:B5')\n\n    capture_div1 = Cpt(EpicsSignal, 'BIT_CAP:B6')\n    capture_div2 = Cpt(EpicsSignal, 'BIT_CAP:B7')\n    capture_div3 = Cpt(EpicsSignal, 'BIT_CAP:B8')\n    capture_div4 = Cpt(EpicsSignal, 'BIT_CAP:B9')\n\n    data = Cpt(ZebraPositionCaptureData, '')\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n\n        if read_attrs is None:\n            read_attrs = ['data']\n        if configuration_attrs is None:\n            configuration_attrs = (\n                ['source', 'direction', 'time_units',\n                 'arm', 'gate', 'pulse'] +\n                [f'capture_enc{i}' for i in range(1,5)] +\n                [f'capture_sys{i}' for i in range(1,3)] +\n                [f'capture_div{i}' for i in range(1,5)]\n            )\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)"
  },
  {
    "class_name": "ZebraBase",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraBase(Device):\n    soft_input1 = Cpt(EpicsSignal, 'SOFT_IN:B0')\n    soft_input2 = Cpt(EpicsSignal, 'SOFT_IN:B1')\n    soft_input3 = Cpt(EpicsSignal, 'SOFT_IN:B2')\n    soft_input4 = Cpt(EpicsSignal, 'SOFT_IN:B3')\n\n    pulse1 = Cpt(ZebraPulse, 'PULSE1_', index=1)\n    pulse2 = Cpt(ZebraPulse, 'PULSE2_', index=2)\n    pulse3 = Cpt(ZebraPulse, 'PULSE3_', index=3)\n    pulse4 = Cpt(ZebraPulse, 'PULSE4_', index=4)\n\n    output1 = Cpt(ZebraFrontOutput12, 'OUT1_', index=1)\n    output2 = Cpt(ZebraFrontOutput12, 'OUT2_', index=2)\n    output3 = Cpt(ZebraFrontOutput3, 'OUT3_', index=3)\n    output4 = Cpt(ZebraFrontOutput4, 'OUT4_', index=4)\n\n    output5 = Cpt(ZebraRearOutput, 'OUT5_', index=5)\n    output6 = Cpt(ZebraRearOutput, 'OUT6_', index=6)\n    output7 = Cpt(ZebraRearOutput, 'OUT7_', index=7)\n    output8 = Cpt(ZebraRearOutput, 'OUT8_', index=8)\n\n    gate1 = Cpt(ZebraGate, 'GATE1_', index=1)\n    gate2 = Cpt(ZebraGate, 'GATE2_', index=2)\n    gate3 = Cpt(ZebraGate, 'GATE3_', index=3)\n    gate4 = Cpt(ZebraGate, 'GATE4_', index=4)\n\n    encoder1 = Cpt(ZebraEncoder, '', index=1)\n    encoder2 = Cpt(ZebraEncoder, '', index=2)\n    encoder3 = Cpt(ZebraEncoder, '', index=3)\n    encoder4 = Cpt(ZebraEncoder, '', index=4)\n\n    pos_capt = Cpt(ZebraPositionCapture, 'PC_')\n    download_status = Cpt(EpicsSignalRO, 'ARRAY_ACQ')\n    reset = Cpt(EpicsSignal, 'SYS_RESET.PROC')\n\n    addresses = ZebraAddresses\n\n    def __init__(self, prefix, *, configuration_attrs=None, read_attrs=None,\n                 **kwargs):\n        if read_attrs is None:\n            read_attrs = []\n        if configuration_attrs is None:\n            configuration_attrs = (\n                [f'soft_input{i}' for i in range(1,5)] +\n                [f'pulse{i}' for i in range(1,5)] +\n                [f'output{i}' for i in range(1,9)] +\n                [f'gate{i}' for i in range(1,5)] +\n                [f'encoder{i}' for i in range(1,5)] +\n                ['pos_capt']\n            )\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, **kwargs)\n\n        self.pulse = dict(self._get_indexed_devices(ZebraPulse))\n        self.output = dict(self._get_indexed_devices(ZebraOutputBase))\n        self.gate = dict(self._get_indexed_devices(ZebraGate))\n        self.encoder = dict(self._get_indexed_devices(ZebraEncoder))\n\n    def _get_indexed_devices(self, cls):\n        for attr in self._sub_devices:\n            dev = getattr(self, attr)\n            if isinstance(dev, cls):\n                yield dev.index, dev\n\n    def trigger(self):\n        # Re-implement this to trigger as desired in bluesky\n        status = DeviceStatus(self)\n        status._finished()\n        return status"
  },
  {
    "class_name": "ZebraArmSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraArmSignalWithRBV(EpicsSignal):\n        def __init__(self, prefix, **kwargs):\n            super().__init__(prefix + 'ARM_OUT', write_pv=prefix+'ARM', **kwargs)"
  },
  {
    "class_name": "ZebraDisarmSignalWithRBV",
    "bases": [
      "EpicsSignal"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/26-zebra.py",
    "source": "class ZebraDisarmSignalWithRBV(EpicsSignal):\n        def __init__(self, prefix, **kwargs):\n            super().__init__(prefix + 'ARM_OUT', write_pv=prefix+'DISARM', **kwargs)"
  },
  {
    "class_name": "InsertionDevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/09-machine_00_lsdc.py",
    "source": "class InsertionDevice(Device):\n    gap = Cpt(EpicsMotor, '-Ax:Gap}-Mtr',\n              kind='hinted', name='')\n    brake = Cpt(EpicsSignal, '}BrakesDisengaged-Sts',\n                write_pv='}BrakesDisengaged-SP',\n                kind='omitted', add_prefix=('read_pv', 'write_pv', 'suffix'))\n\n    def set(self, *args, **kwargs):\n        set_and_wait(self.brake, 1)\n        return self.gap.set(*args, **kwargs)\n\n    def stop(self, *, success=False):\n        return self.gap.stop(success=success)"
  },
  {
    "class_name": "PhotonLocalFeedback",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/09-machine_00_lsdc.py",
    "source": "class PhotonLocalFeedback(Device):\n    x_enable = Cpt(EpicsSignal, 'X-FdbkEnabled')\n    y_enable = Cpt(EpicsSignal, 'Y-FdbkEnabled')"
  },
  {
    "class_name": "BeamlineCalibrations",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/90-utility_00_lsdc.py",
    "source": "class BeamlineCalibrations(Device):\n    LoMagCal = Cpt(EpicsSignal, 'LoMagCal}')\n    HiMagCal = Cpt(EpicsSignal, 'HiMagCal}')"
  },
  {
    "class_name": "PuckSafety",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/90-utility_00_lsdc.py",
    "source": "class PuckSafety(Device):\n    On = Cpt(EpicsSignal, 'On.PROC')\n    Off = Cpt(EpicsSignal, 'Off.PROC')"
  },
  {
    "class_name": "FESlits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_99.py",
    "source": "class FESlits(Device):\n\ti = Cpt(EpicsMotor, '{Slt:3-Ax:I}Mtr')\n\tt = Cpt(EpicsMotor, '{Slt:3-Ax:T}Mtr')\n\to = Cpt(EpicsMotor, '{Slt:4-Ax:O}Mtr')\n\tb = Cpt(EpicsMotor, '{Slt:4-Ax:B}Mtr')\n\tx_ctr = Cpt(VirtualCenter, '{Slt:34-Ax:X}')\n\ty_ctr = Cpt(VirtualCenter, '{Slt:34-Ax:Y}')\n\tx_gap = Cpt(VirtualGap,    '{Slt:34-Ax:X}')\n\ty_gap = Cpt(VirtualGap,    '{Slt:34-Ax:Y}')"
  },
  {
    "class_name": "KBMirror",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/10-motors_99.py",
    "source": "class KBMirror(Device):\n\thp = Cpt(EpicsMotor, ':KBH-Ax:P}Mtr')\n\thr = Cpt(EpicsMotor, ':KBH-Ax:R}Mtr')\n\thx = Cpt(EpicsMotor, ':KBH-Ax:X}Mtr')\n\thy = Cpt(EpicsMotor, ':KBH-Ax:Y}Mtr')\n\tvp = Cpt(EpicsMotor, ':KBV-Ax:P}Mtr')\n\tvx = Cpt(EpicsMotor, ':KBV-Ax:X}Mtr')\n\tvy = Cpt(EpicsMotor, ':KBV-Ax:Y}Mtr')"
  },
  {
    "class_name": "CustomFlyer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/95-custom_plans.py",
    "source": "class CustomFlyer(Device):\n        def __init__(self, *args, **kwargs):\n            self._last_point = 0\n            self._collection_ts = None\n\n            self._ts = zebra.pos_capt.data.time\n            self._centroid_x = stats.ts_centroid.x\n            self._centroid_y = stats.ts_centroid.y\n            self._enc = getattr(zebra.pos_capt.data, f'enc{encoder_idx+1}')\n\n            self._data_sources = (self._centroid_x, self._centroid_y, self._enc)\n\n            super().__init__(*args, **kwargs)\n\n        def kickoff(self):\n            self._collection_ts = time.time()\n            return zebra.kickoff()\n\n        def complete(self):\n            return zebra.complete()\n\n        def collect(self):\n            data = {\n                sig: sig.get(use_monitor=False) for sig in self._data_sources\n            }\n\n            timestamps = self._ts.get(use_monitor=False) + self._collection_ts\n\n            min_len = min([len(d) for d in data.values()])\n            cur_time = time.time()\n\n            for i in range(self._last_point, min_len):\n                yield {\n                    'data': { sig.name: data[sig][i] for sig in data },\n                    'timestamps': { sig.name: timestamps[i] for sig in data },\n                    'time': cur_time\n                }\n\n            self._last_point = min_len\n\n        def describe_collect(self):\n            return {\n                'primary': {\n                    sig.name: {\n                        'source': 'PV:' + sig.pvname,\n                        'shape': [],\n                        'dtype': 'number'\n                    } for sig in self._data_sources\n                }\n            }"
  },
  {
    "class_name": "Channel",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/11-bimorph.py",
    "source": "class Channel(Device):\n    '''Bimorph Channel'''\n    user_setpoint = C(EpicsSignal, '_SP.VAL')\n    target_voltage = C(EpicsSignalRO, '_TARGET_MON.VAL')\n    current_voltage = C(EpicsSignalRO, '_CURRENT_MON.VAL')\n    min_voltage = C(EpicsSignalRO, '_MINV_MON.VAL')\n    max_voltage = C(EpicsSignalRO, '_MINV_MON.VAL')"
  },
  {
    "class_name": "Bimorph",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/11-bimorph.py",
    "source": "class Bimorph(Device):\n    '''Bimorph HV Power Source'''\n\n    bank_no = C(EpicsSignal, ':BANK_NO_32.VAL')\n    step_size = C(EpicsSignal, ':U_STEP.VAL')\n    inc_bank = C(EpicsSignal, ':INCR_U_BANK_CMD.PROC')\n    dec_bank = C(EpicsSignal, ':DECR_U_BANK_CMD.PROC')\n    inc = C(EpicsSignal, ':INCR_U_CMD.A')\n    dec = C(EpicsSignal, ':DECR_U_CMD.A')\n    stop_ramp = C(EpicsSignal, ':STOP_RAMPS_BANK.PROC')\n    start_ramp = C(EpicsSignal, ':START_RAMPS_CMD.PROC')\n\n    format_number = C(EpicsSignal, ':FORMAT_NO_SP.VAL')\n    load_format = C(EpicsSignal, ':FORMAT_ACTIVE_SP.PROC')\n\n    all_target_voltages = C(EpicsSignalRO, ':U_ALL_TARGET_MON.VAL')\n    all_current_voltages = C(EpicsSignalRO, ':U_ALL_CURRENT_MON.VAL')\n\n    unit_status = C(EpicsSignalRO, ':UNIT_STATUS_MON.A')\n\n    channels = DDC(add_channels(range(0, 32)))\n\n    def step(self, bank, size, direction, start=False, wait=False):\n        self.bank_no.put(bank)\n        self.step_size.put(size)\n\n        if(direction == \"inc\"):\n            self.inc_bank.put(1)\n        else:\n            self.dec_bank.put(1)\n\n        if(start):\n            self.start()\n\n        if(wait):\n            self.wait()\n\n    def increment_bank(self, bank, size, start=False, wait=False):\n        ''' Increments the target voltage in `size` Volts in the specified `bank`\n\n        Parameters:\n        -----------\n        bank : int\n            The number of the bank to be incremented\n        size : float\n            The amount of Volts to increment from the bank target value\n        start : bool\n            Determines if the ramp must start right after the increment. Defaults to False.\n        wait : bool\n            Determines if the code must wait until the ramp process finishes. Defaults to False.\n        '''\n        self.step(bank, size, \"inc\", start)\n\n    def decrement_bank(self, bank, size, start=False, wait=False):\n        ''' Decrements the target voltage in `size` Volts in the specified `bank`\n\n        Parameters:\n        -----------\n        bank : int\n            The number of the bank to be decremented\n        size : float\n            The amount of Volts to decrement from the bank target value\n        start : bool\n            Determines if the ramp must start right after the decrement. Defaults to False.\n        wait : bool\n            Determines if the code must wait until the ramp process finishes. Defaults to False.\n        '''\n        self.step(bank, size, \"dec\", start)\n\n    def start(self):\n        ''' Start the Ramping process on all channels '''\n        self.start_ramp.put(1)\n\n    def stop(self):\n        ''' Stops the Ramping process on all channels '''\n        self.stop_ramp.put(1)\n\n    def is_ramping(self):\n        ''' Returns wether the power supply is ramping or not '''\n        return (int(self.unit_status.get()) >> 30) == 1\n\n    def is_interlock_ok(self):\n        ''' Returns the interlock state '''\n        st = int(self.unit_status.get())\n        return (st & 1) & ((st >> 1) & 1) == 1\n\n    def is_on(self):\n        ''' Returns wether the Channels are ON or OFF '''\n        return (int(self.unit_status.get()) >> 29) == 1          \n\n    def wait(self):\n        while self.is_ramping():\n            sleep(0.1)"
  },
  {
    "class_name": "Best",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/21-bpm_99.py",
    "source": "class Best(Device):\n    x_mean  = Cpt(EpicsSignal, 'PosX_Mean')\n    x_std = Cpt(EpicsSignal, 'PosX_Std')\n    y_mean  = Cpt(EpicsSignal, 'PosY_Mean')\n    y_std = Cpt(EpicsSignal, 'PosY_Std')\n    int_mean  = Cpt(EpicsSignal, 'Int_Mean')\n    int_std = Cpt(EpicsSignal, 'Int_Std')"
  },
  {
    "class_name": "Transmission",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/23-attenuator_crl_00_lsdc.py",
    "source": "class Transmission(Device):\n    energy = Cpt(EpicsSignal, 'Energy-SP') # PV only used for debugging. Attenuator uses Bragg axis energy\n    transmission = Cpt(EpicsSignal, 'Trans-SP')\n    set_trans = Cpt(EpicsSignal, 'Cmd:Set-Cmd.PROC')"
  },
  {
    "class_name": "AttenuatorLUT",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/23-attenuator_crl_00_lsdc.py",
    "source": "class AttenuatorLUT(Device):\n    done = Cpt(EpicsSignalRO, '}attenDone')"
  },
  {
    "class_name": "AttenuatorBCU",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/fmx-profile-collection/startup/23-attenuator_crl_00_lsdc.py",
    "source": "class AttenuatorBCU(Device):\n    a1 = Cpt(EpicsMotor, '-Ax:1}Mtr', labels=['fmx'])\n    a2 = Cpt(EpicsMotor, '-Ax:2}Mtr', labels=['fmx'])\n    a3 = Cpt(EpicsMotor, '-Ax:3}Mtr', labels=['fmx'])\n    a4 = Cpt(EpicsMotor, '-Ax:4}Mtr', labels=['fmx'])\n    done = Cpt(EpicsSignalRO, '}attenDone')"
  },
  {
    "class_name": "SampleTower",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hex-profile-collection/startup/03-motors.py",
    "source": "class SampleTower(Device):\n    \"\"\"\n    Ophyd objects for the sample-tower motors (<-> CSS names):\n    \"\"\"\n\n    # Define a list of objects corresponding to motors of the sample tower\n\n    axis_x1 = Cpt(EpicsMotorWithDescription, \"X1}Mtr\")\n    axis_z1 = Cpt(EpicsMotorWithDescription, \"Z1}Mtr\")\n    pitch = Cpt(EpicsMotorWithDescription, \"Rx}Mtr\")\n    vertical_y = Cpt(EpicsMotorWithDescription, \"Y}Mtr\")\n    roll = Cpt(EpicsMotorWithDescription, \"Rz}Mtr\")\n\n    x2 = Cpt(EpicsMotorWithDescription, \"X2}Mtr\")\n    z2 = Cpt(EpicsMotorWithDescription, \"Z2}Mtr\")\n\n    rx1 = Cpt(EpicsMotorWithDescription, \"Rx1}Mtr\")\n    ry1 = Cpt(EpicsMotorWithDescription, \"Ry1}Mtr\")\n    rz1 = Cpt(EpicsMotorWithDescription, \"Rz1}Mtr\")\n\n    def get_motor_list(self):\n        motor_list = []\n        for name in self.read_attrs:\n            if \".\" not in name:\n                motor_list.append(name)\n        return motor_list\n\n    def get_position(self, motor_name):\n        try:\n            motor = getattr(self, motor_name)\n            return motor.read()[motor.name][\"value\"]\n        except AttributeError:\n            return \"No such motor name: {}!\".format(motor_name)\n\n    def get_velocity(self, motor_name):\n        try:\n            motor = getattr(self, motor_name)\n            return motor.velocity.value\n        except AttributeError:\n            return \"No such motor name: {}!\".format(motor_name)\n\n    def get_acceleration(self, motor_name):\n        try:\n            motor = getattr(self, motor_name)\n            return motor.acceleration.value\n        except AttributeError:\n            return \"No such motor name: {}!\".format(motor_name)\n\n    def get_css_name(self, motor_name):\n        try:\n            motor = getattr(self, motor_name)\n            css_name = motor.desc.get()\n            return css_name\n        except AttributeError:\n            return \"No such motor name: {}!\".format(motor_name)"
  },
  {
    "class_name": "HEXMonochromator",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hex-profile-collection/startup/03-motors.py",
    "source": "class HEXMonochromator(Device):\n    xtal2_z = Cpt(EpicsMotor, \"Z2}Mtr\")"
  },
  {
    "class_name": "TomoRotaryStageHoming",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hex-profile-collection/startup/03-motors.py",
    "source": "class TomoRotaryStageHoming(Device):\n\n    home_cmd = Cpt(EpicsSignal, \"Start:Home-Cmd\")\n    home_status = Cpt(EpicsSignal, \"Sts:HomeCmplt-Sts\")\n\n    def set(self, value):\n        def wait_for_home_done(value, old_value, **kwargs):\n            print(f\"Current homing status: {value}, last homing status: {old_value}\")\n            if old_value != 1 and value == 1:\n                return True\n            else:\n                return False\n        \n        status = SubscriptionStatus(self.home_status, run=False, callback=wait_for_home_done)\n        self.home_cmd.put(value)\n        \n        return status"
  },
  {
    "class_name": "TomoRotaryStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hex-profile-collection/startup/03-motors.py",
    "source": "class TomoRotaryStage(Device):\n    rotary_axis = Cpt(EpicsMotorWithDescription, \"Ax:4}Mtr\")\n    home = Cpt(TomoRotaryStageHoming, \"Ax:4}\")"
  },
  {
    "class_name": "MotorValuesMCA1",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hex-profile-collection/startup/03-motors.py",
    "source": "class MotorValuesMCA1(Device):\n    fltr1u = Cpt(EpicsSignalRO, \"1{Fltr:1-Ax:Yu}Mtr.RBV\", kind=Kind.normal)\n    fltr1d = Cpt(EpicsSignalRO, \"1{Fltr:1-Ax:Yd}Mtr.RBV\", kind=Kind.normal)\n    fltr2 = Cpt(EpicsSignalRO, \"1{Fltr:2-Ax:Y}Mtr.RBV\", kind=Kind.normal)\n    fltr3 = Cpt(EpicsSignalRO, \"3{Fltr:3-Ax:Y}Mtr.RBV\", kind=Kind.normal)\n    sliti = Cpt(EpicsSignalRO, \"1{Slt:1-Ax:I}Mtr.RBV\", kind=Kind.normal)\n    slito = Cpt(EpicsSignalRO, \"1{Slt:1-Ax:O}Mtr.RBV\", kind=Kind.normal)\n    slitb = Cpt(EpicsSignalRO, \"1{Slt:1-Ax:B}Mtr.RBV\", kind=Kind.normal)\n    slitt = Cpt(EpicsSignalRO, \"1{Slt:1-Ax:T}Mtr.RBV\", kind=Kind.normal)"
  },
  {
    "class_name": "EDXD",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/hex-profile-collection/startup/03-motors.py",
    "source": "class EDXD(Device):\n    # XF:27IDF-OP:1{EDXD:1-Ax:X}Mtr.VAL\n    axis_x = Cpt(EpicsMotorWithDescription, \"X}Mtr\")\n    # XF:27IDF-OP:1{EDXD:1-Ax:Y}Mtr.VAL\n\n    # XF:27IDF-OP:1{EDXD:1-Ax:Rx}Mtr.VAL\n    axis_rx = Cpt(EpicsMotorWithDescription, \"Rx}Mtr\")"
  },
  {
    "class_name": "SRXFastShutter",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/11-optics.py",
    "source": "class SRXFastShutter(Device):\n    # Based on HXN Fast Shutter code\n    request_open = Cpt(EpicsSignal, \"\")\n    _verbosity = 1\n\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix, **kwargs)\n        self.stage_sigs[self.request_open] = 1\n\n    def open(self):\n        self.request_open.set(1)\n\n    def close(self):\n        self.request_open.set(0)\n\n    def stage(self):\n        if self._verbosity > 0:\n            banner(\"Opening fast shutter\")\n        super().stage()\n\n    def unstage(self):\n        if self._verbosity > 0:\n            banner(\"Closing fast shutter\")\n        super().unstage()"
  },
  {
    "class_name": "SRXSlitsWB",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/11-optics.py",
    "source": "class SRXSlitsWB(Device):\n    # Real synthetic axes\n    h_cen = Cpt(EpicsMotor, \"XCtr}Mtr\")\n    h_gap = Cpt(EpicsMotor, \"XGap}Mtr\")\n    v_cen = Cpt(EpicsMotor, \"YCtr}Mtr\")\n    v_gap = Cpt(EpicsMotor, \"YGap}Mtr\")\n\n    # Real motors\n    top = Cpt(EpicsMotor, \"T}Mtr\")\n    bot = Cpt(EpicsMotor, \"B}Mtr\")\n    inb = Cpt(EpicsMotor, \"I}Mtr\")\n    out = Cpt(EpicsMotor, \"O}Mtr\")"
  },
  {
    "class_name": "SRXSlitsPB",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/11-optics.py",
    "source": "class SRXSlitsPB(Device):\n    # Real synthetic axes\n    h_cen = Cpt(EpicsMotor, \"XCtr}Mtr\")\n    h_gap = Cpt(EpicsMotor, \"XGap}Mtr\")\n\n    # Real motors\n    inb = Cpt(EpicsMotor, \"I}Mtr\")\n    out = Cpt(EpicsMotor, \"O}Mtr\")"
  },
  {
    "class_name": "SRXHFM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/11-optics.py",
    "source": "class SRXHFM(Device):\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n    pitch = Cpt(EpicsMotor, \"P}Mtr\")\n    fine_pitch = Cpt(SRXHFMFinePitch, \"XF:05IDA-OP:1{Mir:1-Ax:PF}\", name=\"fine_pitch\", add_prefix=())\n    bend = Cpt(EpicsMotor, \"Bend}Mtr\")"
  },
  {
    "class_name": "SRXDCM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/11-optics.py",
    "source": "class SRXDCM(Device):\n    bragg = energy.bragg\n    c1_roll = Cpt(EpicsMotor, \"R1}Mtr\")\n    c1_fine = Cpt(\n        HDCMPiezoRoll,\n        \"XF:05IDA-BI{BEST:1}PreDAC0:OutCh2\", name=\"c1_fine\",\n        add_prefix=()\n    )\n    c2_x = energy.c2_x\n    c2_pitch = Cpt(EpicsMotor, \"P2}Mtr\")\n    c2_fine = Cpt(\n        HDCMPiezoPitch,\n        \"XF:05IDA-BI{BEST:1}PreDAC0:OutCh1\",\n        name=\"c2_fine\",\n        add_prefix=()\n    )\n    c2_pitch_kill = Cpt(EpicsSignal, \"P2}Cmd:Kill-Cmd\")\n    x = Cpt(EpicsMotor, \"X}Mtr\")\n    y = Cpt(EpicsMotor, \"Y}Mtr\")\n\n    temp_pitch = Cpt(EpicsSignalRO, \"P}T-I\")"
  },
  {
    "class_name": "SRXBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/11-optics.py",
    "source": "class SRXBPM(Device):\n    y = Cpt(EpicsMotor, \"YFoil}Mtr\")\n    diode_x = Cpt(EpicsMotor, \"XDiode}Mtr\")\n    diode_y = Cpt(EpicsMotor, \"YDiode}Mtr\")"
  },
  {
    "class_name": "SRXSSACalc",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/11-optics.py",
    "source": "class SRXSSACalc(Device):\n    h_cen = Cpt(SRXSSAHC, \"\", name=\"h_cen\")\n    h_gap = Cpt(SRXSSAHG, \"\", name=\"h_gap\")\n    v_cen = Cpt(SRXSSAVC, \"\", name=\"v_cen\")\n    v_gap = Cpt(SRXSSAVG, \"\", name=\"v_gap\")"
  },
  {
    "class_name": "FlyerIDMono",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/60-xanes.py",
    "source": "class FlyerIDMono(Device):\n    def __init__(self, flying_dev, zebra, xs_detectors, scaler, pulse_cpt=None, pulse_width=0.01, paused_timeout=120):\n        \"\"\"Instantiate a flyer based on ID-Mono coordinated motion.\n\n        Parameters\n        ----------\n        flying_dev : IDFlyDevice\n            ID-Mono fly device that has controls of the DCM and ID energies\n\n        zebra : SRXZebra\n            zebra ophyd object\n\n        xs_detectors : list\n            a list of ophyd objects for corresponding xspress3 detectors\n\n        scaler : SRXScaler\n            an ophyd object for the scaler detector\n\n        pulse_cpt : str\n            an ophyd component name corresponding to the pulse signal\n\n        pulse_width : float\n            the pulse width in seconds, used for zebra\n\n        paused_timeout : float\n            the timeout to wait between the steps until the scan is interrupted if the \"unpause\" button is not pressed.\n        \"\"\"\n        super().__init__(\"\", parent=None, name=\"flyer_id_mono\")\n\n        self.flying_dev = flying_dev\n        self.zebra = zebra\n        self.xs_detectors = xs_detectors\n        self.scaler = scaler\n        self._staging_delay = 0.010\n\n        # LUTs\n        self.lut_u = EpicsSignal(\n                         \"SR:C5-ID:G1{IVU21:1}FlyLUT-Gap-RB\",\n                         write_pv=\"SR:C5-ID:G1{IVU21:1}FlyLUT-Gap-SP\",\n                         name=\"lut_u\",\n                         kind=\"omitted\"\n                         )\n        self.lut_e = EpicsSignal(\n                         \"SR:C5-ID:G1{IVU21:1}FlyLUT-Energy-RB\",\n                         write_pv=\"SR:C5-ID:G1{IVU21:1}FlyLUT-Energy-SP\",\n                         name=\"lut_e\",\n                         kind=\"omitted\"\n                         )\n\n        # The pulse width has to be set both in Zebra and the Scan Engine.\n        if pulse_cpt is None:\n            raise RuntimeError(f'pulse_cpt cannot be None. Please provide a valid component name.')\n        self.pulse_cpt = pulse_cpt\n        self.pulse_width = pulse_width\n\n        self.num_scans = None\n        self.num_triggers = None\n\n        self.paused_timeout = paused_timeout\n        self._continue_after_pausing = True\n\n        # Flyer infrastructure parameters.\n        self._traj_info = {}\n        self._array_size = {}\n        self._datum_ids = []\n\n    def stage(self):\n        # total_points = self.num_scans * self.num_triggers\n        if self.num_triggers is None:\n            print(f'You must set {self.name}.num_triggers before staging!')\n            raise Exception\n        total_points = self.num_triggers\n\n        for xs_det in self.xs_detectors:\n            xs_det.hdf5.file_write_mode.put('Capture')\n            xs_det.external_trig.put(True)\n            xs_det.total_points.put(total_points)\n            xs_det.spectra_per_point.put(1)\n            xs_det.stage()\n            xs_det.cam.acquire.put(1)\n\n        # Scaler config\n        # self.scaler.count_mode.put(0)  # put SIS3820 into single count (not autocount) mode\n        self.scaler.stop_all.put(1)  # stop scaler\n        ttime.sleep(0.050)\n        self.scaler.nuse_all.put(2*total_points)\n        ttime.sleep(0.050)\n        self._stage_with_delay()\n        self.scaler.erase_start.put(1)  # This is basically triggering the detector so it should be done last\n\n    def _stage_with_delay(self):\n        # Staging taken from https://github.com/bluesky/ophyd/blob/master/ophyd/device.py\n        # Device - BlueskyInterface\n        \"\"\"Stage the device for data collection.\n        This method is expected to put the device into a state where\n        repeated calls to :meth:`~BlueskyInterface.trigger` and\n        :meth:`~BlueskyInterface.read` will 'do the right thing'.\n        Staging not idempotent and should raise\n        :obj:`RedundantStaging` if staged twice without an\n        intermediate :meth:`~BlueskyInterface.unstage`.\n        This method should be as fast as is feasible as it does not return\n        a status object.\n        The return value of this is a list of all of the (sub) devices\n        stage, including it's self.  This is used to ensure devices\n        are not staged twice by the :obj:`~bluesky.run_engine.RunEngine`.\n        This is an optional method, if the device does not need\n        staging behavior it should not implement `stage` (or\n        `unstage`).\n        Returns\n        -------\n        devices : list\n            list including self and all child devices staged\n        \"\"\"\n        if self._staged == Staged.no:\n            pass  # to short-circuit checking individual cases\n        elif self._staged == Staged.yes:\n            raise RedundantStaging(\"Device {!r} is already staged. \"\n                                   \"Unstage it first.\".format(self))\n        elif self._staged == Staged.partially:\n            raise RedundantStaging(\"Device {!r} has been partially staged. \"\n                                   \"Maybe the most recent unstaging \"\n                                   \"encountered an error before finishing. \"\n                                   \"Try unstaging again.\".format(self))\n        self.log.debug(\"Staging %s\", self.name)\n        self._staged = Staged.partially\n\n        # Resolve any stage_sigs keys given as strings: 'a.b' -> self.a.b\n        stage_sigs = OrderedDict()\n        for k, v in self.stage_sigs.items():\n            if isinstance(k, str):\n                # Device.__getattr__ handles nested attr lookup\n                stage_sigs[getattr(self, k)] = v\n            else:\n                stage_sigs[k] = v\n\n        # Read current values, to be restored by unstage()\n        original_vals = {sig: sig.get() for sig in stage_sigs}\n\n        # We will add signals and values from original_vals to\n        # self._original_vals one at a time so that\n        # we can undo our partial work in the event of an error.\n\n        # Apply settings.\n        devices_staged = []\n        try:\n            for sig, val in stage_sigs.items():\n                self.log.debug(\"Setting %s to %r (original value: %r)\",\n                               self.name,\n                               val, original_vals[sig])\n                sig.set(val, timeout=10).wait()\n                ttime.sleep(self._staging_delay)\n                # It worked -- now add it to this list of sigs to unstage.\n                self._original_vals[sig] = original_vals[sig]\n            devices_staged.append(self)\n\n            # Call stage() on child devices.\n            for attr in self._sub_devices:\n                device = getattr(self, attr)\n                if hasattr(device, 'stage'):\n                    device.stage()\n                    devices_staged.append(device)\n        except Exception:\n            self.log.debug(\"An exception was raised while staging %s or \"\n                           \"one of its children. Attempting to restore \"\n                           \"original settings before re-raising the \"\n                           \"exception.\", self.name)\n            self.unstage()\n            raise\n        else:\n            self._staged = Staged.yes\n        return devices_staged\n\n\n\n    def unstage(self):\n        self._unstage_with_delay()\n        for xs_det in self.xs_detectors:\n            xs_det.cam.acquire.put(0)\n            xs_det.hdf5.capture.put(0)  # this is to save the file is the number of collected frames is less than expected\n            xs_det.cam.trigger_mode.put('Internal')\n            xs_det.unstage()\n\n        # print(f\"{print_now()}: before unstaging scaler\")\n        self.scaler.stop_all.put(1)\n        self.scaler.count_mode.put(1)\n        self.scaler.read_attrs = [\"channels.chan2\", \"channels.chan3\", \"channels.chan4\"]\n        # self.scaler.count_mode.put(1)  # return SIS3820 into autocount (not single count) mode\n        # print(f\"{print_now()}: after unstaging scaler\")\n\n    def _unstage_with_delay(self):\n        # Staging taken from https://github.com/bluesky/ophyd/blob/master/ophyd/device.py\n        # Device - BlueskyInterface\n        \"\"\"Unstage the device.\n        This method returns the device to the state it was prior to the\n        last `stage` call.\n        This method should be as fast as feasible as it does not\n        return a status object.\n        This method must be idempotent, multiple calls (without a new\n        call to 'stage') have no effect.\n        Returns\n        -------\n        devices : list\n            list including self and all child devices unstaged\n        \"\"\"\n        self.log.debug(\"Unstaging %s\", self.name)\n        self._staged = Staged.partially\n        devices_unstaged = []\n\n        # Call unstage() on child devices.\n        for attr in self._sub_devices[::-1]:\n            device = getattr(self, attr)\n            if hasattr(device, 'unstage'):\n                device.unstage()\n                devices_unstaged.append(device)\n\n        # Restore original values.\n        for sig, val in reversed(list(self._original_vals.items())):\n            self.log.debug(\"Setting %s back to its original value: %r)\",\n                           self.name,\n                           val)\n            sig.set(val, timeout=10).wait()\n            ttime.sleep(self._staging_delay)\n            self._original_vals.pop(sig)\n        devices_unstaged.append(self)\n\n        self._staged = Staged.no\n        return devices_unstaged\n\n    def kickoff(self, *args, **kwargs):\n\n        # print('In kickoff...')\n        # Reset zebra to clear the data entries.\n        self.zebra.pc.block_state_reset.put(1)\n\n        # Arm zebra.\n        # self.zebra.pc.arm.put(1)  # is this necessary? we don't use PC\n\n        # PULSE tab of the Zebra CSS:\n        # getattr(self.zebra, self.pulse_cpt).input_addr.put(1)            # 'Input' in CSS, 1=IN1_TTL\n        # getattr(self.zebra, self.pulse_cpt).input_edge.put(0)            # 'Trigger on' in CSS, 0=Rising, 1=Falling\n        # getattr(self.zebra, self.pulse_cpt).delay.put(0.0)               # 'Delay before' in CSS\n        getattr(self.zebra, self.pulse_cpt).width.put(self.pulse_width)  # 'First Pulse' in CSS\n        # getattr(self.zebra, self.pulse_cpt).time_units.put('s')          # 'Time Units' in CSS\n\n        # SYS tab of the Zebra CSS\n        # for out in [1, 2, 3, 4]:\n        # for out in [1, 2, 4]:\n        #     getattr(self.zebra, f'output{out}').ttl.addr.put(52)          # 'OUTx TTL' in CSS\n\n        # TESTING\n        # self.zebra.output3.ttl.addr.put(36)\n\n        # self.zebra.pulse3.input_addr.put(52)\n        # self.zebra.pulse3.input_edge.put(0)\n        # self.zebra.pulse3.time_units.put('ms')\n        # self.zebra.pulse3.width.put(0.100)\n        # self.zebra.pulse3.delay.put(0.0)\n\n        # self.zebra.pulse4.input_addr.put(52)\n        # self.zebra.pulse4.input_edge.put(1)\n        # self.zebra.pulse4.time_units.put('ms')\n        # self.zebra.pulse4.width.put(0.100)\n        # self.zebra.pulse4.delay.put(0.0)\n\n        width_s = self.pulse_width\n        speed = self.flying_dev.parameters.speed.get()\n\n        self.num_scans = num_scans = self.flying_dev.parameters.num_scans.get()\n        self.num_triggers = num_triggers = int(self.flying_dev.parameters.num_triggers.get())\n\n        self.flying_dev.parameters.paused_timeout.put(self.paused_timeout)\n\n        self._traj_info.update({\n            'num_triggers': num_triggers,\n            'energy_start': self.flying_dev.parameters.first_trigger.get(),\n            'energy_stop': self.flying_dev.parameters.last_trigger.get(),\n            })\n\n        # print('Staging...')\n        self.stage()\n\n        # Convert to eV/s.\n        # width_ev = width_s * speed\n        # self.flying_dev.parameters.trigger_width.put(width_ev)\n\n        # print(f'Enabling fly scan')\n        st = self.flying_dev.control.set(\"enable\")\n        while not st.done:\n            ttime.sleep(0.1)\n\n        # Reset the trigger count and current scan:\n        self.flying_dev.parameters.trigger_count_reset.put(1)\n        self.flying_dev.parameters.current_scan_reset.put(1)\n\n        ttime.sleep(1.0)  # Wait 1 second because the control PV updates at 1 Hz\n\n        # Main RUN command:\n        self.flying_dev.control.run.put(1)\n\n        self.status = self.flying_dev.control.scan_in_progress\n\n        def callback(value, old_value, **kwargs):\n            # print(f'{print_now()} in kickoff: {old_value} ---> {value}')\n            if int(round(old_value)) == 0 and int(round(value)) == 1:\n                return True\n            return False\n\n        status = SubscriptionStatus(self.status, callback)\n        return status\n\n    def complete(self, *args, **kwargs):\n        if self.xs_detectors[0]._staged.value == 'no':\n\n            # Note: this is a way to stop the scan on the fly.\n            if self.flying_dev.parameters.num_scans.get() == 0:\n                self._continue_after_pausing = False\n                self.flying_dev.control.abort.put(1)\n\n            if self._continue_after_pausing:\n                self.stage()\n                self.flying_dev.parameters.scan_paused.put(0)\n\n        def _complete_detectors():\n            # print(f\"{print_now()} run 'complete' on detectors.\")\n            # ttime.sleep(0.5)\n            for xs_det in self.xs_detectors:\n                # print(f\"{print_now()} before erase in '_complete_detectors'.\")\n                # xs_det.cam.erase.put(1)\n                # print(f\"{print_now()} after erase in '_complete_detectors'.\")\n                # print(f\"{xs_det.name=}\")\n                xs_det.complete()\n            # print(f\"{print_now()} done with 'complete' on detectors.\")\n\n        def callback_paused(value, old_value, **kwargs):\n            # print(f\"{print_now()} 'callback_paused' in complete:  scan_paused: {old_value} ---> {value}\")\n             # 1=Paused, 0=Not Paused\n            if int(round(old_value)) == 0 and int(round(value)) == 1:\n                _complete_detectors()\n                return True\n            return False\n\n        def callback_all_scans_done(value, old_value, **kwargs):\n            # print(f\"{print_now()} 'callback_all_scans_done' in complete:  current_scan: {old_value} ---> {value}\")\n            if value == self.flying_dev.parameters.num_scans.get():  # last scan in the series, no pausing happens\n                # print(\"  Last scan in the series.\")\n                _complete_detectors()\n                self.zebra.pc.disarm.put(1)\n                return True\n            return False\n\n        current_scan = self.flying_dev.parameters.current_scan.get()\n        num_scans = self.flying_dev.parameters.num_scans.get()\n\n        if  current_scan + 1 < num_scans:  # last scan\n            status_paused = SubscriptionStatus(self.flying_dev.parameters.scan_paused, callback_paused, run=False)\n            return status_paused\n        elif current_scan + 1 == num_scans:\n            status_all_scans_done = SubscriptionStatus(self.flying_dev.parameters.current_scan, callback_all_scans_done, run=False)\n            return status_all_scans_done\n        else:\n            return NullStatus()\n\n    # TODO: Fix the configuration (also for v2).\n    # def describe_configuration(self, *args, **kwargs):\n    #     ret = {}\n    #     for xs_det in self.xs_detectors:\n    #         ret[f'{xs_det}.name'] = xs_det.describe_configuration()\n    #     return ret\n\n    def describe_collect(self, *args, **kwargs):\n        # print(f\"\\n\\n{print_now()}: describe_collect started\")\n        return_dict = {}\n        if True:\n        # for scan_num in range(self.num_scans):\n            current_scan = self.flying_dev.parameters.current_scan.get()\n\n            # print(f\"{print_now()}: current_scan: {current_scan}\")\n\n            formatted_scan_num = f\"scan_{current_scan:03d}\"\n            return_dict[formatted_scan_num] = \\\n                {'energy': {'source': self.flying_dev.name,\n                            'dtype': 'number',\n                            # We need just 1 scalar value for the energy.\n                            # 'shape': [self._traj_info['num_triggers']]},\n                            # TODO: double-check the shape is right for databroker v2.\n                            'shape': []},\n                 'i0_time': {'source': 'scaler', 'dtype': 'array', 'shape': []},\n                 'i0': {'source': 'scaler', 'dtype': 'array', 'shape': []},\n                 'im': {'source': 'scaler', 'dtype': 'array', 'shape': []},\n                 'it': {'source': 'scaler', 'dtype': 'array', 'shape': []},\n                 # f'{self.detector.name}_image': {'source': '...',\n                 #           'dtype': 'array',\n                 #           'shape': [self._array_size['height'],\n                 #                     self._array_size['width']],\n                 #           'external': 'FILESTORE:'}\n                }\n\n            for xs_det in self.xs_detectors:\n                # for channel in xs_det.channels.keys():\n                for channel in xs_det.iterate_channels():\n                    return_dict[formatted_scan_num][f'{xs_det.name}_channel{channel.channel_number:02}'] = {'source': 'xspress3',\n                                                                        'dtype': 'array',\n                                                                        # The shape will correspond to a 1-D array of 4096 bins from xspress3.\n                                                                        'shape': [\n                                                                                  # We don't need the total number of frames here.\n                                                                                  # xs_det.settings.num_images.get(),\n                                                                                  #\n                                                                                  # The height corresponds to a number of channels, but we only need one here.\n                                                                                  # xs_det.hdf5.array_size.height.get(),\n                                                                                  #\n                                                                                  xs_det.hdf5.array_size.width.get()],\n                                                                        'external': 'FILESTORE:'}\n        import pprint\n        # pprint.pprint(return_dict)\n\n        # print(f\"\\n\\n{print_now()}: describe_collect ended\")\n\n        return return_dict\n\n    def collect(self, *args, **kwargs):\n\n        # TODO: test that feature.\n        if not self._continue_after_pausing:\n            return {}\n\n        energy_start = self._traj_info['energy_start']\n        energy_stop = self._traj_info['energy_stop']\n        num_triggers = self._traj_info['num_triggers']\n\n        # if len(self._datum_ids) != num_triggers:\n        #     raise RuntimeError(f\"The number of collected datum ids ({self._datum_ids}) \"\n        #                        f\"does not match the number of triggers ({num_triggers})\")\n\n        ttime.sleep(self.pulse_width + 0.1)\n\n        orig_read_attrs = self.scaler.read_attrs\n        self.scaler.read_attrs = ['mca1', 'mca2', 'mca3', 'mca4']\n        # print(orig_read_attrs)\n\n        total_points = self.num_scans * self.num_triggers\n\n        print(f\"{print_now()}: before while loop in collect scaler data\")\n        flag_collecting_data = 0\n        while (flag_collecting_data < 5):\n            scaler_mca_data = self.scaler.read()\n            i0_time = scaler_mca_data[f\"{self.scaler.name}_mca1\"]['value']\n            i0 = scaler_mca_data[f\"{self.scaler.name}_mca2\"]['value']\n            im = scaler_mca_data[f\"{self.scaler.name}_mca3\"]['value']\n            it = scaler_mca_data[f\"{self.scaler.name}_mca4\"]['value']\n\n            # print(f'{i0_time.shape[0]}\\t?=\\t{2*self.num_triggers}')\n            if i0_time.shape[0] == 2*self.num_triggers:\n                break\n            flag_collecting_data += 1\n            ttime.sleep(0.2)\n            # print(f'({flag_collecting_data+1}/5) Waiting to collect all scaler data...')\n        print(f\"{print_now()}: after while loop in collect scaler data\")\n\n        self.scaler.read_attrs = orig_read_attrs\n        # print(self.scaler.read_attrs)\n\n        # print(f\"Length of 'i0_time': {len(i0_time)}\")\n        # print(f\"Length of 'i0'     : {len(i0)}\")\n        # print(f\"Length of 'im'     : {len(im)}\")\n        # print(f\"Length of 'it'     : {len(it)}\")\n\n        i0_time = i0_time[1::2]\n        i0 = i0[1::2]\n        im = im[1::2]\n        it = it[1::2]\n\n        # print(f\"Truncated length of 'i0_time': {len(i0_time)}\")\n        # print(f\"Truncated length of 'i0'     : {len(i0)}\")\n        # print(f\"Truncated length of 'im'     : {len(im)}\")\n        # print(f\"Truncated length of 'it'     : {len(it)}\")\n\n        if len(i0_time) != len(i0) != len(im) != len(it):\n            # print(f'{len(i0_time)=}')\n            raise RuntimeError(f\"Lengths of the collected arrays are not equal\")\n        # print(f\"{len(i0_time)=}\")\n        # print(f\"{num_triggers=}\")\n        if len(i0_time) != num_triggers:\n            # I don't understand why I can't do this in a for-loop with a list\n            # for d in [i0_time, i0, im, it]:\n            #     d = np.concatenate((d, np.ones((num_triggers-len(d),))))\n            i0_time = np.concatenate((i0_time, np.ones((num_triggers-len(i0_time),))))\n            i0 = np.concatenate((i0, np.ones((num_triggers-len(i0),))))\n            im = np.concatenate((im, np.ones((num_triggers-len(im),))))\n            it = np.concatenate((it, np.ones((num_triggers-len(it),))))\n            # print(f'{len(i0_time)=}')\n\n        # print(f\"{print_now()}: before unstage of xs in collect\")\n\n        # Unstage xspress3 detector(s).\n        print(f\"{print_now()}: before unstaging xs\")\n        self.unstage()\n        print(f\"{print_now()}: after unstaging xs\")\n\n        # print(f\"{print_now()}: after unstage of xs in collect\")\n\n        # Deal with the direction of energies for bi-directional scan.\n        # BlueSky@SRX [27]: id_fly_device.control.scan_type.get(as_string=True)\n        # Out[27]: 'Bidirectional'\n\n        # BlueSky@SRX [28]: id_fly_device.control.scan_type.enum_strs\n        # Out[28]: ('Unidirectional', 'Bidirectional')\n\n        even_direction = np.linspace(energy_start, energy_stop, num_triggers)\n        odd_direction =  even_direction[::-1]\n\n        scan_type = self.flying_dev.control.scan_type.get(as_string=True)\n        current_scan = self.flying_dev.parameters.current_scan.get()\n        # print(f\"{print_now()} the scan is {scan_type}; current scan: {current_scan}\")\n\n        direction = even_direction\n        if scan_type == \"Bidirectional\":\n            if (current_scan + 1) % 2 == 1:  # at this point the current scan number is already incremented\n                direction = odd_direction\n                # print(f\"{print_now()} reversing the energy axis: {direction[0]} --> {direction[-1]}\")\n\n        # print(f\"{print_now()}: In possible long loop...\")\n        for ii, energy in enumerate(direction):\n            # print(f\"  {print_now()}: {energy}\")\n            for xs_det in self.xs_detectors:\n                # print(f\"  {print_now()}: {xs_det.name}\")\n                now = ttime.time()\n\n                data = {\n                    'energy': energy,\n                    'i0_time': i0_time[ii],\n                    'i0': i0[ii],\n                    'im': im[ii],\n                    'it': it[ii],\n                }\n                timestamps = {\n                    'energy': now,\n                    'i0_time': now,\n                    'i0': now,\n                    'im': now,\n                    'it': now,\n                }\n                filled = {}\n                for jj, channel in enumerate(xs_det.iterate_channels()):\n                    # print(f\"  {print_now()}: {channel.name}\")\n                    key = channel.name\n                    idx = jj + ii * len(xs_det.channel_numbers)\n                    timestamps[key] = now\n                    filled[key] = False\n                    try:\n                        # print(f\"{xs_det._datum_ids=}\")\n                        data[key] = xs_det._datum_ids[idx]\n                    except IndexError:\n                        print('Waiting 10 seconds for data from X3X...')\n                        ttime.sleep(10)\n                        try:\n                            data[key] = xs_det._datum_ids[idx]\n                        except IndexError:\n                            print('WARNING! X3X did not receive all the pulses!')\n                            print('         Continuing...')\n                            break  # It won't find anymore data so might as well break\n\n            yield {\n                'data': data,\n                'timestamps': timestamps,\n                'time': now,\n                'seq_num': ii,\n                'filled': filled,\n                'descriptor': 'scan_000',\n            }\n\n        print(f\"{print_now()}: after docs emitted in collect\")\n\n\n    def collect_asset_docs(self):\n        print(f\"{print_now()}: before collecting asset docs from xs in collect_asset_docs\")\n        for xs_det in self.xs_detectors:\n            yield from xs_det.collect_asset_docs()\n        print(f\"{print_now()}: after collecting asset docs from xs in collect_asset_docs\")\n\n    def stop(self):\n        # I don't think this is running on stop :-(\n        print(f\"{print_now()}: I am running the stop function...\")\n        self._continue_after_pausing = False\n\n        # Abort any active scan\n        if self.control.scan_in_progress.get() == 1:\n            if self.control.abort.write_access is True:\n                print('Aborting any active scans...')\n                yield from abs_set(self.control.abort, 1)\n\n        # Disable flying mode\n        if self.flying_dev.control.control.write_access is True:\n           print('Disabling fly mode...')\n           yield from abs_set(self.flying_dev.control.control, 0)\n\n        # unstage flyer\n        print('Unstaging the flyer...')\n        yield from self.unstage()\n\n        #reset scaler count mode\n        print('Resetting the scaler...')\n        yield from mv(sclr1.count_mode, 1)\n        sclr1.read_attrs = [\"channels.chan2\", \"channels.chan3\", \"channels.chan4\"]\n        print(f\"{print_now()}: I am leaving the stop function...\")\n        pass\n\n    def abort(self):\n        self.stop()\n\n    def update_lut(self):\n        # Make some assumptions:\n        N = 20  # Number of points in LUT\n        # Define the \"knot\" values from the calibration\n        u_cal = energy.utoelookup.t\n        e_cal = energy.etoulookup.t\n        Umin = min(u_cal)\n        Umax = max(u_cal)\n\n        # Define an easy variable to call\n        u2e = energy.utoelookup\n\n        # Make new PV values\n        uRBV = np.linspace(Umin, Umax, N, dtype=float)\n        eRBV = u2e(uRBV).astype(float)\n\n        # Output\n        if self.lut_u.write_access:\n            self.lut_u.put(uRBV*1000)\n        else:\n            print(f\"No write access to LUT-Gap\\n{uRBV=}\")\n        if self.lut_e.write_access:\n            self.lut_e.put(eRBV*1000)\n        else:\n            print(f\"No write access to LUT-Energy\\n{eRBV=}\")"
  },
  {
    "class_name": "CurrentPreampZebra",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/32-zebra.py",
    "source": "class CurrentPreampZebra(Device):\n    ch0 = Cpt(EpicsSignalRO, \"Cur:I0-I\")\n    ch1 = Cpt(EpicsSignalRO, \"Cur:I1-I\")\n    ch2 = Cpt(EpicsSignalRO, \"Cur:I2-I\")\n    ch3 = Cpt(EpicsSignalRO, \"Cur:I3-I\")\n\n    # exp_time = Cpt(EpicsSignal, 'Per-SP')\n    exp_time = Cpt(\n        EpicsSignal, \"XF:05IDD-ES:1{Dev:Zebra1}:PULSE3_WID\", add_prefix=()\n    )\n    trigger_mode = Cpt(EpicsSignal, \"Cmd:TrigMode\")\n    initi_trigger = Cpt(EpicsSignal, \"Cmd:Init\")\n    zebra_trigger = Cpt(\n        EpicsSignal, \"XF:05IDD-ES:1{Dev:Zebra1}:SOFT_IN:B0\", add_prefix=()\n    )\n    zebra_pulse_3_source = Cpt(\n        EpicsSignal, \"XF:05IDD-ES:1{Dev:Zebra1}:PULSE3_INP\", add_prefix=()\n    )\n\n    current_scan_rate = Cpt(EpicsSignal, \"Cmd:RdCur.SCAN\")\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.stage_sigs[self.zebra_trigger] = 0\n        #        self.stage_sigs[self.zebra_pulse_3_source] = 44\n        self.stage_sigs[self.zebra_pulse_3_source] = 60\n\n        self.current_scan_rate.put(9)\n        # update\n        # self.trigger_mode.put(5)\n        self.stage_sigs[self.trigger_mode] = 5  # fix this\n        self.initi_trigger.put(1, wait=True)\n\n    def stage(self):\n\n        # Customize what is done before every scan (and undone at the end)\n        # self.stage_sigs[self.trans_diode] = 5\n        # or just use pyepics directly if you need to\n        ret = super().stage()\n        self.initi_trigger.put(1, wait=True)\n        return ret\n\n    def trigger(self):\n        init_ts = self.ch0.timestamp\n        timeout = float(self.exp_time.get() + 0.8)\n\n        def retrigger():\n            print(f\"[WW] Re-triggered ion chamber;\"\n                  f\"I0 for this point is suspect.\")\n            self.zebra_trigger.put(0, wait=True)\n            self.zebra_trigger.put(1, wait=True)\n\n        def done_cb(\n            *args, obj=None, old_value=None,\n            value=None, timestamp=None, **kwargs\n        ):\n            # if the value has changed, assume it is done\n            if value != old_value:\n                tmr.cancel()\n                ret._finished()\n                obj.clear_sub(done_cb)\n\n        tmr = threading.Timer(timeout, retrigger)\n        tmr.start()\n        ret = DeviceStatus(self)\n\n        self.ch0.subscribe(done_cb, event_type=self.ch0.SUB_VALUE, run=False)\n        self.zebra_trigger.put(0, wait=True)\n        self.zebra_trigger.put(1, wait=True)\n\n        return ret"
  },
  {
    "class_name": "ZebraPositionCaptureData",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/32-zebra.py",
    "source": "class ZebraPositionCaptureData(Device):\n    \"\"\"\n    Data arrays for the Zebra position capture function and their metadata.\n    \"\"\"\n\n    # Data arrays\n    div1 = Cpt(EpicsSignal, \"PC_DIV1\")\n    div2 = Cpt(EpicsSignal, \"PC_DIV2\")\n    div3 = Cpt(EpicsSignal, \"PC_DIV3\")\n    div4 = Cpt(EpicsSignal, \"PC_DIV4\")\n    enc1 = Cpt(EpicsSignal, \"PC_ENC1\")\n    enc2 = Cpt(EpicsSignal, \"PC_ENC2\")\n    enc3 = Cpt(EpicsSignal, \"PC_ENC3\")\n    enc4 = Cpt(EpicsSignal, \"PC_ENC4\")\n    filt1 = Cpt(EpicsSignal, \"PC_FILT1\")\n    filt2 = Cpt(EpicsSignal, \"PC_FILT2\")\n    filt3 = Cpt(EpicsSignal, \"PC_FILT3\")\n    filt4 = Cpt(EpicsSignal, \"PC_FILT4\")\n    time = Cpt(EpicsSignal, \"PC_TIME\")\n    # Array sizes\n    num_cap = Cpt(EpicsSignal, \"PC_NUM_CAP\")\n    num_down = Cpt(EpicsSignal, \"PC_NUM_DOWN\")\n    # BOOLs to denote arrays with data\n    cap_enc1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B0\")\n    cap_enc2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B1\")\n    cap_enc3_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B2\")\n    cap_enc4_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B3\")\n    cap_filt1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B4\")\n    cap_filt2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B5\")\n    cap_div1_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B6\")\n    cap_div2_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B7\")\n    cap_div3_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B8\")\n    cap_div4_bool = Cpt(EpicsSignal, \"PC_BIT_CAP:B9\")\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "ZebraPositionCapture",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/32-zebra.py",
    "source": "class ZebraPositionCapture(Device):\n    \"\"\"\n    Signals for the position capture function of the Zebra\n    \"\"\"\n\n    # Configuration settings and status PVs\n    enc = Cpt(EpicsSignalWithRBV, \"PC_ENC\")\n    egu = Cpt(EpicsSignalRO, \"M1:EGU\")\n    dir = Cpt(EpicsSignalWithRBV, \"PC_DIR\")\n    tspre = Cpt(EpicsSignalWithRBV, \"PC_TSPRE\")\n    trig_source = Cpt(EpicsSignalWithRBV, \"PC_ARM_SEL\")\n    arm = Cpt(EpicsSignal, \"PC_ARM\")\n    disarm = Cpt(EpicsSignal, \"PC_DISARM\")\n    armed = Cpt(EpicsSignalRO, \"PC_ARM_OUT\")\n    gate_source = Cpt(EpicsSignalWithRBV, \"PC_GATE_SEL\")\n    gate_start = Cpt(EpicsSignalWithRBV, \"PC_GATE_START\")\n    gate_width = Cpt(EpicsSignalWithRBV, \"PC_GATE_WID\")\n    gate_step = Cpt(EpicsSignalWithRBV, \"PC_GATE_STEP\")\n    gate_num = Cpt(EpicsSignalWithRBV, \"PC_GATE_NGATE\")\n    gated = Cpt(EpicsSignalRO, \"PC_GATE_OUT\")\n    pulse_source = Cpt(EpicsSignalWithRBV, \"PC_PULSE_SEL\")\n    pulse_start = Cpt(EpicsSignalWithRBV, \"PC_PULSE_START\")\n    pulse_width = Cpt(EpicsSignalWithRBV, \"PC_PULSE_WID\")\n    pulse_step = Cpt(EpicsSignalWithRBV, \"PC_PULSE_STEP\")\n    pulse_max = Cpt(EpicsSignalWithRBV, \"PC_PULSE_MAX\")\n    pulse = Cpt(EpicsSignalRO, \"PC_PULSE_OUT\")\n    enc_pos1_sync = Cpt(EpicsSignal, \"M1:SETPOS.PROC\")\n    enc_pos2_sync = Cpt(EpicsSignal, \"M2:SETPOS.PROC\")\n    enc_pos3_sync = Cpt(EpicsSignal, \"M3:SETPOS.PROC\")\n    enc_pos4_sync = Cpt(EpicsSignal, \"M4:SETPOS.PROC\")\n    enc_res1 = Cpt(EpicsSignal, \"M1:MRES\")\n    enc_res2 = Cpt(EpicsSignal, \"M2:MRES\")\n    enc_res3 = Cpt(EpicsSignal, \"M3:MRES\")\n    enc_res4 = Cpt(EpicsSignal, \"M4:MRES\")\n    data_in_progress = Cpt(EpicsSignalRO, \"ARRAY_ACQ\")\n    block_state_reset = Cpt(EpicsSignal, \"SYS_RESET.PROC\")\n    data = Cpt(ZebraPositionCaptureData, \"\")\n\n    def stage(self):\n        # self.arm.put(1)\n\n        super().stage()\n\n    def unstage(self):\n        self.disarm.put(1)\n        self.block_state_reset.put(1)\n\n        super().unstage()"
  },
  {
    "class_name": "SRXZebraOR",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/32-zebra.py",
    "source": "class SRXZebraOR(Device):\n    # I really appreciate the different indexing for input source\n    # Thank you for that\n    use1 = Cpt(EpicsSignal, '_ENA:B0')\n    use2 = Cpt(EpicsSignal, '_ENA:B1')\n    use3 = Cpt(EpicsSignal, '_ENA:B2')\n    use4 = Cpt(EpicsSignal, '_ENA:B3')\n    input_source1 = Cpt(EpicsSignal, '_INP1')\n    input_source2 = Cpt(EpicsSignal, '_INP2')\n    input_source3 = Cpt(EpicsSignal, '_INP3')\n    input_source4 = Cpt(EpicsSignal, '_INP4')\n    invert1 = Cpt(EpicsSignal, '_INV:B0')\n    invert2 = Cpt(EpicsSignal, '_INV:B1')\n    invert3 = Cpt(EpicsSignal, '_INV:B2')\n    invert4 = Cpt(EpicsSignal, '_INV:B3')\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "SRXZebraAND",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/32-zebra.py",
    "source": "class SRXZebraAND(Device):\n    # I really appreciate the different indexing for input source\n    # Thank you for that\n    use1 = Cpt(EpicsSignal, '_ENA:B0')\n    use2 = Cpt(EpicsSignal, '_ENA:B1')\n    use3 = Cpt(EpicsSignal, '_ENA:B2')\n    use4 = Cpt(EpicsSignal, '_ENA:B3')\n    input_source1 = Cpt(EpicsSignal, '_INP1')\n    input_source2 = Cpt(EpicsSignal, '_INP2')\n    input_source3 = Cpt(EpicsSignal, '_INP3')\n    input_source4 = Cpt(EpicsSignal, '_INP4')\n    invert1 = Cpt(EpicsSignal, '_INV:B0')\n    invert2 = Cpt(EpicsSignal, '_INV:B1')\n    invert3 = Cpt(EpicsSignal, '_INV:B2')\n    invert4 = Cpt(EpicsSignal, '_INV:B3')\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()"
  },
  {
    "class_name": "ZebraPulse",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/32-zebra.py",
    "source": "class ZebraPulse(Device):\n    width = Cpt(EpicsSignalWithRBV, 'WID')\n    input_addr = Cpt(EpicsSignalWithRBV, 'INP')\n    input_str = Cpt(EpicsSignalRO, 'INP:STR', string=True)\n    input_status = Cpt(EpicsSignalRO, 'INP:STA')\n    delay = Cpt(EpicsSignalWithRBV, 'DLY')\n    delay_sync = Cpt(EpicsSignal, 'DLY:SYNC')\n    time_units = Cpt(EpicsSignalWithRBV, 'PRE', string=True)\n    output = Cpt(EpicsSignal, 'OUT')\n\n    input_edge = FC(EpicsSignal,\n                    '{self._zebra_prefix}POLARITY:{self._edge_addr}')\n\n    _edge_addrs = {1: 'BC',\n                   2: 'BD',\n                   3: 'BE',\n                   4: 'BF',\n                   }\n\n    def stage(self):\n        super().stage()\n\n    def unstage(self):\n        super().unstage()\n\n    def __init__(self, prefix, *, index=None, parent=None,\n                 configuration_attrs=None, read_attrs=None, **kwargs):\n        if read_attrs is None:\n            read_attrs = ['input_addr', 'input_edge', 'delay', 'width', 'time_units']\n        if configuration_attrs is None:\n            configuration_attrs = []\n\n        zebra = parent\n        self.index = index\n        self._zebra_prefix = zebra.prefix\n        self._edge_addr = self._edge_addrs[index]\n\n        super().__init__(prefix, configuration_attrs=configuration_attrs,\n                         read_attrs=read_attrs, parent=parent, **kwargs)"
  },
  {
    "class_name": "SRXFlyer1Axis",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/32-zebra.py",
    "source": "class SRXFlyer1Axis(Device):\n    \"\"\"\n    This is the flyer object for the Zebra.\n    This is the position based flyer.\n    \"\"\"\n\n    def root_path_str(self):\n        data_session = RE.md[\"data_session\"]\n        cycle = RE.md[\"cycle\"]\n        if \"Commissioning\" in get_proposal_type():\n            root_path = f\"/nsls2/data/srx/proposals/commissioning/{data_session}/assets/\"\n        else:\n            root_path = f\"/nsls2/data/srx/proposals/{cycle}/{data_session}/assets/\"\n        return root_path\n    \n\n    def make_filename(self):\n        \"\"\"Make a filename.\n        Taken/Modified from ophyd.areadetector.filestore_mixins\n        This is a hook so that the read and write paths can either be modified\n        or created on disk prior to configuring the areaDetector plugin.\n        Returns\n        -------\n        filename : str\n            The start of the filename\n        read_path : str\n            Path that ophyd can read from\n        write_path : str\n            Path that the IOC can write to\n        \"\"\"\n        filename = f'{new_short_uid()}.h5'\n        formatter = datetime.datetime.now().strftime\n        write_path = formatter(f'{self.root_path}{self.write_path_template}')\n        read_path = formatter(f'{self.root_path}{self.read_path_template}')\n        return filename, read_path, write_path\n\n    KNOWN_DETS = {\"xs\", \"xs2\", \"xs4\", \"merlin\", \"dexela\"}\n    fast_axis = Cpt(Signal, value=\"HOR\", kind=\"config\")\n    slow_axis = Cpt(Signal, value=\"VER\", kind=\"config\")\n    mode = Cpt(Signal, value='position', kind='config')\n\n    _staging_delay = 0.100  # used to be 10 ms, brute force this to work\n\n    @property\n    def encoder(self):\n        return self._encoder\n\n    @property\n    def detectors(self):\n        return tuple(self._dets)\n\n    @detectors.setter\n    def detectors(self, value):\n        dets = tuple(value)\n        if not all(d.name in self.KNOWN_DETS for d in dets):\n            raise ValueError(\n                f\"One or more of {[d.name for d in dets]}\"\n                f\"is not known to the zebra. \"\n                f\"The known detectors are {self.KNOWN_DETS})\"\n            )\n        self._dets = dets\n\n    @property\n    def sclr(self):\n        return self._sis\n\n    def __init__(self, dets, sclr1, zebra, *, reg=db.reg, **kwargs):\n        super().__init__(\"\", parent=None, **kwargs)\n        self._mode = \"idle\"\n        self._dets = dets\n        self._sis = sclr1\n        self._filestore_resource = None\n        self._encoder = zebra\n\n        self.root_path = self.root_path_str()\n        self.write_path_template=f'zebra/%Y/%m/%d/'\n        self.read_path_template=f'zebra/%Y/%m/%d/'\n        self.reg_root=f'zebra/'\n\n        # Put SIS3820 into single count (not autocount) mode\n        self.stage_sigs[self._sis.count_mode] = 0\n\n        # Stop the SIS3820\n        self._sis.stop_all.put(1)\n\n        self._encoder.pc.block_state_reset.put(1)\n        self.reg = reg\n        self._document_cache = []\n        self._last_bulk = None\n\n    def stage(self):\n        dir = self.fast_axis.get()\n        if dir == \"HOR\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc2\"\n            self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n        elif dir == \"VER\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc1\"\n            self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n        elif dir == \"DET2HOR\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc3\"\n            self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n        elif dir == \"DET2VER\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc4\"\n            self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n        elif dir == \"NANOHOR\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc1\"\n            self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n        elif dir == \"NANOVER\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc2\"\n            self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n        elif dir == \"NANOZ\":\n            self.stage_sigs[self._encoder.pc.enc] = \"Enc3\"\n            self.stage_sigs[self._encoder.pc.dir] = \"Positive\"\n\n        self._stage_with_delay()\n\n        self.root_path = self.root_path_str()\n\n\n    def _stage_with_delay(self):\n        # Staging taken from https://github.com/bluesky/ophyd/blob/master/ophyd/device.py\n        # Device - BlueskyInterface\n        \"\"\"Stage the device for data collection.\n        This method is expected to put the device into a state where\n        repeated calls to :meth:`~BlueskyInterface.trigger` and\n        :meth:`~BlueskyInterface.read` will 'do the right thing'.\n        Staging not idempotent and should raise\n        :obj:`RedundantStaging` if staged twice without an\n        intermediate :meth:`~BlueskyInterface.unstage`.\n        This method should be as fast as is feasible as it does not return\n        a status object.\n        The return value of this is a list of all of the (sub) devices\n        stage, including it's self.  This is used to ensure devices\n        are not staged twice by the :obj:`~bluesky.run_engine.RunEngine`.\n        This is an optional method, if the device does not need\n        staging behavior it should not implement `stage` (or\n        `unstage`).\n        Returns\n        -------\n        devices : list\n            list including self and all child devices staged\n        \"\"\"\n        if self._staged == Staged.no:\n            pass  # to short-circuit checking individual cases\n        elif self._staged == Staged.yes:\n            raise RedundantStaging(\"Device {!r} is already staged. \"\n                                   \"Unstage it first.\".format(self))\n        elif self._staged == Staged.partially:\n            raise RedundantStaging(\"Device {!r} has been partially staged. \"\n                                   \"Maybe the most recent unstaging \"\n                                   \"encountered an error before finishing. \"\n                                   \"Try unstaging again.\".format(self))\n        self.log.debug(\"Staging %s\", self.name)\n        self._staged = Staged.partially\n\n        # Resolve any stage_sigs keys given as strings: 'a.b' -> self.a.b\n        stage_sigs = OrderedDict()\n        for k, v in self.stage_sigs.items():\n            if isinstance(k, str):\n                # Device.__getattr__ handles nested attr lookup\n                stage_sigs[getattr(self, k)] = v\n            else:\n                stage_sigs[k] = v\n\n        # Read current values, to be restored by unstage()\n        original_vals = {sig: sig.get() for sig in stage_sigs}\n\n        # We will add signals and values from original_vals to\n        # self._original_vals one at a time so that\n        # we can undo our partial work in the event of an error.\n\n        # Apply settings.\n        devices_staged = []\n        try:\n            for sig, val in stage_sigs.items():\n                self.log.debug(\"Setting %s to %r (original value: %r)\",\n                               self.name,\n                               val, original_vals[sig])\n                sig.set(val, timeout=10).wait()\n                ttime.sleep(self._staging_delay)\n                # It worked -- now add it to this list of sigs to unstage.\n                self._original_vals[sig] = original_vals[sig]\n            ## TODO: THIS IS BAD\n            ## We should fix the underlying cause, and not resend all the commands\n            for sig, val in stage_sigs.items():\n                self.log.debug(\"Setting %s to %r (original value: %r)\",\n                               self.name,\n                               val, original_vals[sig])\n                sig.set(val, timeout=10).wait()\n                ttime.sleep(self._staging_delay)\n            devices_staged.append(self)\n\n            # Call stage() on child devices.\n            for attr in self._sub_devices:\n                device = getattr(self, attr)\n                if hasattr(device, 'stage'):\n                    device.stage()\n                    devices_staged.append(device)\n        except Exception:\n            self.log.debug(\"An exception was raised while staging %s or \"\n                           \"one of its children. Attempting to restore \"\n                           \"original settings before re-raising the \"\n                           \"exception.\", self.name)\n            self.unstage()\n            raise\n        else:\n            self._staged = Staged.yes\n        return devices_staged\n\n\n    def unstage(self):\n        self._unstage_with_delay()\n\n\n    def _unstage_with_delay(self):\n        # Staging taken from https://github.com/bluesky/ophyd/blob/master/ophyd/device.py\n        # Device - BlueskyInterface\n        \"\"\"Unstage the device.\n        This method returns the device to the state it was prior to the\n        last `stage` call.\n        This method should be as fast as feasible as it does not\n        return a status object.\n        This method must be idempotent, multiple calls (without a new\n        call to 'stage') have no effect.\n        Returns\n        -------\n        devices : list\n            list including self and all child devices unstaged\n        \"\"\"\n        self.log.debug(\"Unstaging %s\", self.name)\n        self._staged = Staged.partially\n        devices_unstaged = []\n\n        # Call unstage() on child devices.\n        for attr in self._sub_devices[::-1]:\n            device = getattr(self, attr)\n            if hasattr(device, 'unstage'):\n                device.unstage()\n                devices_unstaged.append(device)\n\n        # Restore original values.\n        for sig, val in reversed(list(self._original_vals.items())):\n            self.log.debug(\"Setting %s back to its original value: %r)\",\n                           self.name,\n                           val)\n            sig.set(val, timeout=10).wait()\n            ttime.sleep(self._staging_delay)\n            self._original_vals.pop(sig)\n        devices_unstaged.append(self)\n\n        self._staged = Staged.no\n        return devices_unstaged\n\n\n    def describe_collect(self):\n\n        ext_spec = \"FileStore:\"\n\n        spec = {\n            \"external\": ext_spec,\n            \"dtype\": \"array\",\n            \"shape\": [self._npts],\n            \"source\": \"\",  # make this the PV of the array the det is writing\n        }\n\n        desc = OrderedDict()\n        desc[\"zebra_time\"] = spec\n        desc[\"zebra_time\"][\"source\"] = getattr(self._encoder.pc.data, \"time\").pvname\n        desc[\"zebra_time\"][\"dtype_str\"] = \"<f4\"\n        # nanoZebra.pc.data.time.dtype_str = \"<f4\"\n\n        for chan in (\"enc1\", \"enc2\", \"enc3\"):\n            desc[chan] = spec\n            desc[chan][\"source\"] = getattr(self._encoder.pc.data, chan).pvname\n\n        # Handle the detectors we are going to get\n        for d in self._dets:\n            desc.update(d.describe())\n\n        # Handle the ion chamber that the zebra is collecting\n        desc[\"i0\"] = spec\n        desc[\"i0\"][\"source\"] = self._sis.mca2.pvname\n        desc[\"i0_time\"] = spec\n        desc[\"i0_time\"][\"source\"] = self._sis.mca1.pvname\n        desc[\"im\"] = spec\n        desc[\"im\"][\"source\"] = self._sis.mca3.pvname\n        desc[\"it\"] = spec\n        desc[\"it\"][\"source\"] = self._sis.mca4.pvname\n\n        return {\"stream0\": desc}\n\n    def kickoff(self, *, xstart, xstop, xnum, dwell, tacc):\n        dets_by_name = {d.name: d for d in self.detectors}\n        t_delay = 0.010  # delay after each write/put to zebra, this value is taken from _stage_with_delay\n\n        mode = self.mode.get()\n        # print(f'{mode=}')\n\n        self._encoder.pc.disarm.put(0)\n        ttime.sleep(t_delay)\n        self._mode = \"kicked off\"\n        self._npts = int(xnum)\n        if xstart < xstop:\n            direction = 1\n        else:\n            direction = -1\n        pxsize = np.abs(xstop - xstart) / (xnum - 1)\n        extent = np.abs(xstop - xstart) + pxsize\n        v = pxsize / dwell\n\n        if mode == 'position':\n            if 'dexela' in [d.name for d in self.detectors]:\n                decrement = (pxsize / dwell) * 0.001\n                decrement = np.max([decrement, 0.001])\n            else:\n                if dwell > 0.099:\n                    decrement = (pxsize / dwell) * 0.001\n                else:\n                    decrement = (pxsize / dwell) * 0.0001\n            # 0.1 ms delay between pulses\n            # decrement = (pxsize / dwell) * 0.001\n            if decrement < 1e-5:\n                print('Warning: Changing the pulse width!')\n                decrement = 1e-5\n        elif mode == 'time':\n            if 'dexela' in [d.name for d in self.detectors]:\n                decrement = 0.001\n            else:\n                decrement = 0.0002\n            # decrement = 0.0002\n\n        if mode == 'position':\n            self._encoder.pc.gate_start.put(xstart - direction * (pxsize / 2))\n            ttime.sleep(t_delay)\n            self._encoder.pc.gate_step.put(extent + 0.051)\n            ttime.sleep(t_delay)\n            self._encoder.pc.gate_width.put(extent + 0.050)\n            ttime.sleep(t_delay)\n        elif mode == 'time':\n            self._encoder.pc.gate_start.put(tacc + t_delay)\n            ttime.sleep(t_delay)\n            # self._encoder.pc.gate_step.put(extent / v)\n            self._encoder.pc.gate_step.put(extent / v + 0.100)\n            ttime.sleep(t_delay)\n            # self._encoder.pc.gate_width.put(extent / v + 0.050)\n            self._encoder.pc.gate_width.put(extent / v)\n            ttime.sleep(t_delay)\n\n\n        self._encoder.pc.pulse_start.put(0.0)\n        ttime.sleep(t_delay)\n        self._encoder.pc.pulse_max.put(xnum)\n        ttime.sleep(t_delay)\n        if mode == 'position':\n            self._encoder.pc.pulse_step.put(pxsize)\n            ttime.sleep(t_delay)\n            self._encoder.pc.pulse_width.put(pxsize - decrement)\n            ttime.sleep(t_delay)\n        elif mode == 'time':\n            self._encoder.pc.pulse_step.put(dwell)\n            ttime.sleep(t_delay)\n            self._encoder.pc.pulse_width.put(dwell - decrement)\n            ttime.sleep(t_delay)\n\n        # For dexela, we will use time triggering in a pixel, not position\n        # if \"dexela\" in dets_by_name:\n        #     self._encoder.output1.ttl.addr.put(52)\n        #     self._encoder.output3.ttl.addr.put(52)\n        #     self._encoder.pulse1.width.put(0.5 * dwell - 0.050)\n        # else:\n        #     self._encoder.output1.ttl.addr.put(31)\n        #     # self._encoder.output3.ttl.addr.put(31)\n        #     self._encoder.output3.ttl.addr.put(36)\n        #     self._encoder.pulse3.input_addr.put(31)\n        #     self._encoder.pulse4.input_addr.put(31)\n\n        self._encoder.pc.enc_pos1_sync.put(1)  # Scanner X\n        ttime.sleep(t_delay)\n        self._encoder.pc.enc_pos2_sync.put(1)  # Scanner Y\n        ttime.sleep(t_delay)\n        self._encoder.pc.enc_pos3_sync.put(1)  # Scanner Z\n        ttime.sleep(t_delay)\n        # self._encoder.pc.enc_pos4_sync.put(1)  # None\n\n        # Do a block reset on the zebra\n        # self._encoder.pc.block_state_reset.put(1)\n        # ttime.sleep(t_delay)\n\n        st = (\n            NullStatus()\n        )\n        # TODO Return a status object *first*\n        # and do the above asynchronously.\n        return st\n\n    def complete(self):\n        \"\"\"\n        Call this when all needed data has been collected. This has no idea\n        whether that is true, so it will obligingly stop immediately. It is\n        up to the caller to ensure that the motion is actually complete.\n        \"\"\"\n\n        amk_debug_flag = False\n\n        # Our acquisition complete PV is: XF:05IDD-ES:1{Dev:Zebra1}:ARRAY_ACQ\n        t0 = ttime.monotonic()\n        while self._encoder.pc.data_in_progress.get() == 1:\n            ttime.sleep(0.01)\n            if (ttime.monotonic() - t0) > 60:\n                print(f\"{self.name} is behaving badly!\")\n                print(f\"Number of points captured:   {self._encoder.pc.data.num_cap.get()}\")\n                print(f\"Number of points downloaded: {self._encoder.pc.data.num_down.get()}\")\n                self._encoder.pc.disarm.put(1)\n                ttime.sleep(0.100)\n                if self._encoder.pc.data_in_progress.get() == 1:\n                    print(\"Last row of data is lost :-(\")\n                    print(\"Aborting scan\")\n                    raise TimeoutError\n\n        # ttime.sleep(.1)\n        self._mode = \"complete\"\n        self._encoder.pc.block_state_reset.put(1)\n        # see triggering errors of the xspress3 on suspension.  This is\n        # to test the reset of the xspress3 after a line.\n\n        for d in self._dets:\n            d.stop(success=True)\n\n        # Set filename/path for zebra data\n        f, rp, wp = self.make_filename()\n        self.__filename = f\n        self.__read_filepath = os.path.join(rp, self.__filename)\n        self.__write_filepath = os.path.join(wp, self.__filename)\n        # Set filename/path for scaler data\n        f, rp, wp = self.make_filename()\n        self.__filename_sis = f\n        self.__read_filepath_sis = os.path.join(rp, self.__filename_sis)\n        self.__write_filepath_sis = os.path.join(wp, self.__filename_sis)\n        \n\n        self.__filestore_resource, datum_factory_z = resource_factory(\n            \"ZEBRA_HDF51\",\n            root=\"/\",\n            resource_path=self.__read_filepath,\n            resource_kwargs={},\n            path_semantics=\"posix\",\n        )\n        self.__filestore_resource_sis, datum_factory_sis = resource_factory(\n            \"SIS_HDF51\",\n            root=\"/\",\n            resource_path=self.__read_filepath_sis,\n            resource_kwargs={},\n            path_semantics=\"posix\",\n        )\n\n        time_datum = datum_factory_z({\"column\": \"zebra_time\"})\n        enc1_datum = datum_factory_z({\"column\": \"enc1\"})\n        enc2_datum = datum_factory_z({\"column\": \"enc2\"})\n        enc3_datum = datum_factory_z({\"column\": \"enc3\"})\n        sis_datum = datum_factory_sis({\"column\": \"i0\"})\n        sis_datum_im = datum_factory_sis({\"column\": \"im\"})\n        sis_datum_it = datum_factory_sis({\"column\": \"it\"})\n        sis_datum_time = datum_factory_sis({\"column\": \"sis_time\"})\n\n        self._document_cache.extend(\n            (\"resource\", d)\n            for d in (self.__filestore_resource, self.__filestore_resource_sis)\n        )\n        self._document_cache.extend(\n            (\"datum\", d)\n            for d in (\n                time_datum,\n                enc1_datum,\n                enc2_datum,\n                enc3_datum,\n                sis_datum,\n                sis_datum_time,\n                sis_datum_im,\n                sis_datum_it,\n            )\n        )\n\n        # grab the asset documents from all of the child detectors\n        for d in self._dets:\n            self._document_cache.extend(d.collect_asset_docs())\n\n        # Write the file.\n        # @timer_wrapper\n        def get_zebra_data():\n            if 'nano' in self.name:\n                export_nano_zebra_data(self._encoder, self.__write_filepath, self.fast_axis.get())\n            else:\n                export_zebra_data(self._encoder, self.__write_filepath, self.fast_axis)\n\n        if amk_debug_flag:\n            t_getzebradata = tic()\n        get_zebra_data()\n        if amk_debug_flag:\n            toc(t_getzebradata, str='Get Zebra data')\n\n        # @timer_wrapper\n        def get_sis_data():\n            export_sis_data(\n                self._sis, self.__write_filepath_sis, self._encoder\n            )\n\n        if amk_debug_flag:\n            t_sisdata = tic()\n        get_sis_data()\n        if amk_debug_flag:\n            toc(t_sisdata, str='Get SIS data')\n\n        # Yield a (partial) Event document. The RunEngine will put this\n        # into metadatastore, as it does all readings.\n        self._last_bulk = {\n            \"time\": ttime.time(),\n            \"seq_num\": 1,\n            \"data\": {\n                \"zebra_time\": time_datum[\"datum_id\"],\n                \"enc1\": enc1_datum[\"datum_id\"],\n                \"enc2\": enc2_datum[\"datum_id\"],\n                \"enc3\": enc3_datum[\"datum_id\"],\n                \"i0\": sis_datum[\"datum_id\"],\n                \"i0_time\": sis_datum_time[\"datum_id\"],\n                \"im\": sis_datum_im[\"datum_id\"],\n                \"it\": sis_datum_it[\"datum_id\"],\n            },\n            \"timestamps\": {\n                \"zebra_time\": time_datum[\"datum_id\"],  # not a typo#\n                \"enc1\": time_datum[\"datum_id\"],\n                \"enc2\": time_datum[\"datum_id\"],\n                \"enc3\": time_datum[\"datum_id\"],\n                \"i0\": sis_datum[\"datum_id\"],\n                \"i0_time\": sis_datum_time[\"datum_id\"],\n                \"im\": sis_datum_im[\"datum_id\"],\n                \"it\": sis_datum_it[\"datum_id\"],\n            },\n        }\n        for d in self._dets:\n            reading = d.read()\n            self._last_bulk[\"data\"].update(\n                {k: v[\"value\"] for k, v in reading.items()}\n                )\n            self._last_bulk[\"timestamps\"].update(\n                {k: v[\"timestamp\"] for k, v in reading.items()}\n            )\n\n        return NullStatus()\n\n    def collect(self):\n        # Create records in the FileStore database.\n        # move this to stage because I thinkt hat describe_collect needs the\n        # resource id\n        # TODO use ophyd.areadectector.filestoer_mixins.resllource_factory here\n        if self._last_bulk is None:\n            raise Exception(\n                \"the order of complete and collect is brittle and out \"\n                \"of sync. This device relies on in-order and 1:1 calls \"\n                \"between complete and collect to correctly create and stash \"\n                \"the asset registry documents\"\n            )\n        yield self._last_bulk\n        self._last_bulk = None\n        self._mode = \"idle\"\n\n    def collect_asset_docs(self):\n        yield from iter(list(self._document_cache))\n        self._document_cache.clear()\n\n    def stop(self):\n        self._encoder.pc.block_state_reset.put(1)\n        pass\n\n    def pause(self):\n        \"Pausing in the middle of a kickoff nukes the partial dataset.\"\n        self._encoder.pc.block_state_reset.put(1)\n        self._sis.stop_all.put(1)\n        for d in self._dets:\n            if hasattr(d, \"settings\"):\n                d.settings.acquire.put(0)\n            if hasattr(d, \"cam\"):\n                d.cam.acquire.put(0)\n        self._mode = \"idle\"\n        self.unstage()\n\n    def resume(self):\n        self.unstage()\n        self.stage()"
  },
  {
    "class_name": "InsertionDevice",
    "bases": [
      "Device",
      "PositionerBase"
    ],
    "file": "profile-collections/srx-profile-collection/startup/10-machine.py",
    "source": "class InsertionDevice(Device, PositionerBase):\n    gap = Cpt(EpicsMotor, \"-Ax:Gap}-Mtr\", kind=\"hinted\", name=\"\")\n    brake = Cpt(\n        EpicsSignal,\n        \"}BrakesDisengaged-Sts\",\n        write_pv=\"}BrakesDisengaged-SP\",\n        kind=\"omitted\",\n        add_prefix=(\"read_pv\", \"write_pv\", \"suffix\"),\n    )\n\n    # These are debugging values, not even connected to by default\n    elev = Cpt(EpicsSignalRO, \"-Ax:Elev}-Mtr.RBV\", kind=\"omitted\")\n    taper = Cpt(EpicsSignalRO, \"-Ax:Taper}-Mtr.RBV\", kind=\"omitted\")\n    tilt = Cpt(EpicsSignalRO, \"-Ax:Tilt}-Mtr.RBV\", kind=\"omitted\")\n    elev_u = Cpt(EpicsSignalRO, \"-Ax:E}-Mtr.RBV\", kind=\"omitted\")\n\n    def set(self, *args, **kwargs):\n        # set_and_wait(self.brake, 1) // deprecated\n        self.brake.set(1).wait()\n        return self.gap.set(*args, **kwargs)\n\n    def stop(self, *, success=False):\n        return self.gap.stop(success=success)\n\n    @property\n    def settle_time(self):\n        return self.gap.settle_time\n\n    @settle_time.setter\n    def settle_time(self, val):\n        self.gap.settle_time = val\n\n    @property\n    def timeout(self):\n        return self.gap.timeout\n\n    @timeout.setter\n    def timeout(self, val):\n        self.gap.timeout = val\n\n    @property\n    def egu(self):\n        return self.gap.egu\n\n    @property\n    def limits(self):\n        return self.gap.limits\n\n    @property\n    def low_limit(self):\n        return self.gap.low_limit\n\n    @property\n    def high_limit(self):\n        return self.gap.high_limit\n\n    def move(self, *args, moved_cb=None, **kwargs):\n        if moved_cb is not None:\n\n            @functools.wraps(moved_cb)\n            def inner_move(status, obj=None):\n                if obj is not None:\n                    obj = self\n                return moved_cb(status, obj=obj)\n\n        else:\n            inner_move = None\n        return self.set(*args, moved_cb=inner_move, **kwargs)\n\n    @property\n    def position(self):\n        return self.gap.position\n\n    @property\n    def moving(self):\n        return self.gap.moving\n\n    def subscribe(self, callback, *args, **kwargs):\n        @functools.wraps(callback)\n        def inner(obj, **kwargs):\n            return callback(obj=self, **kwargs)\n\n        return self.gap.subscribe(inner, *args, **kwargs)"
  },
  {
    "class_name": "SRXSlitsFE",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/10-machine.py",
    "source": "class SRXSlitsFE(Device):\n    top = Cpt(EpicsMotor, \"3-Ax:T}Mtr\")\n    bot = Cpt(EpicsMotor, \"4-Ax:B}Mtr\")\n    inb = Cpt(EpicsMotor, \"3-Ax:I}Mtr\")\n    out = Cpt(EpicsMotor, \"4-Ax:O}Mtr\")"
  },
  {
    "class_name": "FlyScanControl",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/10-machine.py",
    "source": "class FlyScanControl(Device):\n    control = Cpt(EpicsSignal, write_pv='MACROControl-SP', read_pv='MACROControl-RB',\n                  add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    status = Cpt(EpicsSignalRO, 'MACRO-Sts')\n    reset = Cpt(EpicsSignal, 'MACRO-CLRF.PROC')\n\n    def set(self, command):\n        allowed_commands = {\"enable\", \"disable\"}\n        ENABLED_VALUE = 5\n        DISABLED_VALUE = 10\n\n        def _int_round(value):\n            return int(round(value))\n\n        if command == \"enable\":\n            def enable_callback(value, old_value, **kwargs):\n                # print(f'{print_now()} in {self.name}/{command}: {old_value} ---> {value}')\n                value = _int_round(value)\n                old_value = _int_round(old_value)\n                if value == ENABLED_VALUE:\n                    return True\n                return False\n            status = SubscriptionStatus(self.control, enable_callback, run=False)\n            self.control.put(1)\n            return status\n\n        elif command == \"disable\":\n            def disable_callback(value, old_value, **kwargs):\n                # print(f'{print_now()} in {self.name}/{command}: {old_value} ---> {value}')\n                value = _int_round(value)\n                old_value = _int_round(old_value)\n                if value == DISABLED_VALUE:\n                    return True\n                return False\n            status = SubscriptionStatus(self.control, disable_callback, run=False)\n            self.control.put(0)\n            return status\n        else:\n            raise ValueError(f\"Unknown command: {command}. \"\n                             f\"Allowed commands: {allowed_commands}\")\n\n    scan_type = Cpt(EpicsSignal, write_pv='FlyScan-Type-SP', read_pv='FlyScan-Type-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    run = Cpt(EpicsSignal, 'FlyScan-MvReq-Cmd.PROC')\n    abort = Cpt(EpicsSignal, 'FlyScan-Mtr.STOP')\n    moving = Cpt(EpicsSignalRO, 'FlyScan-Mtr.MOVN')\n    scan_in_progress = Cpt(EpicsSignalRO, 'FlyScan-Running-Sts')\n\n    energy_lut = Cpt(EpicsSignal, write_pv='FlyLUT-Energy-SP', read_pv='FlyLUT-Energy-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    gap_lut = Cpt(EpicsSignal, write_pv='FlyLUT-Gap-SP', read_pv='FlyLUT-Gap-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    # After the LUT are updated, the calc_spline should be called.\n    calc_spline = Cpt(EpicsSignal, 'CalculateSpline.PROC')\n    spline_status = Cpt(EpicsSignalRO, 'FlySplineOK-RB')"
  },
  {
    "class_name": "FlyScanParameters",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/10-machine.py",
    "source": "class FlyScanParameters(Device):\n    harmonic = Cpt(EpicsSignal, write_pv='SR:C5-ID:G1{IVU21:1}FlyHarmonic-SP', read_pv='SR:C5-ID:G1{IVU21:1}FlyHarmonic-RB', add_prefix=(), put_complete=True)\n\n    speed = Cpt(EpicsSignal, write_pv='-Speed-SP', read_pv='-Speed-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    first_trigger = Cpt(EpicsSignal, write_pv='First-SP', read_pv='First-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    last_trigger = Cpt(EpicsSignal,  write_pv='Last-SP', read_pv='Last-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    num_triggers = Cpt(EpicsSignal, write_pv='NTriggers-SP', read_pv='NTriggers-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    trigger_width = Cpt(EpicsSignal, write_pv='TriggerWidth-SP', read_pv='TriggerWidth-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    id_energy_offset = Cpt(EpicsSignal, write_pv='IDOffset_eV-SP', read_pv='IDOffset_eV-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    timing_offset = Cpt(EpicsSignal, write_pv='TriggerOffset-SP', read_pv='TriggerOffset-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    trigger_count = Cpt(EpicsSignalRO, 'TriggerCount-RB')\n    trigger_count_reset = Cpt(EpicsSignal, 'TriggerCount-Reset.PROC')\n    num_scans = Cpt(EpicsSignal, write_pv='NScans-SP', read_pv='NScans-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    current_scan = Cpt(EpicsSignalRO, 'IScan-RB')\n    current_scan_reset = Cpt(EpicsSignal, 'IScan-Reset.PROC')\n    dwell_time = Cpt(EpicsSignal, write_pv='DwellTime-SP', read_pv='DwellTime-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    paused_timeout = Cpt(EpicsSignal, write_pv='PausedTimeout-SP', read_pv='PausedTimeout-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    scan_paused = Cpt(EpicsSignal, write_pv='Paused-SP', read_pv='Paused-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)"
  },
  {
    "class_name": "HDCMParameters",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/10-machine.py",
    "source": "class HDCMParameters(Device):\n    # 'ang' is for Angstrom, not angle\n    ang_over_ev = Cpt(EpicsSignal, write_pv='AngOverEv-SP', read_pv='AngOverEv-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    d111 = Cpt(EpicsSignal, write_pv='d111-SP', read_pv='d111-SP', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    delta_bragg = Cpt(EpicsSignal, write_pv='DeltaBragg-SP', read_pv='DeltaBragg-SP', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    c2x_cal = Cpt(EpicsSignal, write_pv='C2XCal-SP', read_pv='C2XCal-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    t2_cal = Cpt(EpicsSignal, write_pv='T2Cal-SP', read_pv='T2Cal-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)\n    x_offset = Cpt(EpicsSignal, write_pv='XOffset-SP', read_pv='XOffset-RB', add_prefix=('read_pv', 'write_pv'), put_complete=True)"
  },
  {
    "class_name": "IDFlyDevice",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/10-machine.py",
    "source": "class IDFlyDevice(Device):\n    # Fly scan control\n    control = Cpt(FlyScanControl, '')\n\n    parameters = Cpt(FlyScanParameters, 'EScan')\n\n    hdcm_parameters = Cpt(HDCMParameters, 'Fly_')\n\n    # Fly scan parameters\n    energy_motor = Cpt(EpicsMotor, 'FlyScan-Mtr')\n    id_energy = Cpt(EpicsSignal, 'FlyEnergyID-RB')"
  },
  {
    "class_name": "BPMStats",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/20-diagnostics.py",
    "source": "class BPMStats(Device):\n    tot1 = Cpt(EpicsSignal, 'Stats1:Total_RBV')\n    tot2 = Cpt(EpicsSignal, 'Stats2:Total_RBV')\n    tot3 = Cpt(EpicsSignal, 'Stats3:Total_RBV')\n    tot4 = Cpt(EpicsSignal, 'Stats4:Total_RBV')"
  },
  {
    "class_name": "BPMDiode",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/20-diagnostics.py",
    "source": "class BPMDiode(Device):\n    \"Beam Position Monitor Diode\"\n    diode0 = Cpt(EpicsSignalRO, '_Ch1')\n    diode1 = Cpt(EpicsSignalRO, '_Ch2')\n    diode2 = Cpt(EpicsSignalRO, '_Ch3')\n    diode3 = Cpt(EpicsSignalRO, '_Ch4')\n    # femto = EpicsSignal('XF:05IDA-BI:1{IM:1}Int-I')\n\n    def trigger(self):\n        # There is nothing to do. Just report that we are done.\n        # Note: This really should not necessary to do --\n        # future changes to PVPositioner may obviate this code.\n        status = StatusBase()\n        status._finished()\n        return status"
  },
  {
    "class_name": "DiamondBPM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/20-diagnostics.py",
    "source": "class DiamondBPM(Device):\n    diode_top = Cpt(EpicsSignalRO, 'Current1:MeanValue_RBV')\n    diode_inb = Cpt(EpicsSignalRO, 'Current2:MeanValue_RBV')\n    diode_out = Cpt(EpicsSignalRO, 'Current3:MeanValue_RBV')\n    diode_bot = Cpt(EpicsSignalRO, 'Current4:MeanValue_RBV')\n    sigma_top = Cpt(EpicsSignalRO, 'Current1:Sigma_RBV')\n    sigma_inb = Cpt(EpicsSignalRO, 'Current2:Sigma_RBV')\n    sigma_out = Cpt(EpicsSignalRO, 'Current3:Sigma_RBV')\n    sigma_bot = Cpt(EpicsSignalRO, 'Current4:Sigma_RBV')\n    x_pos = Cpt(EpicsSignalRO, 'PosX:MeanValue_RBV')\n    y_pos = Cpt(EpicsSignalRO, 'PosY:MeanValue_RBV')\n    x_sigma = Cpt(EpicsSignalRO, 'PosX:Sigma_RBV')\n    y_sigma = Cpt(EpicsSignalRO, 'PosY:Sigma_RBV')"
  },
  {
    "class_name": "SlitDrainCurrent",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/20-diagnostics.py",
    "source": "class SlitDrainCurrent(Device):\n    t = Cpt(EpicsSignalRO, 'Current1:MeanValue_RBV')\n    b = Cpt(EpicsSignalRO, 'Current2:MeanValue_RBV')\n    i = Cpt(EpicsSignalRO, 'Current3:MeanValue_RBV')\n    o = Cpt(EpicsSignalRO, 'Current4:MeanValue_RBV')\n\n    def trigger(self):\n        # There is nothing to do. Just report that we are done.\n        # Note: This really should not necessary to do --\n        # future changes to PVPositioner may obviate this code.\n        status = StatusBase()\n        status._finished()\n        return status"
  },
  {
    "class_name": "BPM_TetrAMM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/20-diagnostics.py",
    "source": "class BPM_TetrAMM(Device):\n    \"Beam Position Monitor Foil\"\n    channel1 = Cpt(EpicsSignalRO, 'Current1:MeanValue_RBV', kind=Kind.omitted)\n    channel2 = Cpt(EpicsSignalRO, 'Current2:MeanValue_RBV', kind=Kind.omitted)\n    channel3 = Cpt(EpicsSignalRO, 'Current3:MeanValue_RBV', kind=Kind.omitted)\n    channel4 = Cpt(EpicsSignalRO, 'Current4:MeanValue_RBV', kind=Kind.omitted)\n\n    x = Cpt(EpicsSignalRO, 'PosX:MeanValue_RBV')\n    y = Cpt(EpicsSignalRO, 'PosY:MeanValue_RBV')\n    total_current = Cpt(EpicsSignalRO, 'SumAll:MeanValue_RBV')"
  },
  {
    "class_name": "HACK_SRX_NSLS_EM",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/20-diagnostics.py",
    "source": "class HACK_SRX_NSLS_EM(Device):\n    current1 = Cpt(EpicsSignalRO, 'Current1:MeanValue_RBV')\n    current2 = Cpt(EpicsSignalRO, 'Current2:MeanValue_RBV')\n    current3 = Cpt(EpicsSignalRO, 'Current3:MeanValue_RBV')\n    current4 = Cpt(EpicsSignalRO, 'Current4:MeanValue_RBV')\n\n    sumX = Cpt(EpicsSignalRO, 'SumX:MeanValue_RBV')\n    sumY = Cpt(EpicsSignalRO, 'SumY:MeanValue_RBV')\n    sumT = Cpt(EpicsSignalRO, 'SumAll:MeanValue_RBV')\n    diffX = Cpt(EpicsSignalRO, 'DiffX:MeanValue_RBV')\n    diffY = Cpt(EpicsSignalRO, 'DiffY:MeanValue_RBV')\n    posX = Cpt(EpicsSignalRO, 'PosX:MeanValue_RBV')\n    posY = Cpt(EpicsSignalRO, 'PosY:MeanValue_RBV')\n\n    bias = Cpt(EpicsSignal, 'DAC3')\n\n    xmotor = Cpt(EpicsMotor, 'XF:05IDD-ES:1{Stg:Xbpm-Ax:X}Mtr', add_prefix=(), name='xmotor')\n    ymotor = Cpt(EpicsMotor, 'XF:05IDD-ES:1{Stg:Xbpm-Ax:Y}Mtr', add_prefix=(), name='ymotor')\n\n    def _balanceX(self):\n        return (np.abs(self.sumX.get()) - np.abs(self.diffX.get())) / np.abs(self.sumX.get())\n\n    def _balanceY(self):\n        return (np.abs(self.sumY.get()) - np.abs(self.diffY.get())) / np.abs(self.sumY.get())\n\n    @property\n    def balanceX(self, name='xbpm2_balanceX'):\n       return self._balanceX()\n\n    @property\n    def balanceY(self):\n       return self._balanceY()\n\n    @property\n    def balance(self):\n       return np.sqrt(np.power(self.balanceX(), 2) + np.power(self.balanceY(), 2)) / np.sqrt(2)"
  },
  {
    "class_name": "ScalerPreAmp",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/20-diagnostics.py",
    "source": "class ScalerPreAmp(Device):\n    _DEFAULT_TIMEOUT = 2\n\n    sens_num = Cpt(EpicsSignal, 'sens_num', string=True, timeout=_DEFAULT_TIMEOUT) # XF:05IDD-CT{SR570:N}sens_num\n    sens_unit = Cpt(EpicsSignal, 'sens_unit', string=True, timeout=_DEFAULT_TIMEOUT) # XF:05IDD-CT{SR570:N}sens_unit\n    offset_on = Cpt(EpicsSignal, 'offset_on', string=True, timeout=_DEFAULT_TIMEOUT) # XF:05IDD-CT{SR570:N}offset_on\n    offset_sign = Cpt(EpicsSignal, 'offset_sign', string=True, timeout=_DEFAULT_TIMEOUT) # XF:05IDD-CT{SR570:N}offset_sign\n    offset_num = Cpt(EpicsSignal, 'offset_num', string=True, timeout=_DEFAULT_TIMEOUT) # XF:05IDD-CT{SR570:N}offset_num\n    offset_unit = Cpt(EpicsSignal, 'offset_unit', string=True, timeout=_DEFAULT_TIMEOUT) # XF:05IDD-CT{SR570:N}offset_unit\n    invert = Cpt(EpicsSignal, 'invert_on', string=True, timeout=_DEFAULT_TIMEOUT)  # XF:05IDD-CT{SR570:N}invert_on\n    off_u_put = Cpt(EpicsSignal, 'off_u_put', kind=Kind.omitted) # XF:05IDD-CT{SR570:N}off_u_put\n    offset_u_tweak = Cpt(EpicsSignal, 'offset_u_tweak', kind=Kind.omitted) # XF:05IDD-CT{SR570:N}offset_u_tweak\n    offset_cal = Cpt(EpicsSignal, 'offset_cal', kind=Kind.omitted)"
  },
  {
    "class_name": "ZebraSaver",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/29-zebra-h5-saver.py",
    "source": "class ZebraSaver(Device):\n    # Saving business logic:\n    write_dir = Cpt(EpicsSignal, \"write_dir\", string=True)\n    file_name = Cpt(EpicsSignal, \"file_name\", string=True)\n    full_file_path = Cpt(EpicsSignalRO, \"full_file_path\")\n\n    acquire = Cpt(EpicsSignal, \"acquire\", string=True)\n    file_stage = Cpt(EpicsSignal, \"stage\")\n\n\n    dev_type = Cpt(EpicsSignal, \"dev_type\")\n\n    # Zebra-related PVs:\n    enc1 = Cpt(EpicsSignal, \"enc1\")\n    enc2 = Cpt(EpicsSignal, \"enc2\")\n    enc3 = Cpt(EpicsSignal, \"enc3\")\n    zebra_time = Cpt(EpicsSignal, \"zebra_time\")\n\n    # Scaler-related PVs:\n    i0 = Cpt(EpicsSignal, \"i0\")\n    im = Cpt(EpicsSignal, \"im\")\n    it = Cpt(EpicsSignal, \"it\")\n    sis_time = Cpt(EpicsSignal, \"sis_time\")"
  },
  {
    "class_name": "EpicsSignalROLazyier",
    "bases": [
      "EpicsSignalRO"
    ],
    "file": "profile-collections/srx-profile-collection/startup/30-scaler.py",
    "source": "class EpicsSignalROLazyier(EpicsSignalRO):\n    def get(self, *args, timeout=5, **kwargs):\n        return super().get(*args, timeout=timeout, **kwargs)"
  },
  {
    "class_name": "SRXNanoKB",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/16-nanoES.py",
    "source": "class SRXNanoKB(Device):\n    # XF:05IDD-ES:1{nKB:vert-Ax:Y}Mtr.RBV\n    v_y = Cpt(EpicsMotor, 'vert-Ax:Y}Mtr')\n    # XF:05IDD-ES:1{nKB:vert-Ax:PC}RPOS\n    v_pitch = Cpt(SRXNanoKBCoarse,\n                  'XF:05IDD-ES:1{nKB:vert-Ax:PC}',\n                  name='nanoKB_v_pitch',\n                  add_prefix=())  \n    # XF:05IDD-ES:1{nKB:horz-Ax:PC}Mtr.RBV\n    v_pitch_um = Cpt(EpicsMotor, 'vert-Ax:PC}Mtr')\n    # XF:05IDD-ES:1{nKB:vert-Ax:PFPI}Mtr.RBV\n    v_pitch_fine = Cpt(EpicsMotor,\n                       \"XF:05IDD-ES:1{nKB:vert-Ax:PFPI}Mtr\",\n                       name=\"v_pitch_fine\",\n                       add_prefix=\"\")\n    # XF:05IDD-ES:1{nKB:horz-Ax:X}Mtr.RBV\n    h_x = Cpt(EpicsMotor, 'horz-Ax:X}Mtr')\n    # XF:05IDD-ES:1{nKB:horz-Ax:PC}RPOS\n    h_pitch = Cpt(SRXNanoKBCoarse,\n                  'XF:05IDD-ES:1{nKB:horz-Ax:PC}',\n                  name='nanoKB_h_pitch',\n                  add_prefix=())\n    # XF:05IDD-ES:1{nKB:vert-Ax:PC}Mtr.RBV\n    h_pitch_um = Cpt(EpicsMotor, 'horz-Ax:PC}Mtr')\n    # XF:05IDD-ES:1{nKB:horz-Ax:PFPI}Mtr.RBV\n    h_pitch_fine = Cpt(EpicsMotor,\n                       \"XF:05IDD-ES:1{nKB:horz-Ax:PFPI}Mtr\",\n                       name=\"h_pitch_fine\",\n                       add_prefix=\"\")"
  },
  {
    "class_name": "SRXNanoStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/16-nanoES.py",
    "source": "class SRXNanoStage(Device):\n    # x = Cpt(EpicsMotor, 'sx}Mtr')  # XF:05IDD-ES:1{nKB:Smpl-Ax:sx}Mtr.RBV\n    y = Cpt(EpicsMotor, 'sy}Mtr')  # XF:05IDD-ES:1{nKB:Smpl-Ax:sy}Mtr.RBV\n    z = Cpt(EpicsMotor, 'sz}Mtr')  # XF:05IDD-ES:1{nKB:Smpl-Ax:sz}Mtr.RBV\n    sx = Cpt(EpicsMotor, 'ssx}Mtr')  # XF:05IDD-ES:1{nKB:Smpl-Ax:ssx}Mtr.RBV\n    sy = Cpt(EpicsMotor, 'ssy}Mtr')  # XF:05IDD-ES:1{nKB:Smpl-Ax:ssy}Mtr.RBV\n    sz = Cpt(EpicsMotor, 'ssz}Mtr')  # XF:05IDD-ES:1{nKB:Smpl-Ax:ssz}Mtr.RBV\n    th = Cpt(EpicsMotor, 'th}Mtr')  # XF:05IDD-ES:1{nKB:Smpl-Ax:th}Mtr.RBV\n    topx = Cpt(EpicsMotor, 'xth}Mtr')"
  },
  {
    "class_name": "SRXNanoVLMStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/16-nanoES.py",
    "source": "class SRXNanoVLMStage(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr')  # XF:05IDD-ES:1{nKB:VLM-Ax:X}Mtr.RBV\n    y = Cpt(EpicsMotor, 'Y}Mtr')\n    z = Cpt(EpicsMotor, 'Z}Mtr')"
  },
  {
    "class_name": "SRXNanoDet",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/16-nanoES.py",
    "source": "class SRXNanoDet(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr')  # XF:05IDD-ES:1{nKB:Det-Ax:X}Mtr.RBV\n    y = Cpt(EpicsMotor, 'Y}Mtr')  # XF:05IDD-ES:1{nKB:Det-Ax:Y}Mtr.RBV\n    z = Cpt(EpicsMotor, 'Z}Mtr')  # XF:05IDD-ES:1{nKB:Det-Ax:Z}Mtr.RBV\n    sample2detector = Cpt(EpicsSignalRO,\n                          \"XF:05IDD-ES:1{nKB:Det-Ax:Dist}MTR:RBV\",\n                          name=\"sample2detector\",\n                          add_prefix=\"\")"
  },
  {
    "class_name": "SRXNanoTemp",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/16-nanoES.py",
    "source": "class SRXNanoTemp(Device):\n    temp_nanoKB_horz = Cpt(EpicsSignalRO, '2}T:C-I')\n    temp_nanoKB_vert = Cpt(EpicsSignalRO, '1}T:C-I')\n    temp_nanoKB_base = Cpt(EpicsSignalRO, '4}T:C-I')\n    temp_room = Cpt(EpicsSignalRO, '3}T:C-I')"
  },
  {
    "class_name": "SRXNanoKBInterferometer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/16-nanoES.py",
    "source": "class SRXNanoKBInterferometer(Device):\n    posX = Cpt(EpicsSignalRO, 'Chan0}Pos-I')\n    posY = Cpt(EpicsSignalRO, 'Chan1}Pos-I')\n    posZ = Cpt(EpicsSignalRO, 'Chan2}Pos-I')"
  },
  {
    "class_name": "SRXNanoStageInterferometer",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/16-nanoES.py",
    "source": "class SRXNanoStageInterferometer(Device):\n    posX = Cpt(EpicsSignalRO, 'POS_0')\n    posY = Cpt(EpicsSignalRO, 'POS_1')\n    posZ = Cpt(EpicsSignalRO, 'POS_2')"
  },
  {
    "class_name": "HFETomoStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/18-tempstages.py",
    "source": "class HFETomoStage(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr')\n    y = Cpt(EpicsMotor, 'Y}Mtr')"
  },
  {
    "class_name": "XFMstage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/18-tempstages.py",
    "source": "class XFMstage(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr')\n    y = Cpt(EpicsMotor, 'Y}Mtr')\n    z = Cpt(EpicsMotor, 'Z}Mtr')"
  },
  {
    "class_name": "XFMslit",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/18-tempstages.py",
    "source": "class XFMslit(Device):\n    h_trans = Cpt(EpicsMotor, 'HT}Mtr')\n    h_gap = Cpt(EpicsMotor, 'HA}Mtr')\n    v_trans = Cpt(EpicsMotor, 'VT}Mtr')\n    v_gap = Cpt(EpicsMotor, 'VA}Mtr')"
  },
  {
    "class_name": "DexelaBeamstop",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/18-tempstages.py",
    "source": "class DexelaBeamstop(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr')\n    y = Cpt(EpicsMotor, 'Y}Mtr')"
  },
  {
    "class_name": "SRXJJSlits",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/15-microES.py",
    "source": "class SRXJJSlits(Device):\n    h_gap = Cpt(EpicsMotor, 'HA}Mtr')\n    h_trans = Cpt(EpicsMotor, 'HT}Mtr')\n    v_gap = Cpt(EpicsMotor, 'VA}Mtr')\n    v_trans = Cpt(EpicsMotor, 'VT}Mtr')"
  },
  {
    "class_name": "SRXAttenuators",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/15-microES.py",
    "source": "class SRXAttenuators(Device):\n    Al_050um = Cpt(EpicsSignal, '8-Cmd')  # XF:05IDD-ES{IO:4}DO:8-Cmd\n    Al_100um = Cpt(EpicsSignal, '7-Cmd')  # XF:05IDD-ES{IO:4}DO:7-Cmd\n    Al_250um = Cpt(EpicsSignal, '6-Cmd')  # XF:05IDD-ES{IO:4}DO:6-Cmd\n    Al_500um = Cpt(EpicsSignal, '5-Cmd')  # XF:05IDD-ES{IO:4}DO:5-Cmd\n    Si_250um = Cpt(EpicsSignal, '2-Cmd')  # XF:05IDD-ES{IO:4}DO:2-Cmd\n    Si_650um = Cpt(EpicsSignal, '1-Cmd')"
  },
  {
    "class_name": "HFSampleStage",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/15-microES.py",
    "source": "class HFSampleStage(Device):\n    x = Cpt(EpicsMotor, '{Stg:Smpl2-Ax:X}Mtr')\n    y = Cpt(EpicsMotor, '{Stg:Smpl2-Ax:Y}Mtr')\n    z = Cpt(EpicsMotor, '{Stg:Smpl1-Ax:Z}Mtr')\n    th = Cpt(EpicsMotor, '{Smpl:1-Ax:Rot}Mtr')\n    topx = Cpt(EpicsMotor, '{Smpl:1-Ax:XF}Mtr')\n    topz = Cpt(EpicsMotor, '{Smpl:1-Ax:ZF}Mtr')\n\n    RETRY_DEADBAND_X = Cpt(EpicsSignal,\n                           'XF:05IDD-ES:1{Stg:Smpl2-Ax:X}Mtr.RDBD',\n                           add_prefix=())\n    RETRY_DEADBAND_Y = Cpt(EpicsSignal,\n                           'XF:05IDD-ES:1{Stg:Smpl2-Ax:Y}Mtr.RDBD',\n                           add_prefix=())\n    _RETRY_DEADBAND_DEFAULT = 0.0001\n\n    BACKLASH_SPEED_X = Cpt(EpicsSignal,\n                           'XF:05IDD-ES:1{Stg:Smpl2-Ax:X}Mtr.BVEL',\n                           add_prefix=())\n    BACKLASH_SPEED_Y = Cpt(EpicsSignal,\n                           'XF:05IDD-ES:1{Stg:Smpl2-Ax:Y}Mtr.BVEL',\n                           add_prefix=())\n    _BACKLASH_SPEED_DEFAULT = 0.1\n\n    def reset_stage_defaults(self):\n        yield from mv(self.RETRY_DEADBAND_X, self._RETRY_DEADBAND_DEFAULT,\n                      self.RETRY_DEADBAND_Y, self._RETRY_DEADBAND_DEFAULT,\n                      self.BACKLASH_SPEED_X, self._BACKLASH_SPEED_DEFAULT,\n                      self.BACKLASH_SPEED_Y, self._BACKLASH_SPEED_DEFAULT)"
  },
  {
    "class_name": "SRXDownStreamGantry",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/15-microES.py",
    "source": "class SRXDownStreamGantry(Device):\n    x = Cpt(EpicsMotor, 'X}Mtr')\n    y = Cpt(EpicsMotor, 'Y}Mtr')\n    z = Cpt(EpicsMotor, 'Z}Mtr')\n    focus = Cpt(EpicsMotor, 'Foc}Mtr')"
  },
  {
    "class_name": "SRXScanRecord",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/40-scanutils.py",
    "source": "class SRXScanRecord(Device):\n\n    class OneScan(Device):\n        p1s = Cpt(EpicsSignal, 'P1-S')\n        p2s = Cpt(EpicsSignal, 'P2-S')\n        p1i = Cpt(EpicsSignal, 'P1-I')\n        p2i = Cpt(EpicsSignal, 'P2-I')\n        p1stp = Cpt(EpicsSignal, 'P1-STP')\n        p2stp = Cpt(EpicsSignal, 'P2-STP')\n        p1npts = Cpt(EpicsSignalRO, 'P1-NPTS')\n        p2npts = Cpt(EpicsSignalRO, 'P2-NTPS')\n        p1e = Cpt(EpicsSignalRO, 'P1-E')\n        p2e = Cpt(EpicsSignalRO, 'P2-E')\n        p1ena = Cpt(EpicsSignal, 'P1-ENA')\n        p2ena = Cpt(EpicsSignal, 'P2-ENA')\n        curpt = Cpt(EpicsSignal, 'CURPT')\n        npts = Cpt(EpicsSignalRO, 'NPTS')\n        tpp = Cpt(EpicsSignal, 'TPP')\n        ena = Cpt(EpicsSignal, 'ENA')\n        acq = Cpt(EpicsSignal, 'ACQ')\n        e1s = Cpt(EpicsSignal, 'E1-S')\n        e1i = Cpt(EpicsSignal, 'E1-I')\n        e1npts = Cpt(EpicsSignal, 'E1-NPTS')\n        e1e = Cpt(EpicsSignal, 'E1-E')\n        e2s = Cpt(EpicsSignal, 'E2-S')\n        e2i = Cpt(EpicsSignal, 'E2-I')\n        e2npts = Cpt(EpicsSignal, 'E2-NPTS')\n        e2e = Cpt(EpicsSignal, 'E2-E')\n        e3s = Cpt(EpicsSignal, 'E3-S')\n        e3i = Cpt(EpicsSignal, 'E3-I')\n        e3npts = Cpt(EpicsSignal, 'E3-NPTS')\n        e3e = Cpt(EpicsSignal, 'E3-E')\n        efs = Cpt(EpicsSignal, 'EF-S')\n        Eena = Cpt(EpicsSignal, 'E-ENA')\n        Ewait = Cpt(EpicsSignal, 'E-WAIT')\n        filename = Cpt(EpicsSignal, 'FILEN')\n        sampname = Cpt(EpicsSignal, 'SAMPN')\n        roi = Cpt(EpicsSignal, 'ROIN')\n        detune = Cpt(EpicsSignal, 'DETUNE')\n\n#    scans = [ Cpt(OneScan,'Scan'+str(i)+':') for i in range(0,8) ]\n    scan0 = Cpt(OneScan, 'Scan0:')\n    scan1 = Cpt(OneScan, 'Scan1:')\n    scan2 = Cpt(OneScan, 'Scan2:')\n    scan3 = Cpt(OneScan, 'Scan3:')\n    scan4 = Cpt(OneScan, 'Scan4:')\n    scan5 = Cpt(OneScan, 'Scan5:')\n    scan6 = Cpt(OneScan, 'Scan6:')\n    scan7 = Cpt(OneScan, 'Scan7:')\n    scan8 = Cpt(OneScan, 'Scan8:')\n    scan9 = Cpt(OneScan, 'Scan9:')\n    scan10 = Cpt(OneScan, 'Scan10:')\n    scan11 = Cpt(OneScan, 'Scan11:')\n    scan12 = Cpt(OneScan, 'Scan12:')\n    scan13 = Cpt(OneScan, 'Scan13:')\n    scan14 = Cpt(OneScan, 'Scan14:')\n    scan15 = Cpt(OneScan, 'Scan15:')\n\n    def cp(self, src, dest):\n        '''\n        Copy all elements of the scan object from src to dest.\n        src and dest must be the string names of the scans\n        scans are indexed starting at 0\n        '''\n        for i in ['p1s', 'p2s', 'p1i', 'p2i', 'p1stp', 'p2stp',\n                  'p1ena', 'p2ena', 'curpt', 'tpp', 'ena', 'acq',\n                  'e1s', 'e1i', 'e1npts', 'e1e', 'e2s', 'e2i', 'e2npts', 'e2e',\n                  'e3s', 'e3i', 'e3npts', 'e3e', 'efs', 'Eena', 'Ewait',\n                  'filename', 'sampname', 'roi', 'detune']:\n            getattr(getattr(self, dest), i).put(getattr(getattr(scanrecord, src), i).get())\n\n    def cp_XANES(self, src_num, dest_num):\n        '''\n        Copy all energy elements of scan number src_num to scan number dest_num\n        scan numbers are indexed starting at 1\n        '''\n        src = 'scan{}'.format(src_num-1)\n        dest = 'scan{}'.format(dest_num-1)\n        for i in ['p1s', 'p2s', 'p1i', 'p2i', 'p1stp', 'p2stp',\n                  'p1ena', 'p2ena', 'curpt', 'tpp', 'ena', 'acq',\n                  'e1s', 'e1i', 'e1npts', 'e1e', 'e2s', 'e2i', 'e2npts', 'e2e',\n                  'e3s', 'e3i', 'e3npts', 'e3e', 'efs', 'Eena', 'Ewait',\n                  'filename', 'sampname', 'roi', 'detune']:\n            pass\n            getattr(getattr(self, dest), i).put(getattr(getattr(scanrecord, src), i).get())\n\n    def cp_XRF(self, src_num, dest_num):\n        '''\n        Copy all positional elements of scan number src_num to scan number\n        dest_num scan numbers are indexed starting at 1\n        '''\n        src = 'scan{}'.format(src_num-1)\n        dest = 'scan{}'.format(dest_num-1)\n        for i in ['p1s', 'p2s', 'p1i', 'p2i', 'p1stp', 'p2stp',\n                  'p1ena', 'p2ena', 'curpt', 'tpp', 'ena', 'acq',\n                  'sampname']:\n            getattr(getattr(self, dest), i).put(getattr(getattr(scanrecord, src), i).get())\n\n    def disable_scans(self):\n        for i in range(0, 16):\n            scan = 'scan{}'.format(i)\n            getattr(getattr(scanrecord, scan), 'ena').put(0)\n            getattr(getattr(scanrecord, scan), 'Eena').put(0)\n\n    def update_metadata(self):\n        md = RE.md['proposal']\n        # print(self.cycle.pvname)\n        # print(self.cycle.connected)\n        # if (self.cycle.connected is True):\n        if True:\n            self.proposal_num.put(str(md['proposal_id']))\n            self.proposal_title.put(str(md['title']))\n            # self.SAF.put(str(md['saf_num']))\n            self.PI.put(str(md['pi_name']))\n            self.cycle.put(str(RE.md['cycle']))\n            print('Scanrecord updated.')\n        else:\n            print('Scanrecord NOT updated...')\n\n    current_scan = Cpt(EpicsSignal, 'Scan:CUR')\n    current_scan_id = Cpt(EpicsSignal, 'Scan:CUR_ID')\n    current_type = Cpt(EpicsSignal, 'Scan:TYPE')\n    time_remaining = Cpt(EpicsSignal, 'Scan:REMTIME')\n    scanning = Cpt(EpicsSignal, 'Scan:ENA')\n\n    proposal_num = Cpt(EpicsSignal, 'PROPOSAL_NUM')\n    # If len(string) > 40 characters, then it needs to be a waveform on the IOC\n    proposal_title = Cpt(EpicsSignal, 'PROPOSAL_TITLE', string=True)\n    SAF = Cpt(EpicsSignal, 'SAF_NUM')\n    PI = Cpt(EpicsSignal, 'PI_NAME')\n    cycle = Cpt(EpicsSignal, 'CYCLE')"
  },
  {
    "class_name": "OneScan",
    "bases": [
      "Device"
    ],
    "file": "profile-collections/srx-profile-collection/startup/40-scanutils.py",
    "source": "class OneScan(Device):\n        p1s = Cpt(EpicsSignal, 'P1-S')\n        p2s = Cpt(EpicsSignal, 'P2-S')\n        p1i = Cpt(EpicsSignal, 'P1-I')\n        p2i = Cpt(EpicsSignal, 'P2-I')\n        p1stp = Cpt(EpicsSignal, 'P1-STP')\n        p2stp = Cpt(EpicsSignal, 'P2-STP')\n        p1npts = Cpt(EpicsSignalRO, 'P1-NPTS')\n        p2npts = Cpt(EpicsSignalRO, 'P2-NTPS')\n        p1e = Cpt(EpicsSignalRO, 'P1-E')\n        p2e = Cpt(EpicsSignalRO, 'P2-E')\n        p1ena = Cpt(EpicsSignal, 'P1-ENA')\n        p2ena = Cpt(EpicsSignal, 'P2-ENA')\n        curpt = Cpt(EpicsSignal, 'CURPT')\n        npts = Cpt(EpicsSignalRO, 'NPTS')\n        tpp = Cpt(EpicsSignal, 'TPP')\n        ena = Cpt(EpicsSignal, 'ENA')\n        acq = Cpt(EpicsSignal, 'ACQ')\n        e1s = Cpt(EpicsSignal, 'E1-S')\n        e1i = Cpt(EpicsSignal, 'E1-I')\n        e1npts = Cpt(EpicsSignal, 'E1-NPTS')\n        e1e = Cpt(EpicsSignal, 'E1-E')\n        e2s = Cpt(EpicsSignal, 'E2-S')\n        e2i = Cpt(EpicsSignal, 'E2-I')\n        e2npts = Cpt(EpicsSignal, 'E2-NPTS')\n        e2e = Cpt(EpicsSignal, 'E2-E')\n        e3s = Cpt(EpicsSignal, 'E3-S')\n        e3i = Cpt(EpicsSignal, 'E3-I')\n        e3npts = Cpt(EpicsSignal, 'E3-NPTS')\n        e3e = Cpt(EpicsSignal, 'E3-E')\n        efs = Cpt(EpicsSignal, 'EF-S')\n        Eena = Cpt(EpicsSignal, 'E-ENA')\n        Ewait = Cpt(EpicsSignal, 'E-WAIT')\n        filename = Cpt(EpicsSignal, 'FILEN')\n        sampname = Cpt(EpicsSignal, 'SAMPN')\n        roi = Cpt(EpicsSignal, 'ROIN')\n        detune = Cpt(EpicsSignal, 'DETUNE')"
  }
]